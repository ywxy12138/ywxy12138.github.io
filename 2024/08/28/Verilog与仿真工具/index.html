<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Verilog与仿真工具 | yumooo</title><meta name="author" content="聿尛"><meta name="copyright" content="聿尛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Verilog与仿真工具Verilog建模Verilog 模型可以描述实际电路中不同级别的抽象。所谓不同的抽象级别，是指同一个物理电路，可以在不同的层次上用 Verilog 语言来描述它。在这里，不同的层次可以理解为：电路的某个功能部件是由更小的、功能较为简单的部件连接组合而成的，因此可以将不同的部件划分在不同的层次。使用硬件描述语言（HDL）对系统进行抽象，可以在不同层次观察系统。类似于 C 语">
<meta property="og:type" content="article">
<meta property="og:title" content="Verilog与仿真工具">
<meta property="og:url" content="http://ywxy12138.github.io/2024/08/28/Verilog%E4%B8%8E%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7/index.html">
<meta property="og:site_name" content="yumooo">
<meta property="og:description" content="Verilog与仿真工具Verilog建模Verilog 模型可以描述实际电路中不同级别的抽象。所谓不同的抽象级别，是指同一个物理电路，可以在不同的层次上用 Verilog 语言来描述它。在这里，不同的层次可以理解为：电路的某个功能部件是由更小的、功能较为简单的部件连接组合而成的，因此可以将不同的部件划分在不同的层次。使用硬件描述语言（HDL）对系统进行抽象，可以在不同层次观察系统。类似于 C 语">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ywxy12138.github.io/img/HDL.jpg">
<meta property="article:published_time" content="2024-08-28T15:40:02.000Z">
<meta property="article:modified_time" content="2024-09-07T04:38:16.364Z">
<meta property="article:author" content="聿尛">
<meta property="article:tag" content="Verilog">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ywxy12138.github.io/img/HDL.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://ywxy12138.github.io/2024/08/28/Verilog%E4%B8%8E%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 聿尛","link":"链接: ","source":"来源: yumooo","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Verilog与仿真工具',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-09-07 12:38:16'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/self/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E8%8A%B1%E9%AC%98.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/HDL.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="yumooo"><span class="site-name">yumooo</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Verilog与仿真工具</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-28T15:40:02.000Z" title="发表于 2024-08-28 23:40:02">2024-08-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-07T04:38:16.364Z" title="更新于 2024-09-07 12:38:16">2024-09-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0/">北航计组笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Verilog与仿真工具"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Verilog与仿真工具"><a href="#Verilog与仿真工具" class="headerlink" title="Verilog与仿真工具"></a>Verilog与仿真工具</h1><h2 id="Verilog建模"><a href="#Verilog建模" class="headerlink" title="Verilog建模"></a>Verilog建模</h2><p>Verilog 模型可以描述实际电路中不同级别的抽象。所谓不同的抽象级别，是指同一个物理电路，可以在不同的层次上用 Verilog 语言来描述它。在这里，不同的层次可以理解为：电路的某个功能部件是由更小的、功能较为简单的部件连接组合而成的，因此可以将不同的部件划分在不同的层次。使用硬件描述语言（HDL）对系统进行抽象，可以在不同层次观察系统。类似于 C 语言当中，函数调用是对一组表达式集合的抽象。我们将着重于硬件设计的两类仿真级别：结构级建模以及行为级建模。</p>
<p>结构级建模和行为级建模是一对相辅相成的关系。在电路中，我们既需要对某一模块（部件）的行为、功能进行描述，也要在已设计好的模块之间进行连接，完成上层结构的建模。进一步讲，其又可以作为新的功能模块，供更上层的结构建模中使用，以此类推。</p>
<p>在进行电路刻画时，可用原理图（Schematic）进行表示。原理图通常包括器件（components）以及连线（wires），其中连线用于连接各器件。原理图具有输入输出，因此原理图描述的电路本身也可以作为器件使用，从而易于层次化设计。</p>
<p>使用 Verilog 语言进行结构级建模时，可将原理图中器件及连线映射为相应的语言描述要素，从而完成建模。该层次建模描述使用低层次器件（如常见简单门电路）描述模块（module），同时使用连线描述系统内各模块输入输出间的关系。</p>
<p>行为级建模则着力于&#x3D;&#x3D;使用系统输出及输入的作用关系&#x3D;&#x3D;。</p>
<p>同一个电路可以在上述两种级别分别进行建模。一般来讲，完成复杂电路的设计往往需要两种级别建模方式的参与。</p>
<p>复杂数字逻辑电路和系统的层次化、结构化设计意味着硬件设计方案的逐次分解。在设计过程的任意层次，硬件至少有一种描述建模形式。在集成电路设计的一层中，硬件可分解为一些模块（基本单元），这一层的硬件结构由这些模块的互连进行描述，该层次的硬件行为则由这些模块的行为描述。其中，基本单元可由下一层的基本单元互连而成。如此，完整的硬件设计可以由一棵倒置的设计树进行描述。在这棵设计树上，节点对应基本单元的描述，枝干对应于单元结构分解。</p>
<p>常用的硬件系统设计方法主要分为&#x3D;&#x3D;自顶向下设计&#x3D;&#x3D;以及&#x3D;&#x3D;自底向上设计&#x3D;&#x3D;两种：</p>
<p>在自顶向下设计（Top-down design）当中，从顶层开始，进行功能划分和结构设计，重写行为建模至结构建模，直到可使用元件&#x2F;原语（primitive）进行描述；</p>
<p>从底向上设计（Bottom-up design）当中，从简单门器件出发（通常复用已制造的标准基本单元模块），逐层搭建更复杂的模块，直到实现顶层行为要求。</p>
<p>更进一步，电路的完整 Verilog HDL 模型是由若干个 Verilog HDL 模块构成的，每一个模块又可以由若干个子模块构成。这些模块可以分别用不同抽象级别的 Verilog HDL 描述，在一个模块中也可以有多种级别的描述。利用 Verilog HDL 语言结构所提供的这种功能就可以构造一个模块间的清晰层次结构来描述极其复杂的大型设计。</p>
<h3 id="结构级建模"><a href="#结构级建模" class="headerlink" title="结构级建模"></a>结构级建模</h3><p>结构化建模就是把基本门和&#x2F;或功能单元（主要是我们自己定义的模块）连接起来，从而产生特定的功能元件。结构化建模的过程，类似于我们在 Logisim 中连接一个电路， Logisim 为我们封装好了不同的模块，我们需要完成的只是对不同模块的连接。</p>
<p>在 Verilog 中，结构化建模的主要表现形式为<strong>实例化（instantiate）</strong>。通俗来讲，实例化就是利用某个模板所创建一个其所对应的实体的过程。我们想要使用一个元件前，需要对其进行<strong>实例化</strong>。在实例化的同时，我们需要指定模块输入输出端口与对应的信号。</p>
<p>对电路元件进行实例化的最常见语法是：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">模块名 实例名<span class="hljs-comment">(端口信号映射)</span>;<span class="hljs-comment">//模块名类似类名，实例名类似对象名</span><br></code></pre></td></tr></table></figure>

<p>其中，端口信号映射的格式也有两种：</p>
<ol>
<li><strong>位置映射</strong>：<code>模块名 实例名(信号1, 信号2, ...)</code>，其中信号 n 对应被实例化模块声明时排在第 n 位的端口。</li>
<li><strong>名映射</strong>：<code>模块名 实例名(.端口名a(信号1), .端口名b(信号2), ...)</code>，其中信号 n 对应其前的端口名。</li>
</ol>
<p>值得注意的是，在实例化元件时，<code>wire</code> 类型信号可以被连接至任意端口上，但 <code>reg</code> 类型的信号只能被连接至元件的<strong>输入端口</strong>上。在声明元件时，我们可以将任意端口声明为 <code>wire</code> 类型，但只能将&#x3D;&#x3D;输出端口声明为 <code>reg</code> 类型&#x3D;&#x3D;，否则会出现问题。</p>
<p>Verilog 中已经为我们预备好了一系列基本功能元件，称为&#x3D;&#x3D;原语&#x3D;&#x3D;，主要包括：</p>
<p><code>and</code>, <code>nand</code>, <code>or</code>, <code>nor</code>, <code>xor</code>, <code>xnor</code> 这些 n 输入原语和 <code>not</code> 这一 n 输出原语</p>
<p>n 输入原语可以有多个输入，只能通过位置映射连接，对应端口连接顺序为输出, 输入1, 输入2, 输入3, …</p>
<p>n 输出原语可以有多个输出，只能通过位置映射连接，对应端口连接顺序为输出1, 输出2, …, 输出n, 输入</p>
<p>下面来看一个例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">module Adder(<br>    <span class="hljs-selector-tag">input</span> <span class="hljs-selector-tag">a</span>, <br>    <span class="hljs-selector-tag">input</span> <span class="hljs-selector-tag">b</span>, <br>    <span class="hljs-selector-tag">input</span> cin, <br>    output sum, <br>    output <span class="hljs-attribute">overflow</span><br>    );<br>    wire s1, s2, s3;<br>    //xor 与 and 均为原语，是系统预定义的模块<br>    xor xor1(sum, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, cin);<br>    and and1(s1, <span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>);<br>    and and2(s2, <span class="hljs-selector-tag">a</span>, cin);<br>    and and3(s3, <span class="hljs-selector-tag">b</span>, cin);<br>    or or1(<span class="hljs-attribute">overflow</span>, s1, s2, s3);<br>endmodule   <br></code></pre></td></tr></table></figure>

<p>对应的电路图如下所示：</p>
<p><img src="/img/5.4.2.1.png" alt="电路图"></p>
<h3 id="行为级描述"><a href="#行为级描述" class="headerlink" title="行为级描述"></a>行为级描述</h3><p>对于一个复杂电路来说门级电路结构看起来会相当复杂。而且，使用 Verilog 描述的电路，一般最终都需要转换出实物，而同样的逻辑门，在不同的实现工艺上成本也会不同。因此，利用门级电路的结构直接对一个模块进行描述时，可能就显得不够灵活。</p>
<p>为了解决这些问题我们可以用比较直观的行为级描述进行电路的设计。使用行为级描述设计电路时，我们主要描述电路输入信号和输出信号间的逻辑关系，关注电路“<strong>干什么</strong>”而不是“<strong>怎么做</strong>”。低层次内部结构和实现细节等的考虑，以及将其转化为物理电路的过程，都由有关软件自动完成。其中这一转化过程就叫**综合 (synthesis)**。</p>
<p>值得注意的是，Verilog 的行为级描述并不意味着我们可以“为所欲为”。正如上文所说，任何电路设计最终都要着眼于最终的实现。综合工具的能力是有限的，并不是所有的结构都可以被有效的转换成真实的电路结构。<strong>因此在编写代码时，我们也要注重自己编写的代码的可综合性，了解自己代码对应的真实电路</strong>。</p>
<p>行为级描述的方法一般有两种：</p>
<ol>
<li>利用连续赋值语句 <code>assign</code> 描述电路。</li>
<li><ol start="2">
<li>利用 <code>initial</code> 结构、<code>always</code> 结构和过程控制语句描述电路。</li>
</ol>
</li>
</ol>
<h4 id="连续赋值语句-assign"><a href="#连续赋值语句-assign" class="headerlink" title="连续赋值语句 assign"></a>连续赋值语句 assign</h4><p>一种很重要的行为级描述就是连续赋值语句，其常见形式为：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">assign signal <span class="hljs-operator">=</span> expression<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>signal</code> 必须是&#x3D;&#x3D;<strong><code>wire</code></strong>&#x3D;&#x3D;型数据，而 <code>expression</code> 则是由数据和运算符组成的表达式。</p>
<p><code>assign</code> 语句的作用是将右侧表达式的值&#x3D;&#x3D;持续性&#x3D;&#x3D;的赋给左侧的信号，一般用于描述一个信号是如何由其他信号生成的。所谓持续性，指的是当右侧表达式中的变量发生变化时，左侧信号的值也会随之变化。</p>
<p><code>assign</code> 语句非常适合简单的组合逻辑的描述，经常与三目运算符配合使用。一般来说，<code>assign</code> 语句综合出来的电路是右侧表达式化简后所对应的逻辑门组合。</p>
<h4 id="过程控制语句与有关结构"><a href="#过程控制语句与有关结构" class="headerlink" title="过程控制语句与有关结构"></a>过程控制语句与有关结构</h4><p>一个电路的输出，可以由<strong>输入信号</strong>决定（此时为纯粹的组合逻辑电路），也可以由<strong>输入信号</strong>和<strong>电路当前的状态</strong>决定（此时电路一般为时序电路）。我们可以把电路的当前状态（如果有）和电路的输出抽象为一些<strong>变量</strong>。通过描述不同条件下对这些<strong>变量的变化规律</strong>来描述电路，这就是利用过程控制语句与有关结构进行的行为级描述。</p>
<p>上文所述的变量，其实就是 <code>Verilog</code> 中的 <code>reg</code> 类型数据。要注意的是，<code>reg</code> 类型数据只是一个变量，用途是方便我们的描述，并不一定对应一个真实电路中的寄存器。综合工具在综合时，会通过对整体结构的分析，来判断电路具体如何实现。</p>
<p>利用过程控制语句与有关结构进行的行为级描述时，我们要解决两个主要问题：</p>
<ol>
<li>如何将<strong>变量</strong>和模块的<strong>输出</strong>建立起关系。</li>
<li>如何<strong>描述</strong>不同情况下各变量的<strong>变化规律</strong>。</li>
</ol>
<h5 id="变量和模块输出间的关系"><a href="#变量和模块输出间的关系" class="headerlink" title="变量和模块输出间的关系"></a>变量和模块输出间的关系</h5><p>一般可以采用两种方法将变量和模块的输出建立起联系：</p>
<ol>
<li>采用 <code>assign</code> 语句，将变量的值赋给输出信号（此时输出信号为 <code>wire</code> 型）</li>
<li>直接将 <code>output</code> 端口声明为 <code>reg</code> 型</li>
</ol>
<h5 id="变量变化规律的描述"><a href="#变量变化规律的描述" class="headerlink" title="变量变化规律的描述"></a>变量变化规律的描述</h5><p>我们采用过程控制语句对变量的变化进行描述。过程控制语句与我们学习过的 C 语言有一定相似，主要包括&#x3D;&#x3D;阻塞&#x2F;非阻塞&#x3D;&#x3D;赋值语句、<code>if</code>&#x2F;<code>case</code> 等条件语句以及各种循环语句。</p>
<p>过程控制语句不能直接存在于模块内，一般<strong>只能在</strong> <code>initial</code> 或 <code>always</code> 结构中出现（<em>还可以出现在任务和函数中，但是我们的实验基本上不会涉及</em>）。一个模块中可以包含多个 <code>initial</code> 或 <code>always</code> 结构。多个 <code>initial</code> 或 <code>always</code> 结构中的语句会同时执行。</p>
<h6 id="两种基本结构和语句块"><a href="#两种基本结构和语句块" class="headerlink" title="两种基本结构和语句块"></a>两种基本结构和语句块</h6><p> initial 结构</p>
<p><code>initial</code> 结构，形式为 <code>initial 语句（块）</code>，从仿真 0 时刻开始执行其中的语句。在整个仿真过程中只执行一次，一般用于&#x3D;&#x3D;初始化&#x3D;&#x3D;某些变量的值。</p>
<p> always 结构</p>
<p><code>always</code> 结构，形式为 <code>always@(敏感条件列表) 语句（块）</code>，从&#x3D;&#x3D;仿真 0 时刻开始执行&#x3D;&#x3D;。</p>
<p>敏感条件列表一般由多个敏感条件之间用 <code>or</code> 连接形成。<code>always</code> 条件语句在敏感条件列表中有任一条件满足时被触发。</p>
<p>敏感条件主要分为两种：&#x3D;&#x3D;边沿敏感和电平敏感&#x3D;&#x3D;，一般不应混用。</p>
<p>边沿敏感条件的格式为 <code>posedge/negedge 信号名</code>，表明信号在处于上升沿&#x2F;下降沿的时候会执行结构中的语句，一般用于时序逻辑的描述。</p>
<p>电平敏感条件的格式为信号名，表明该信号发生改变（注意不是为真）时会执行结构中的语句，一般用于组合逻辑的描述。</p>
<p>使用 <code>always</code> 结构描述组合逻辑时，可以使用 <code>always@(*)</code> 的简写，表示语句中所涉及到变量的任何变化都会引起该 <code>always</code> 结构的执行。</p>
<p>可省去 <code>@(敏感条件列表)</code>，此时整个结构无条件执行，一次执行完毕后，立即重新开始执行。一般配合延迟语句在 <code>testbench</code> 的编写中使用，例如：<code>always #5 clk = ~clk;</code></p>
<p>语句块</p>
<p>块语句的作用是将多条语句合并成一组，使它们像一条语句那样。在使用上一节提到的各种控制语句或者要使用 <code>always</code>&#x2F;<code>initial</code> 过程块时，如果要执行多条语句，就可以使用块语句，这就类似于 C 语言中大括号里的语句。</p>
<p>块语句有两种：顺序块和并行块。顺序块的关键字是 <code>begin</code> - <code>end</code>，并行块的关键字是 <code>fork</code> - <code>join</code>，关键字位于块语句的起始位置和结束位置，相当于 C 语言中的左大括号和右大括号。块语句也可以嵌套。</p>
<p>从名字就可以看出这两种块的特点，顺序块中的语句是顺序执行的，而并行块中的语句是并行执行的。在我们的实验中只会用到顺序块，顺序块有以下特点：</p>
<ol>
<li>顺序块中的语句是一条接一条按顺序执行的，只有前面的语句执行完成之后才能执行后面的语句，除非是带有内嵌延迟控制的非阻塞赋值语句。</li>
<li>如果语句包括延迟，那么延迟总是相对于前面那条语句执行完成的仿真时间的。</li>
</ol>
<p>配合语句块使用，两种基本结构的格式就变为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br><span class="hljs-comment">// more procedural statements</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span>@(<span class="hljs-comment">/*敏感条件列表*/</span>) <span class="hljs-keyword">begin</span><br><span class="hljs-comment">// more procedural statements</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h6 id="常见的过程控制语句"><a href="#常见的过程控制语句" class="headerlink" title="常见的过程控制语句"></a>常见的过程控制语句</h6><p><strong>i. <code>if</code> 语句</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">if</span> (expression1)<br>    statement1;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expression2)<br>    statement2;<br><span class="hljs-keyword">else</span><br>    statement3;<br></code></pre></td></tr></table></figure>

<p><strong>ii. <code>while</code> 语句</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">while</span> (expression)<br>    statement;<br></code></pre></td></tr></table></figure>

<p><strong>iii. <code>for</code> 语句</strong></p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">for</span> (expression1; expression2; expression3)<br>    statement;<br></code></pre></td></tr></table></figure>

<p>其中，每个 statement 可能是阻塞赋值语句或非阻塞赋值语句。他们在仿真时具有不同的行为。</p>
<h4 id="过程控制语句描述的一般用法"><a href="#过程控制语句描述的一般用法" class="headerlink" title="过程控制语句描述的一般用法"></a>过程控制语句描述的一般用法</h4><p><code>always</code> 块实现组合逻辑的一般格式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(*) <span class="hljs-keyword">begin</span><br><span class="hljs-comment">// 采用阻塞赋值，描述电路的变化规律</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>always块实现时序逻辑的一般格式为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span>@(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br><span class="hljs-comment">// 采用非阻塞赋值，描述电路的变化规律</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>注意：不要混用阻塞和非阻塞赋值，&#x3D;&#x3D;<strong>尽量只在组合逻辑中使用阻塞赋值，只在时序逻辑中使用非阻塞赋值</strong>&#x3D;&#x3D;。</p>
<h2 id="ISE入门"><a href="#ISE入门" class="headerlink" title="ISE入门"></a>ISE入门</h2><h3 id="输入输出设计"><a href="#输入输出设计" class="headerlink" title="输入输出设计"></a>输入输出设计</h3><p>定义模块：工程管理视窗单击右键 -&gt; New source -&gt; <strong>Verilog Module</strong></p>
<table>
<thead>
<tr>
<th>Module Name</th>
<th>模块名</th>
</tr>
</thead>
<tbody><tr>
<td>Port Name</td>
<td>端口名</td>
</tr>
<tr>
<td>Direction</td>
<td>端口方向</td>
</tr>
<tr>
<td>Bus</td>
<td>不勾选表示该端口为一位信号，勾选表示该端口为多位信号</td>
</tr>
<tr>
<td>MSB</td>
<td>最高位</td>
</tr>
<tr>
<td>LSB</td>
<td>最低位</td>
</tr>
</tbody></table>
<h3 id="语言模板辅助工具"><a href="#语言模板辅助工具" class="headerlink" title="语言模板辅助工具"></a>语言模板辅助工具</h3><p>ISE 中内嵌的语言模板包括了大量的开发实例以及 FPGA 语法的介绍和举例。</p>
<ul>
<li>Verilog HDL &#x2F; HDL 常用模块</li>
<li>FPGA 原语使用实例</li>
<li>约束文件的语法规则</li>
<li>各类指令和符号的说明</li>
</ul>
<p>语言模板不仅可在设计中直接使用，还是辅助 FPGA 开发的工具手册。</p>
<p>选择 Edit -&gt; Language Templates 打开语言模板</p>
<h3 id="语言模板的使用"><a href="#语言模板的使用" class="headerlink" title="语言模板的使用"></a>语言模板的使用</h3><p><code>$readmemh</code>函数的参数依次是<strong>数据文件路径</strong>、<strong>目标寄存器</strong>、<em>起始地址</em>和<em>终止地址</em>，其中起始地址和终止地址是可选项，因此该语句有三种用法：<code>$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;);</code> <code>$readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;,&lt;起始地址&gt;);`` $readmemh(&quot;&lt;数据文件名&gt;&quot;,&lt;存储器名&gt;,&lt;起始地址&gt;,&lt;终止地址&gt;); </code>导入格式为十六进制形式。</p>
<p><code>$readmemb</code>函数的用法类似，只不过导入的是二进制形式。</p>
<h2 id="VCS入门"><a href="#VCS入门" class="headerlink" title="VCS入门"></a>VCS入门</h2><h3 id="VCS与Verdi简介"><a href="#VCS与Verdi简介" class="headerlink" title="VCS与Verdi简介"></a>VCS与Verdi简介</h3><p>VCS 是一款编译型的 Verilog 仿真器。它能够将 Verilog 像编译 C 语言程序那样编译成一个可执行文件，只需运行这个可执行文件，就能进行仿真。VCS 的编译与运行都是以命令行形式完成的。</p>
<p>Verdi 是一个调试平台。它能够查看 VCS 仿真程序的运行轨迹、波形，同时对仿真过程中的值来源、错误原因进行追踪和分析。</p>
<h3 id="VCS项目结构"><a href="#VCS项目结构" class="headerlink" title="VCS项目结构"></a>VCS项目结构</h3><p>为了使 VCS 上手更加容易，我们准备了一个 VCS 工程示例文件，位于 <code>~/VCS-Example</code> 文件夹中，（*<code>~</code>是一个缩写，代表用户的主目录(home)，课程所用虚拟机中用户的主目录的路径为<code>/home/co-eda</code>。*）其内容如下图所示。在完成题目时，可直接将此示例工程复制，并在其基础上修改、完成你的设计。</p>
<p>本示例工程中，各个文件的作用列举如下。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">.<br>├── clean.sh           # 脚本文件，用于清除编译产生的可执行文件和缓存<br>├── compile.sh         # 脚本文件，执行此脚本，即可将 Verilog 源代码文件编译为可执行文件<br>├── README.md          # 工程说明文件，可直接双击打开<br>├── run.sh             # 脚本文件，执行该脚本即可运行编译出的可执行文件，启动仿真<br>├── sim                # 空文件夹，用于存放编译、仿真的结果<br>├── src                # 存放源代码的文件夹<br>│   ├── adder.v        # 一个示例 Verilog 文件，简单的加法器<br>│   └── tb.v           # 一个示例 Testbench 文件<br>└── verdi.sh           # 脚本文件，执行该脚本可以打开 Verdi，查看仿真产生的波形<br></code></pre></td></tr></table></figure>

<p>项目目录下，<code>.sh</code> 结尾的文件是&#x3D;&#x3D;脚本文件&#x3D;&#x3D;，用于执行一些&#x3D;&#x3D;常用任务&#x3D;&#x3D;；<code>src</code> 目录存放了&#x3D;&#x3D;设计的源代码&#x3D;&#x3D;和&#x3D;&#x3D;Testbench&#x3D;&#x3D;；<code>sim</code> 目录将存放编译好的&#x3D;&#x3D;二进制文件&#x3D;&#x3D;和运行时产生的&#x3D;&#x3D;波形&#x3D;&#x3D;。</p>
<h3 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h3><p>若要开始仿真，首先需要将 Verilog 源代码编译为可执行文件。在 VCS-Example 文件夹中打开终端，并输入 <code>./compile.sh</code>，就可以编译项目了。执行命令后，会看到 VCS 的运行日志，如果编译成功，则输出类似这样：</p>
<p><img src="/img/compile.png" alt="示例"></p>
<p>运行 <code>cat compile.sh</code> 或用 Sublime Text 打开 <code>compile.sh</code>，即可查看这个脚本的代码。第一行为 Shebang；<code>#</code> 开头的行为注释；具有实际功能的是最后一行，其调用 <code>vcs</code> 命令进行编译，将 <code>src</code> 目录下的所有 <code>.v</code> 文件编译为 <code>sim</code> 文件夹下的 <code>simv</code> 文件。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">#!/bin/bash<br><br># full64: 指定使用 64 位 VCS<br># src/*.v: 所有源代码文件<br># -o sim/simv: 输出文件路径<br># -fsdb: 输出 fsdb 波形文件需要指定此选项<br># -kdb: 生成源代码数据库文件，供 Verdi 显示源代码使用<br># -q: 减少日志数量（安静模式）<br>vcs -full64 src/*.v -o sim/simv -fsdb -kdb -q<br><br></code></pre></td></tr></table></figure>

<h2 id="Verilog语法"><a href="#Verilog语法" class="headerlink" title="Verilog语法"></a>Verilog语法</h2><h3 id="模块的定义方法"><a href="#模块的定义方法" class="headerlink" title="模块的定义方法"></a>模块的定义方法</h3><p>模块（module）是 Verilog HDL 的基本功能单元，它实际上代表了具有一定功能的&#x3D;&#x3D;电路实体&#x3D;&#x3D;。通俗来讲，其代表了电路中被导线连接的各个功能模块（子电路）。</p>
<p>下面我们通过一个简单的&#x3D;&#x3D;与门（&amp;）&#x3D;&#x3D;实例来说明模块定义的基本语法：（<strong>Verilog HDL 的注释方式与 C 语言相同</strong>）</p>
<p>法1：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> AndGate(<br>    <span class="hljs-keyword">input</span> i1,<br>    <span class="hljs-keyword">input</span> i2,<br>    <span class="hljs-keyword">output</span> o<span class="hljs-comment">//注意这里可没有逗号，易错点</span><br>    ); <span class="hljs-comment">// 模块名定义、端口定义及IO说明</span><br>    <span class="hljs-keyword">assign</span> o = i1 &amp; i2; <span class="hljs-comment">// 模块功能定义</span><br><span class="hljs-keyword">endmodule</span> <span class="hljs-comment">// 结束模块定义</span><br></code></pre></td></tr></table></figure>

<p>法2：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> AndGate(i1,i2,o); <span class="hljs-comment">// 模块名定义及端口定义</span><br>    <span class="hljs-keyword">input</span> i1;<br>    <span class="hljs-keyword">input</span> i2; <span class="hljs-comment">// 也可合并为一句: input i1,i2;</span><br>    <span class="hljs-keyword">output</span> o;<br>    <span class="hljs-comment">// 上为IO说明</span><br>    <span class="hljs-keyword">assign</span> o = i1 &amp; i2; <span class="hljs-comment">// 模块功能定义</span><br><span class="hljs-keyword">endmodule</span> <span class="hljs-comment">// 结束模块定义</span><br></code></pre></td></tr></table></figure>

<p>两种方法没有实质上的区别，只是形式上有所不同：方法 1 对方法 2 中的端口定义及 IO 说明进行了&#x3D;&#x3D;合并&#x3D;&#x3D;。(定义略有差别)</p>
<p>从上面的例子可以看出，一个模块以&#x3D;&#x3D;<code>module</code>&#x3D;&#x3D;开始，以 &#x3D;&#x3D;<code>endmodule</code>&#x3D;&#x3D; 结束，包括<strong>模块名</strong>、<strong>端口定义</strong>、<strong>I&#x2F;O （input&#x2F;output）说明</strong>、<strong>内部信号声明</strong>和<strong>功能定义</strong>等部分。需要指出的是，<strong>模块中的语句除了顺序块之外，都是“并行的”</strong>（&#x3D;&#x3D;同时执行的&#x3D;&#x3D;）；输入输出端口若不特别说明类型及位宽，<strong>默认为 1 位 <code>wire</code> 型</strong>。</p>
<p><strong>只有连续赋值语句<code>assign</code>和实例引用语句可以独立于过程块而存在于模块的功能定义部分。</strong></p>
<p><strong>在一个模块中改变另一个模块的参数时，需使用<code>defparam</code>命令。</strong></p>
<h3 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h3><h4 id="wire型"><a href="#wire型" class="headerlink" title="wire型"></a>wire型</h4><p><code>wire</code> 型数据属于线网 <code>nets</code> 型数据（<code>nets</code>型变量不能储存值，必须受到驱动器（门、<code>assign</code>等）的驱动，若为驱动该变量就是高阻的，值为z），通常用于表示<strong>组合逻辑信号</strong>，可以将它类比为电路中的导线。它本身并不能存储数据，需要<strong>有输入才有输出</strong>（这里输入的专业术语叫驱动器），且输出随着输入的改变而即时改变。<strong>一般使用 <code>assign</code> 语句对 <code>wire</code> 型数据进行驱动</strong>。</p>
<p><code>wire</code> 型的数据分为标量（1 位）和向量（多位）两种。<strong>可以在声明过程中使用范围指示器指明位数</strong>，如 <code>wire [31:0] a;</code>。冒号两侧分别代表最高有效位（MSB, Most Significant Bit）和最低有效位（LSB, Least Significant Bit）。在访问时，可以使用形如 <code>a[7:4]</code> (注意是<code>：</code>，而不是<code>，</code>)的方式取出 a 的第 7-4 位数据。</p>
<p>一般<strong>在使用 <code>wire</code> 型数据前应先声明它</strong>。但如果在模块实例的端口信号列表中使用了一个未声明的变量，则会将其<strong>默认定义为 1 位的 <code>wire</code> 变量</strong>。</p>
<p>需要注意的是，信号变量与 C 语言中的变量有所不同，不能像 C 语言一样随意赋值，一般需要按照组合逻辑的规则进行操作。比如，对于 <code>wire</code> 型变量 <code>a</code>，&#x3D;&#x3D;<code>assign a = a + 1</code>是不合法的&#x3D;&#x3D;。</p>
<p>wire 型数据类型不具有存储功能，它类比于电路中的导线，只能将信号直接相连，无法存储。</p>
<p>注意：</p>
<p>1.使用向量时，大小端顺序必须与声明时的顺序保持一致。声明时为<code>[3:0]</code> a,那么<code>a[0:3]</code>是错误的写法。</p>
<p>2.使用未经声明的变量不会导致错误。变量未经声明即使用时默认为 1 位 <code>wire</code> 型变量。</p>
<p>3.声明<code>wire</code>型向量：wire[num1:num2] a(其中num1,num2为整数常量)，则num1,num2的值&#x3D;&#x3D;可以是负数&#x3D;&#x3D;，且&#x3D;&#x3D;num1、num2中的较大值可在前也可在后&#x3D;&#x3D;。</p>
<p>4.使用assign语句时，若左右两侧位宽不一致时，会对右侧变量进行扩展或截断，使之与左侧变量位宽相等。</p>
<p>5.<code>wire</code> 型变量不能在 always 块中被赋值,但<code>reg</code>型变量可以，可以再需要赋值时将<code>wire</code>型变量声明为<code>reg</code>类型，或另外声明<code>reg</code>的变量。</p>
<h4 id="reg型"><a href="#reg型" class="headerlink" title="reg型"></a>reg型</h4><p><code>reg</code> 型是<em>寄存器</em>数据类型，具有<strong>存储</strong>功能。它<strong>也分为标量和向量</strong>，类似 <code>wire</code> 型，可以类比前面的教程。一般<strong>在 <code>always</code> 块内</strong>使用 <code>reg</code> 型变量，通过赋值语句来改变寄存器中的值，其作用与改变触发器储存的值相当。为了确定何时进行赋值，我们经常需要用到各种控制结构，包括 <code>while</code>、<code>for</code>、<code>switch</code> 等，这与 C 语言中的做法十分相似。</p>
<p>需要注意的是，&#x3D;&#x3D;<strong><code>reg</code> 型变量不能使用 <code>assign</code> 赋值</strong>&#x3D;&#x3D;。而且，<code>reg</code> 型并<strong>不一定被综合成寄存器</strong>，还有可能被综合成 RAM 一类的存储器，它也可和 <code>always</code> 关键字配合，建模组合逻辑。</p>
<p><code>reg</code>型数据的默认初始值为不定值x。<code>reg</code>型数据可以被赋正值，也可被赋负值。但当一个<code>reg</code>型数据是一个表达式中的操作数时，其值将被当作是无符号值，即正值。</p>
<h5 id="利用-reg-数据类型建模存储器"><a href="#利用-reg-数据类型建模存储器" class="headerlink" title="利用 reg 数据类型建模存储器"></a>利用 reg 数据类型建模存储器</h5><p>我们可以通过对 <code>reg</code> 型变量建立数组来对存储器建模，例如 <code>reg [31:0] mem [0:1023];</code>，其中<strong>前面的中括号内为位宽，后面的中括号内为存储器数量</strong>。这种写法在我们开始搭建CPU后会用到。</p>
<p>我们可以通过引用操作访问存储器型数据元素，类似于位选择操作，例如 <code>mem[2]</code> 就是访问 <code>mem</code> 中的第 3 个元素。</p>
<p><code>wire</code> 数据类型和 <code>reg</code> 数据类型是 Verilog HDL 中最常用的两种数据类型，其含义与同学们之前接触的 C 语言中的数据有些不同。在这里，理解 Verilog HDL 的关键在于“站在硬件的角度”来看待程序的设计与运行。</p>
<p>需要注意的是，Verilog HDL 中&#x3D;&#x3D;没有多维数组&#x3D;&#x3D;。</p>
<h4 id="memory型"><a href="#memory型" class="headerlink" title="memory型"></a>memory型</h4><p><code>memory</code>型数据是通过扩展<code>reg</code>型数据的地址范围来生成的。格式如下：</p>
<p>​                      <code>reg [n-1:0] 存储器名[m-1:0];</code></p>
<p>或                  <code>reg [n-1:0] 存储器名[m:1];</code></p>
<p>其实就是<code>reg</code>型向量。其中<code>reg [n-1:0]</code>定义了存储器中每个存储单元的大小；而<code>[m-1:0]/[m:1]</code>则定义了存储器个数。</p>
<p>注意：一个n位的存储器和一个由n个一位存储器组成的存储器组是不同的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] rega;<span class="hljs-comment">//一个n位的存储器</span><br><span class="hljs-keyword">reg</span> mega [n-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>];<span class="hljs-comment">//一个由n个一位存储器组成的存储器组是不同的 </span><br></code></pre></td></tr></table></figure>



<h4 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h4><p>Verilog 中的数字字面量可以按二进制（b 或 B）、八进制（o 或 O）、十六进制（h 或 H）、十进制（d 或 D）表示。</p>
<p>数字的完整表达为 <code>&lt;位宽&gt;&#39;&lt;进制&gt;&lt;值&gt;</code>，如 <code>10&#39;d100</code>。省略位宽时采用默认位宽（与机器有关，一般为 <strong>32 位</strong>），省略进制时默认为<strong>十进制</strong>，值部分可以用下划线分开提高可读性，如 <code>16&#39;b1010_1011_1111_1010</code>。（</p>
<p>Verilog 中除了普通的数字以外，还有两个特殊的值：**<code>x</code>** 和 <strong><code>z</code><strong>。<code>x</code> 为不定值，当某一二进制位的值不能确定时出现，变量的</strong>默认初始值为 <code>x</code><strong>。<code>z</code> 为高阻态，代表</strong>没有连接到有效输入上</strong>。对于位宽大于 1 的数据类型，**<code>x</code> 与 <code>z</code> 均可只在部分位上出现**。</p>
<p>注意：</p>
<p>1.数字字面量定义中<code>&#39;</code>不能省略，位宽和进制可以省略，但是该进制下的数字不能超过位宽(二进制下)所能表示的最大值。例如：3’101是个错误的定义，因为进制省略，所以采用默认的十进制，而位宽为3，此位宽下十进制最大值为7&lt;101，定义错误。</p>
<p>2.可以定义负数，但是负号得写在位宽位之前，例如：32’d-100×，-32‘d100✓。</p>
<p>3.数字中间可以用短横 _ 隔开， Verilog 语法规定短横只能出现在数字之间。例如：8’b_0011_1010×。</p>
<p>4.特殊值 x 和 z 可以出现在多位数字中的某几位。例如：4’b10x0 和 4’b101z 均符合规范。</p>
<h4 id="integer型"><a href="#integer型" class="headerlink" title="integer型"></a>integer型</h4><p><code>integer</code> 数据类型一般为 32 位，与 C 语言中的 <code>int</code> 类似，<strong>默认为有符号数</strong>，在我们的实验中<strong>主要用于 <code>for</code> 循环</strong>。</p>
<h4 id="parameter-型"><a href="#parameter-型" class="headerlink" title="parameter 型"></a>parameter 型</h4><p><code>parameter</code> 类型用于<strong>在编译时确认值的常量</strong>，通过形如 <code>parameter 标识符 = 表达式;</code> 的语句进行定义，如：<code>parameter width = 8;</code>。在实例化模块时，可通过参数传递改变在被引用模块实例中已定义的参数。<code>parameter</code> 虽然看起来可变，但它属于常量，在编译时会有一个确定的值。</p>
<p><code>parameter</code> 可以用于在模块实例化时指定数据位宽等参数，便于在结构相似、位宽不同的模块之间实现代码复用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">parameter</span> msb=<span class="hljs-number">7</span>;<span class="hljs-comment">//定义参数msb位常量7</span><br><span class="hljs-keyword">parameter</span> e=<span class="hljs-number">25</span>,f=<span class="hljs-number">29</span>;<span class="hljs-comment">//定义两个常量参数</span><br><span class="hljs-keyword">parameter</span> r=<span class="hljs-number">5</span><span class="hljs-variable">.5</span>;<span class="hljs-comment">//声明r为一个实型参数</span><br><span class="hljs-keyword">parameter</span> byte_size=<span class="hljs-number">8</span>,byte_msb=byte_size-<span class="hljs-number">1</span>;<span class="hljs-comment">//用常数表达式赋值</span><br><span class="hljs-keyword">parameter</span> average_delay=(r+f)/<span class="hljs-number">2</span>;<span class="hljs-comment">//用常数表达式赋值，其中r和f在此前已定义并初始化过</span><br></code></pre></td></tr></table></figure>

<p><strong>参数型常数经常用于定义&#x3D;&#x3D;延迟时间&#x3D;&#x3D;和&#x3D;&#x3D;变量宽度&#x3D;&#x3D;。</strong>在模块或实例引用时，可通过参数传递改变在被引用模块或实例中已定义的参数。</p>
<h4 id="几个实例"><a href="#几个实例" class="headerlink" title="几个实例"></a>几个实例</h4><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] w1;<br><span class="hljs-comment">// [7:0] 为该变量的位宽，代表该变量为 8 位，可以通过索引访问任意一位。</span><br><span class="hljs-keyword">wire</span>[<span class="hljs-number">32</span>:<span class="hljs-number">1</span>] w2, w3;<br><span class="hljs-comment">// 位宽可以不从 0 开始，此时访问某一位时需与声明相符，如 w2 的最高位为 w2[32]。</span><br><span class="hljs-keyword">reg</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] r1, r2, mem[<span class="hljs-number">1023</span>:<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 可以同时声明存储器和单个 reg，存储器的地址索引同样可以不从 0 开始。</span><br><span class="hljs-number">2&#x27;b11</span>;      <span class="hljs-comment">// 2 位，对应十进制 3</span><br><span class="hljs-number">32&#x27;d12</span>;     <span class="hljs-comment">// 32 位，对应十进制 12</span><br><span class="hljs-number">32&#x27;h11</span>;     <span class="hljs-comment">// 32 位，对应十进制 17</span><br><span class="hljs-number">32&#x27;o11</span>;     <span class="hljs-comment">// 32 位，对应十进制 9</span><br><span class="hljs-number">4&#x27;b10x0</span>;    <span class="hljs-comment">// 从低位数第 2 位为不定值</span><br></code></pre></td></tr></table></figure>

<h3 id="组合逻辑建模常用语法"><a href="#组合逻辑建模常用语法" class="headerlink" title="组合逻辑建模常用语法"></a>组合逻辑建模常用语法</h3><h4 id="assign-语句"><a href="#assign-语句" class="headerlink" title="assign 语句"></a>assign 语句</h4><p><code>assign</code> 语句是&#x3D;&#x3D;连续赋值&#x3D;&#x3D;语句，是组合逻辑的建模利器，其作用是<strong>用一个信号来驱动另一个信号</strong>。如 <code>assign a = b;</code>，其中 <code>a</code> 为 <code>wire</code> 型（也可由<strong>位拼接</strong>得到，见运算符部分），<code>b</code> 是由数据和运算符组成的表达式。</p>
<p><code>assign</code> 语句与 C 语言的赋值语句有所不同，这里&#x3D;&#x3D;“驱动”的含义类似于电路的连接&#x3D;&#x3D;，也就是说，<code>a</code> 的值<strong>时刻</strong>等于 <code>b</code>。这也解释了 <code>assign a = a + 1;</code> 这样的语句为什么是不合法的。由于这样的特性，**<code>assign</code> 语句不能在 <code>always</code> 和 <code>initial</code> 块中使用**。</p>
<p><code>assign</code> 语句<strong>经常与三目运算符配合使用建模组合逻辑</strong>。一般来说，<code>assign</code> 语句综合出来的电路是右侧表达式<em>化简后所对应的逻辑门组合</em>。</p>
<p>注意：</p>
<p>1.<code>reg</code> 类型变量不可以被 <code>assign</code>；</p>
<p>2.未被驱动的 <code>wire</code> 型变量可以理解为一段没有连接任何信号的导线，它和其他导线相连是没有意义的。因此 <code>assign w2=w1(假设w1未被驱动)</code>是错误的定义。</p>
<p>3.assign 意味着左侧的信号值始终等于右侧，因此w1&#x3D;w1|w1中令 w1 始终等于 w1 | w1 是错误的。</p>
<h4 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h4><p>Verilog HDL 中有相当多的运算符都与 C 语言基本相同，如：</p>
<ul>
<li>基本运算符：<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> 等</li>
<li>位运算符：<code>&amp;</code>, <code>|</code>, <code>~</code>, <code>^</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;</code> 等</li>
<li>逻辑运算符：<code>&amp;&amp;</code>, <code>||</code>, <code>!</code> 等</li>
<li>关系运算符：<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code> 等</li>
<li>条件运算符（三目运算符）：<code>? :</code></li>
</ul>
<p>这些运算的运算规则与 C 语言相同，只是在操作数中出现了不定值 <code>x</code> 和高阻值 <code>z</code> 的话最终结果可能也是带 <code>x</code> 或 <code>z</code> 的。另外 Verilog 中没有自增、自减运算符。下面主要介绍其他与 C 不同的部分。</p>
<ul>
<li><p>逻辑右移运算符 <code>&gt;&gt;</code> 与算术右移运算符 <code>&gt;&gt;&gt;</code></p>
<p>它们的区别主要在于前者在最高位<strong>补 0</strong>(<code>&gt;&gt;</code>)，而后者在最高位<strong>补符号位</strong>(<code>&gt;&gt;&gt;</code>)。</p>
<p>注意：算术右移的运算可以通过<code>$signed($signed(a)&gt;&gt;&gt;b)</code>来表示a算术右移b位。</p>
</li>
<li><p>相等比较运算符 <code>==</code> 与 <code>===</code> 和 <code>!=</code> 与 <code>!==</code></p>
<p><code>==</code> 和 <code>!=</code> 可能由于不定值 <code>x</code> 和高阻值 <code>z</code> 的出现导致结果为<strong>不定值 <code>x</code><strong>，而 <code>===</code> 和 <code>!==</code> 的结果一定是</strong>确定的 0 或 1</strong>（<code>x</code> 与 <code>z</code> 也参与比较）。</p>
</li>
<li><p>阻塞赋值 <code>=</code> 和非阻塞赋值 <code>&lt;=</code></p>
<p>不同于 <code>assign</code> 语句，这两种赋值方式被称为&#x3D;&#x3D;过程赋值&#x3D;&#x3D;，通常出现在 <code>initial</code> 和 <code>always</code> 块中，<strong>为 <code>reg</code> 型变量赋值</strong>。这种赋值类似 C 语言中的赋值，不同于 <code>assign</code> 语句，赋值仅会在一个时刻执行。由于 Verilog 描述硬件的特性，Verilog程序内会有大量的并行，因而产生了这两种赋值方式。这里暂时只需记住一点：为了写出正确、可综合的程序，<strong>在描述时序逻辑时要使用非阻塞式赋值 <code>&lt;=</code></strong> 。</p>
</li>
<li><p>位拼接运算符 <code>&#123;&#125;</code></p>
<p>这个运算符可以将几个信号的某些位<strong>拼接</strong>起来，例如 <code>&#123;a, b[3:0], w, 3&#39;b101&#125;;</code>；可以简化重复的表达式，如 <code>&#123;4&#123;w&#125;&#125;</code> 等价于 <code>&#123;w,w,w,w&#125;</code>；还可以嵌套，<code>&#123;b, &#123;3&#123;a, b&#125;&#125;&#125;</code> 等价于 <code>&#123;b, &#123;a, b, a, b, a, b&#125;&#125;</code>，也就等价于 <code>&#123;b, a, b, a, b, a, b&#125;</code>。</p>
</li>
<li><p>&#x3D;&#x3D;缩减&#x3D;&#x3D;运算符</p>
<p>运算符 <code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）等作为单目运算符是<strong>对操作数的每一位(从低位向高位逐步运算）汇总运算</strong>，如对于 <code>reg[31:0] B;</code> 中的 <code>B</code> 来说，<code>&amp;B</code> 代表将 <code>B</code> 的<strong>每一位与起来</strong>得到的结果。</p>
</li>
</ul>
<p>注意：</p>
<p>1.同一变量不能有多个 driver, 即&#x3D;&#x3D;不能&#x3D;&#x3D;被多次赋值。</p>
<h4 id="常用实现方式："><a href="#常用实现方式：" class="headerlink" title="常用实现方式："></a>常用实现方式：</h4><ul>
<li><p><code>assign</code> 赋值语句。</p>
</li>
<li><p><code>always</code> + <strong>阻塞赋值</strong>语句。</p>
<p>建议尽量使用<code>assign</code>赋值语句的方法实现组合逻辑，只有在必要场景下才使用后者：</p>
<ol>
<li><p><strong><code>assign</code> 赋值语句的结构清晰</strong>：结合三目运算符的多层嵌套调用可以非常简洁地实现对应的组合逻辑。</p>
<p>assign方式实现ALU标程：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ALU&#123;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] inA,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] inB,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op,<br>    <span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ans<br>&#125;;<br>    <span class="hljs-keyword">assign</span> ans=(op==<span class="hljs-number">2&#x27;b00</span>)?inA+inB:<br>               (op==<span class="hljs-number">2&#x27;b01</span>)?inA-inB:<br>               (op==<span class="hljs-number">2&#x27;b10</span>)?inA|inB:<br>               (op==<span class="hljs-number">2&#x27;b11</span>)?inA&amp;inB:<br>                   <span class="hljs-number">4&#x27;b0000</span>;<br>    <span class="hljs-comment">//assign只能对wire型变量赋值，不能对reg型变量赋值</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>


</li>
<li><p><strong><code>always</code> + 阻塞赋值的实现方法容易产生混淆</strong>：方法容易与实现时序逻辑的非阻塞赋值混淆从而埋下问题，且实现的语句更为复杂。</p>
<p>always&#96; + 阻塞赋值的实现方法实现ALU标程：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> ALU&#123;<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] inA,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] inB,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ans <br>&#125;;<br>    <span class="hljs-keyword">always</span> @(*)<span class="hljs-keyword">begin</span><br>        <span class="hljs-keyword">case</span>(op)<br>            <span class="hljs-number">2&#x27;b00</span>:<span class="hljs-keyword">begin</span><br>                ans=inA+inB;<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-number">2&#x27;b01</span>:<span class="hljs-keyword">begin</span><br>                ans=inA-inB;<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-number">2&#x27;b10</span>:<span class="hljs-keyword">begin</span><br>                ans=inA|inB;<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-number">2&#x27;b11</span>:<span class="hljs-keyword">begin</span><br>                ans=inA&amp;inB;<br>            <span class="hljs-keyword">end</span><br>            <span class="hljs-keyword">default</span>:<span class="hljs-keyword">begin</span><br>                ans=<span class="hljs-number">4&#x27;b0000</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">endcase</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>3.在不考虑综合后&#x3D;&#x3D;时序开销&#x3D;&#x3D;的情况下<strong>尽量用 <code>assign</code> + 三目的形式实现组合逻辑</strong>，从而保持 <code>always</code> 代码块中仅有非阻塞赋值语句。在考虑到时序开销的情况下（计组课设不对时序开销有任2222何严格约束），可以使用形如 <code>assign result = (is_A &amp; A) | (is_B &amp; B);</code> 的形式将连续三目表达式转换为并行的 MUX。</p>
</li>
</ol>
</li>
</ul>
<h3 id="时序逻辑建模常用语法"><a href="#时序逻辑建模常用语法" class="headerlink" title="时序逻辑建模常用语法"></a>时序逻辑建模常用语法</h3><h4 id="always-块"><a href="#always-块" class="headerlink" title="always 块"></a>always 块</h4><p><code>always</code> 块有如下两种用法：</p>
<ul>
<li>若 <code>always</code> 之后紧跟 <code>@(...)</code>，其中括号内是&#x3D;&#x3D;敏感条件&#x3D;&#x3D;（触发条件）列表，表示当<strong>括号中的条件满足</strong>时，将会执行 <code>always</code> 之后紧跟的语句或<strong>顺序语句块</strong>（和 C 语言中的语句块类似，只是将大括号用 <code>begin</code> 和 <code>end</code> 替换了）。这种用法<strong>主要用于建模时序逻辑</strong>。</li>
</ul>
<p>举例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk)  <span class="hljs-comment">// 表示在 clk 上升沿触发后面的语句块</span><br><span class="hljs-keyword">begin</span><span class="hljs-comment">//代替&#123;</span><br><span class="hljs-comment">// 一些操作</span><br><span class="hljs-keyword">end</span><span class="hljs-comment">//代替&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>若 <code>always</code> 之后紧跟 &#x3D;&#x3D;<code>@ *</code>&#x3D;&#x3D; 或 &#x3D;&#x3D;<code>@(*)</code>&#x3D;&#x3D;，则表示对其后紧跟的语句或语句块内所有信号的&#x3D;&#x3D;变化敏感&#x3D;&#x3D;。这种用法主要用于与 <code>reg</code> 型数据和阻塞赋值配合，<strong>建模组合逻辑</strong>。</p>
</li>
<li><p>若 <code>always</code> 紧跟语句，则表示在该语句执行完毕之后立刻再次执行。这种用法主要配合后面提到的时间控制语句使用，来产生一些周期性的信号。</p>
</li>
</ul>
<p><code>always</code> 的敏感条件列表中，条件使用变量名称表示，例如 <code>always @(a)</code> 表示当变量 <code>a</code> 发生变化时执行之后的语句；若条件前加上 <code>posedge</code> 关键字，如 <code>always @(posedge a)</code>，表示当 <code>a</code> 达到上升沿，即从 <code>0</code> 变为 <code>1</code> 时触发条件，下降沿不触发；加上 <code>negedge</code> 则是下降沿触发条件，上升沿不触发。每个条件使用逗号 <code>,</code> 或 <code>or</code> 隔开，<strong>只要有其中一个条件被触发，<code>always</code> 之后的语句都会被执行</strong>。</p>
<p>为了良好的代码可读性与可综合性，<strong>不要在多个 <code>always</code> 块中对同一个变量进行赋值</strong>！</p>
<p>注意：</p>
<p>1.always 块既可以是边沿敏感的，也可以是电平敏感的，主要看敏感条件的书写。</p>
<p>2.&#x3D;&#x3D;在多个 always 块中对同一个变量进行赋值的代码是不可综合的。&#x3D;&#x3D;</p>
<p>3.指定端口位宽时，若形式为<code>in[a : b]</code>，则两侧的数字均不能含有变量。正确的写法是采用如下的赋值形式：</p>
<p> <code>assign out = in[sel * 4 +: 4];</code>（采用[+:]表示位宽的方式）</p>
<p> 指的一提的是，当端口位宽为 1 时，例如<code>in[sel]</code>的写法是允许的。（即本该写成<code>in[sel +: 1]</code>但允许写成<code>in[sel]</code>的形式。)</p>
<p>4.<code>always</code>块内的语句是按照书写的顺序执行的，称为“顺序语句”。</p>
<p>5.<code>always</code>块不能嵌套在<code>initial</code>块中。</p>
<h4 id="initial-块"><a href="#initial-块" class="headerlink" title="initial 块"></a>initial 块</h4><p><code>initial</code> 块后面紧跟的语句或顺序语句块在硬件仿真开始时就会运行，且仅会运行&#x3D;&#x3D;一次&#x3D;&#x3D;，一般用于对 <code>reg</code> 型变量的取值进行&#x3D;&#x3D;初始化&#x3D;&#x3D;。<code>initial</code> 块通常仅用于仿真，是<strong>不可综合的</strong>。下面的代码用于给寄存器 <code>a</code> 赋初始值 <code>0</code>：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> a;<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>Verilog 中 <code>if</code> 语句的语法和 <code>C</code> 语言基本相同，也有 <code>else if</code>、<code>else</code> 这样的用法。但是，<code>if</code> 语句<strong>只能出现在顺序块中</strong>，其后的分支也只能是语句或顺序块。举例如下（下面的例子也使用了 <code>always</code> 建模组合逻辑）：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @ * <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-keyword">begin</span><br>        out = a;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>        out = b;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>为了避免意料之外的锁存器的生成而导致错误，<strong>建议为所有的 <code>if</code> 语句都写出相应的 <code>else</code> 分支</strong>。</p>
<h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><p>Verilog 中的 <code>case</code> 语句与 C 语言的写法略有区别，详见下方的示例。<code>case</code> 语句同样<strong>只能出现在顺序块中</strong>，其中的分支也只能是语句或顺序块。与 C 语言不同，<code>case</code> 语句在<strong>分支执行结束后不会落入下一个分支</strong>，而会自动退出。举例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br> <span class="hljs-keyword">case</span>(data)<br>      <span class="hljs-number">0</span>: out &lt;= <span class="hljs-number">4</span>;<br>      <span class="hljs-number">1</span>: out &lt;= <span class="hljs-number">5</span>;<br>      <span class="hljs-number">2</span>: out &lt;= <span class="hljs-number">2</span>;<br>      <span class="hljs-number">3</span>: <span class="hljs-keyword">begin</span><br>          out &lt;= <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-keyword">default</span>: ;<br>  <span class="hljs-keyword">endcase</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>需要指出的是，<code>case</code> 语句进行的是<strong>全等比较</strong>，也就是每一位都相等（包括 <code>x</code> 和 <code>z</code>）才认为相等。另外，还有 <code>casex</code> 和 <code>casez</code> 两种语句。</p>
<h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>Verilog 中 <code>for</code> 语句的语法和 C 语言基本相同，但需要注意以下事项。</p>
<h5 id="循环变量"><a href="#循环变量" class="headerlink" title="循环变量"></a>循环变量</h5><p><strong><code>integer</code> 和 <code>reg</code> 类型的变量均可作为循环变量</strong>，使用 <code>reg</code> 类型变量作为循环变量时需要<strong>合理设置位宽</strong>，防止进入死循环状态。</p>
<p>以下为 <code>reg</code> 类型循环变量未合理设置位宽而造成的死循环示例代码（循环部分）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//此代码会造成lsim崩溃</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] temp; <br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">for</span> (temp = <span class="hljs-number">2&#x27;h0</span>; temp &lt;= <span class="hljs-number">2&#x27;h3</span>; temp = temp + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;run the loop&quot;</span>);<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;finish!&quot;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>仿真结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">run the loop<br>run the loop<br>run the loop<br>run the loop<br>run the loop<br>...<br></code></pre></td></tr></table></figure>

<p>可以发现仿真进入死循环（Isim 也因此崩溃），不会输出 <code>finish!</code> 。这是因为循环变量 <code>temp</code> 是位宽为 <code>2</code> 的 <code>reg</code> 型变量，当循环计数到达 <code>3</code> 时，<code>temp + 1</code> 溢出，计数将再次从 <code>0</code> 开始，如此重复，不会出现 <code>temp</code> 大于 <code>3</code> 的情况，循环将一直被执行。</p>
<h5 id="循环结束条件"><a href="#循环结束条件" class="headerlink" title="循环结束条件"></a>循环结束条件</h5><ul>
<li><p>建议写成类似 <code>i &lt; const</code> 形式( <code>const</code> 表示常数)，<strong>循环上限使用常数而非变量</strong>，否则容易造成死循环。</p>
</li>
<li><p>需要使用输入信号的 <code>for</code> 语句，比如输入信号限制最大值为 <code>31</code> ，建议写出类似 <code>i &lt; inputA &amp;&amp; i &lt; 32</code> 形式，加上&#x3D;&#x3D;常数限制&#x3D;&#x3D;，避免可能的死循环。</p>
</li>
</ul>
<h5 id="for-语句对应实际线路"><a href="#for-语句对应实际线路" class="headerlink" title="for 语句对应实际线路"></a>for 语句对应实际线路</h5><p>  Verilog 中 <code>for</code> 语句在实际意义上并不等同于 C 语言中的，而是对应实际的线路。Verilog 作为一种硬件描述语言，建议&#x3D;&#x3D;<strong>想好实际线路之后再写代码</strong>&#x3D;&#x3D;。以下是一个 <code>for</code> 循环对应的线路示例。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] x,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ans<br>    );<br>    <span class="hljs-keyword">integer</span> i;<br>    <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>        ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>            ans = ans + x;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>对应线路</p>
<p><img src="/img/3-4-1.png" alt="对应线路"></p>
<h5 id="for语句应用示例"><a href="#for语句应用示例" class="headerlink" title="for语句应用示例"></a>for语句应用示例</h5><p>下面给出使用 <code>for</code> 语句实现七人投票表决器的例子。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> vote7(<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">6</span>:<span class="hljs-number">0</span>] vote,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> pass<br>    );<br>    <span class="hljs-keyword">reg</span>[<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] sum;                         <span class="hljs-comment">// sum为reg型变量，用于统计赞成的人数</span><br>    <span class="hljs-keyword">integer</span> i;                            <span class="hljs-comment">// 循环变量</span><br>    <span class="hljs-keyword">always</span> @(vote) <span class="hljs-keyword">begin</span>                  <span class="hljs-comment">// 此处使用always建模组合逻辑</span><br>        sum = <span class="hljs-number">3&#x27;b000</span>;                     <span class="hljs-comment">// sum初值为0,一定要记得初始化</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">7</span>;i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span> <span class="hljs-comment">// for语句</span><br>            <span class="hljs-keyword">if</span> (vote[i]) sum = sum + <span class="hljs-number">1</span>;   <span class="hljs-comment">// 只要有人投赞成票，则sum加1</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">if</span> (sum &gt;= <span class="hljs-number">3&#x27;d4</span>) pass = <span class="hljs-number">1&#x27;b1</span>;     <span class="hljs-comment">// 若大于等于4人赞成，则表决通过</span><br>        <span class="hljs-keyword">else</span> pass = <span class="hljs-number">1&#x27;b0</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p>Verilog 中 <code>while</code> 语句的语法和 C 语言基本相同。下面给出一个例子（对一个 8 位二进制数中值为 1 的位进行计数）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> count1s_while(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] rega,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] count<br>    );<br><br>     <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span>: count1 <span class="hljs-comment">// 命名顺序块，建模时序逻辑</span><br>        <span class="hljs-keyword">reg</span>[<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] tempreg; <span class="hljs-comment">// 用作循环执行条件表达式</span><br>        count = <span class="hljs-number">0</span>; <span class="hljs-comment">// count初值为0</span><br>        tempreg = rega; <span class="hljs-comment">// tempreg初值为rega</span><br>        <span class="hljs-keyword">while</span> (tempreg) <span class="hljs-keyword">begin</span> <span class="hljs-comment">// 若tempreg非0，则执行以下语句</span><br>            <span class="hljs-keyword">if</span> (tempreg[<span class="hljs-number">0</span>]) count = count + <span class="hljs-number">1</span>; <span class="hljs-comment">// 只要trmpreg最低位为1，则count加1</span><br>            tempreg = tempreg &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 逻辑右移1位</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>1.在Verilog 中所有的循环语句只能在 always 或 initial 块中使用，因此 for 语句和 while 语句不能直接出现在语句块外。</p>
<p>2.循环语句中即可用&#x3D;&#x3D;非阻塞赋值&#x3D;&#x3D;，也可用&#x3D;&#x3D;阻塞赋值&#x3D;&#x3D;，所以 for 语句和 while 语句既可以用于建模组合逻辑（阻塞赋值），也可以用来建模时序逻辑（非阻塞赋值）。</p>
<h4 id="时间控制语句"><a href="#时间控制语句" class="headerlink" title="时间控制语句"></a>时间控制语句</h4><p>时间控制语句通常出现在测试模块中，用来产生符合我们期望变化的测试信号，比如每隔 5 个时间单位变更一次信号等。这个语句通过关键字 <code>#</code> 实现延时，格式为 **<code>#时间</code>**，当延时语句出现在顺序块中时它后面的语句会在延时完毕后继续执行。举例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">#<span class="hljs-number">3</span>;         <span class="hljs-comment">// 延迟 3 个时间单位</span><br>#<span class="hljs-number">5</span> b = a;   <span class="hljs-comment">// b 为 reg 型，延迟 5 个时间单位后执行赋值语句</span><br><span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~clk;   <span class="hljs-comment">// 每过 5 个时间单位触发一次，时钟信号反转，时钟周期为 10 个时间单位</span><br><span class="hljs-keyword">assign</span> #<span class="hljs-number">5</span> b = a;        <span class="hljs-comment">// b 为 wire 型，将表达式右边的值延时 5 个时间单位后赋给 b</span><br></code></pre></td></tr></table></figure>

<h4 id="常用实现方式"><a href="#常用实现方式" class="headerlink" title="常用实现方式"></a>常用实现方式</h4><p>一般情况下：</p>
<p>1.（用宏定义对不同的状态表示进行简化）</p>
<p>2.初始化（采用<code>initial</code>块）</p>
<p>3.状态更新（采用<code>always</code>块）</p>
<p>4.输出更新（采用<code>assign</code>语句）</p>
<p>对于大部分的状态机，关键点在于寻找到所有的状态和正确的完整状态迁移，同时要处理好 <code>always</code> 的敏感变量。</p>
<h3 id="模块的典型内部结构"><a href="#模块的典型内部结构" class="headerlink" title="模块的典型内部结构"></a>模块的典型内部结构</h3><p>一个模块的典型结构可以大致划分为三个部分：组合逻辑、时序逻辑和对其他模块的引用。</p>
<p>在组合逻辑部分，通常使用到的语法为 <strong><code>assign</code> 语句</strong>，用于对 <code>wire</code> 型变量进行连续赋值。根据情况，我们也可能会使用 <strong><code>always</code> 块</strong>来建模组合逻辑。</p>
<p>在时序逻辑部分，**<code>always</code> 块<strong>是必不可少的。通常我们会在 <strong><code>always</code> 块</strong>中使用各种</strong>流程控制语句**建模时序逻辑。有时，我们还需要 <strong><code>initial</code> 块</strong>对变量进行一定的初始化。</p>
<p>引用其他模块时，我们会用到<strong>模块实例化</strong>的语法（见Verilog建模中的结构级建模）。</p>
<h3 id="阻塞赋值与非阻塞赋值"><a href="#阻塞赋值与非阻塞赋值" class="headerlink" title="阻塞赋值与非阻塞赋值"></a>阻塞赋值与非阻塞赋值</h3><p>先通过一段实例代码来介绍二者之间的区别</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> blocked_and_non_blocked(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> b_blocked,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> c_blocked,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> b_non_blocked,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> c_non_blocked<br>    );<br><br>    <span class="hljs-comment">// 非阻塞赋值</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        b_non_blocked &lt;= a;<br>        c_non_blocked &lt;= b_non_blocked;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">// 阻塞赋值</span><br>    <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>        b_blocked = a;<br>        c_blocked = b_blocked;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<h4 id="非阻塞赋值语句"><a href="#非阻塞赋值语句" class="headerlink" title="非阻塞赋值语句"></a>非阻塞赋值语句</h4><p>处在一个 <code>always</code> 块中的非阻塞赋值是<strong>在块结束时</strong>同时<strong>并发</strong>执行的。对于以上示例代码，<code>clk</code> 信号的上升沿到来时，<code>b_non_blocked</code> 就等于 <code>a</code> 的值，<code>c_non_blocked</code> 就等于原来 <code>b_non_blocked</code> 的值。代码对应的电路图如下图所示，其中用到两个触发器。</p>
<p><img src="/img/3-6-1.svg" alt="非阻塞赋值"></p>
<p>对于 ISim，<strong>在每一条非阻塞赋值执行前</strong>，仿真器“按下快门”保存下了在 <code>&lt;=</code> 右边参与运算的变量值。在块结束进行赋值时，对于 <code>&lt;=</code> 左边被赋值的变量，都是用“快照”中的值参与运算的。</p>
<p><img src="/img/%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E6%B3%A2%E5%BD%A2%E5%9B%BE.png" alt="非阻塞赋值的波形图"></p>
<h4 id="阻塞赋值语句"><a href="#阻塞赋值语句" class="headerlink" title="阻塞赋值语句"></a>阻塞赋值语句</h4><p>阻塞赋值语句的执行是具有明确&#x3D;&#x3D;<strong>顺序</strong>&#x3D;&#x3D;关系的，在 <code>begin</code> - <code>end</code> 的顺序块中，当前一句阻塞赋值完成后（即 <code>=</code> 左边的变化为右边的值后），下一条阻塞赋值语句才会被继续执行。对于以上示例代码，<code>clk</code> 信号上升沿到来时，<code>b_blocked</code> 先取 <code>a</code> 的值，<code>c_blocked</code> 再取 <code>b_blocked</code> 的值（即等于 <code>a</code>）。代码对应的电路图如下图所示，只用了一个触发器来寄存 <code>a</code> 的值并输出给 <code>b_blocked</code> 和 <code>c_blocked</code> ，这大概不是设计者的初衷，同时在时序逻辑中的阻塞赋值可能是不可综合的，所以非常有必要思考好是否使用阻塞赋值。</p>
<p><img src="/img/3-6-2.svg" alt="阻塞赋值"></p>
<p>阻塞赋值在 Isim 中的仿真波形如下图所示：</p>
<p><img src="/img/%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E7%9A%84%E6%B3%A2%E5%BD%A2%E5%9B%BE.png" alt="阻塞赋值的波形图"></p>
<h3 id="块语句"><a href="#块语句" class="headerlink" title="块语句"></a>块语句</h3><h4 id="顺序块"><a href="#顺序块" class="headerlink" title="顺序块"></a>顺序块</h4><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>1.块内的语句是按顺序执行的。</p>
<p>2.<strong>每条语句的延迟时间是相对于前一条语句的仿真时间而言的。</strong></p>
<p>3.所有语句都执行完，程序控制流程才跳出该语句块。</p>
<h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">begin</span>:块名<span class="hljs-comment">//一个标识名</span><br>    块内声明语句<span class="hljs-comment">//可为参数声明语句、reg型/integer型/real型变量声明语句</span><br>    语句<span class="hljs-number">1</span>；<br>    语句<span class="hljs-number">2</span>；<br>    ……<br>    语句n；<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h4 id="并行块"><a href="#并行块" class="headerlink" title="并行块"></a>并行块</h4><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><p>1.块内语句是同时执行的，即程序流程控制一进入到该并行块，块内语句则开始同时并行的执行。</p>
<p>2.<strong>块内每条语句的延迟时间是相对于程序流程控制进入到块内的仿真时间的</strong>。</p>
<p>3.延时时间是用来给赋值语句提供执行时序的。</p>
<p>4.当按时间时序排序在最后的语句执行完后或一个<code>disable</code>语句执行时，程序流程控制跳出该语句块。</p>
<h5 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">fork</span>:块名<span class="hljs-comment">//一个标识符</span><br>    块内声明语句<span class="hljs-comment">//可为参数说明语句、reg型/integer型/real型/time型变量声明语句和事件说明语句</span><br>    语句<span class="hljs-number">1</span>;<br>    语句<span class="hljs-number">2</span>;<br>    ……<br>    语句n;<br><span class="hljs-keyword">join</span><br></code></pre></td></tr></table></figure>

<p><del>其实感觉用顺序块+非阻塞赋值也可以达到并行块的效果</del>。</p>
<h4 id="块名"><a href="#块名" class="headerlink" title="块名"></a>块名</h4><p>块名存在的原因：</p>
<p>1.可在块内定义局部变量，即只在块内使用的变量。</p>
<p>2.可允许块被其他语句调用，如<code>disable</code>语句。</p>
<p>3.在Verilog语言中，所有的变量都是静态的，即<strong>所有的变量都只有一个唯一的存储地址</strong>，因此进入或跳出块并不影响存储在变量内的值。</p>
<p>因此，块名提供了一个在任何仿真时刻确认变量值的方法。</p>
<h3 id="有符号数的处理方法"><a href="#有符号数的处理方法" class="headerlink" title="有符号数的处理方法"></a>有符号数的处理方法</h3><p>在 Verilog HDL 中，<code>wire</code>、<code>reg</code> 等数据类型<strong>默认都是无符号的</strong>。当你希望做符号数的操作时，你需要使用 **<code>$signed()</code>**。</p>
<h4 id="例子引入："><a href="#例子引入：" class="headerlink" title="例子引入："></a>例子引入：</h4><p>一个比较器的例子：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//先定义了一个比较器的模块，类似于函数的概念</span><br><span class="hljs-keyword">module</span> comparator(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> reset,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a,<br>    <span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] b,<br>    <span class="hljs-keyword">output</span> res<br>    );<br><br>    <span class="hljs-keyword">assign</span> res = a &gt; b;<br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>我们希望程序实现比较 a, b 大小的功能，若 a &gt; b，res 输出 1，否则输出 0，下面通过以下代码进行测试。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> comparator_tb;<br><br>    <span class="hljs-comment">// Inputs</span><br>    <span class="hljs-keyword">reg</span> clk;<br>    <span class="hljs-keyword">reg</span> reset;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] b;<br><br>    <span class="hljs-comment">// Outputs</span><br>    <span class="hljs-keyword">wire</span> res;<br><br>    <span class="hljs-comment">// Instantiate the Unit Under Test (UUT)-&gt;实例化被测单元</span><br>    comparator uut (<br>        <span class="hljs-variable">.clk</span>(clk), <br>        <span class="hljs-variable">.reset</span>(reset), <br>        <span class="hljs-variable">.a</span>(a), <br>        <span class="hljs-variable">.b</span>(b), <br>        <span class="hljs-variable">.res</span>(res)<br>    );<span class="hljs-comment">//名映射</span><br><br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        clk = <span class="hljs-number">0</span>;<br>        reset = <span class="hljs-number">0</span>;<br>        a = <span class="hljs-number">4</span>;<br>        b = <span class="hljs-number">1</span>;<br><br>        #<span class="hljs-number">100</span> b = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>我们初始化 a &#x3D; 4，b &#x3D; 1，100ns 后 b 变为 -1。期望的结果是 res 始终为 1。（因为4&gt;1且4&gt;-1是<del>毋庸置疑</del>的吧？）下面是波形：</p>
<p><img src="/img/verilog-signed3.png" alt="波形图"></p>
<p>可以看到 100ns 后，res 输出变为了 0，与预期不符。其原因在于比较时 Verilog 将 a 和 b 都默认视为无符号数，-1 会被认为是 15(<code>4&#39;b1111</code>)。</p>
<p>将比较代码修改为 <code>assign res = $signed(a) &gt; $signed(b);</code>，程序即可达到预期结果。</p>
<p>值得一提的是，假如将比较代码修改为 <code>assign res = a &gt; $signed(b);</code>，得到的结果也达不到预期效果。</p>
<p>在对无符号数和符号数同时操作时，Verilog 会自动地做数据类型匹配，&#x3D;&#x3D;<strong>将符号数向无符号数转化</strong>&#x3D;&#x3D;。因为在执行 <code>a &gt; $signed(b)</code> 时，<code>a</code> 是无符号数，<code>$signed(b)</code> 是符号数，Verilog 默认向无符号类型转化，得到的结果仍是无符号数的比较结果。</p>
<h4 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h4><p>Verilog 对于符号的处理有些特殊，分为<strong>最外层表达式符号的确定</strong>与<strong>向内传播</strong>两个过程。也就是说先确定下来最终结果有无符号，再向内传播进行类型转换，诸多诡异行为的“罪魁祸首”就是向内传播。</p>
<p>为了方便后续表述，让我们先定义两个概念。<strong>表达式和原子表达式</strong>，<strong>自决定表达式和上下文决定表达式</strong>。</p>
<p>注意，这些概念仅适用于本节。</p>
<h4 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h4><h5 id="表达式和原子表达式。"><a href="#表达式和原子表达式。" class="headerlink" title="表达式和原子表达式。"></a>表达式和原子表达式。</h5><ul>
<li><p>单独的运算数（比如常数（32‘d1)，变量（a））是表达式。</p>
</li>
<li><p>表达式与运算符的合法组合是表达式（a+1）。</p>
</li>
<li><p>设表达式 S 是表达式 A, B, … 与运算符X的合法组合。则称 A, B, … 是 S 的子表达式。</p>
</li>
<li><p>称没有子表达式的表达式为&#x3D;&#x3D;原子表达式&#x3D;&#x3D;（类比原子公式）。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] a;<br><span class="hljs-keyword">wire</span> b;<br><span class="hljs-number">32&#x27;d1</span>               <span class="hljs-comment">// 是表达式，常数</span><br>a                   <span class="hljs-comment">// 是表达式，变量</span><br>a + <span class="hljs-number">1</span>               <span class="hljs-comment">// 是表达式，加法运算</span><br>b ? a + <span class="hljs-number">1</span> : a - <span class="hljs-number">1</span>   <span class="hljs-comment">// 是表达式，三目运算</span><br>&amp;a                  <span class="hljs-comment">// 是表达式，单目与运算</span><br>&amp;&amp;a                 <span class="hljs-comment">// 不是表达式，&quot;&amp;&amp;&quot;是双目运算符,不合法也不是表达式</span><br></code></pre></td></tr></table></figure>

<p>这里可以类比刚刚学习过的离散数学中对公式的定义，与我们这里对表达式的定义如出一辙，这将是以后常用的定义形式。另外，这里的原子代表不可再分，也是以后常会遇到的概念。</p>
</li>
</ul>
<h5 id="自决定表达式-self-determined-expression-和上下文决定表达式-context-determined-expression-。"><a href="#自决定表达式-self-determined-expression-和上下文决定表达式-context-determined-expression-。" class="headerlink" title="自决定表达式(self-determined expression)和上下文决定表达式(context-determined expression)。"></a>自决定表达式(self-determined expression)和上下文决定表达式(context-determined expression)。</h5><p>自决定表达式的<strong>位宽</strong>和<strong>符号</strong>都是由自身决定的，和表达式所在的上下文无关。比如布尔表达式，不论它的子表达式和上下文如何，该表达式的结果总是一位的<strong>无符号数</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> a;<br><span class="hljs-keyword">wire</span> b;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] c;<br><span class="hljs-keyword">assign</span> c = a == <span class="hljs-number">1</span> &amp;&amp; b == <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 上面的式子中 a == 1 &amp;&amp; b == 0 是自决定的</span><br><span class="hljs-comment">// a == 1 和 b == 0 也是自决定的</span><br></code></pre></td></tr></table></figure>

<p>上下文决定表达式的位宽和符号既由&#x3D;&#x3D;自身&#x3D;&#x3D;又由&#x3D;&#x3D;上下文&#x3D;&#x3D;决定。比如 <code>a + $signed(b)</code> 的例子。它的符号不由自身决定，它取决于其子表达式。</p>
<p>紧接着就来认识一下 Verilog 符号判定的两条原理——最外层表达式符号的确定和向内传播。</p>
<h4 id="最外层表达式符号的确定"><a href="#最外层表达式符号的确定" class="headerlink" title="最外层表达式符号的确定"></a>最外层表达式符号的确定</h4><p>对于自决定表达式，它的符号由自身决定。</p>
<p>对于上下文决定的表达式，其符号和位宽和运算符无关，由其子表达式决定。确定规则<strong>可简单概括为，其子表达式中有任一表达式是无符号则该表达式就是无符号的。</strong>（一层一层向内”拨“）</p>
<p>那子表达式有无符号怎么确定？当做最外层表达式来判定。所以大家应该能理会到，表达式的符号确定规则是递归的规则。</p>
<p>举一个稍微复杂一点点的例子，<code>$signed(a) * ($signed(b) + ($signed(c) - d))</code>。这个表达式或许有些复杂，不过如果我们按上述定义提炼出它的树状结构，就可以更清晰地解读表达式。具体如图：</p>
<p><img src="/img/verilog-signed4.svg" alt="图"></p>
<p>在该图中，非叶节点的符号都是无法确定的，只能依靠它的子节点确定。而其中，d 是无符号的，所以它的上层表达式也是无符号的。以至于最外层表达式也是无符号的。</p>
<h4 id="向内传播"><a href="#向内传播" class="headerlink" title="向内传播"></a>向内传播</h4><p>在用上述的规则确定好最外层表达式后，将最外层表达式的位宽和符号由外向内地传递给上下文决定的子表达式（自决定的子表达式不受影响）。这也是一个递归的过程，直至遇到原子表达式，此时要<strong>强制转换原子表达式的类型</strong>。</p>
<p>还是上面那个例子，在确定完最外层表达式是无符号的之后，原子表达式，就是树的叶节点，这些节点就都要强制转换为无符号的类型。所以最后上面的表达式的值等同于 <code>a * (b + (c - d))</code>。</p>
<p><img src="/img/verilog-signed5.svg" alt="图"></p>
<h4 id="一些特殊情况"><a href="#一些特殊情况" class="headerlink" title="一些特殊情况"></a>一些特殊情况</h4><p>看到这你可能会有疑问，在最开始的例子 <code>a &gt; $signed(b)</code> 中，这应该是一个比较关系的布尔表达式，应该是自决定的，但是它仍然进行了向内传播。这是因为 Verilog 语言规定关系表达式与等式表达式属于<strong>自确定与上下文决定的中间态</strong>，具体体现为&#x3D;&#x3D;结果是自确定的&#x3D;&#x3D;，但是&#x3D;&#x3D;它们的子表达式需要相互影响&#x3D;&#x3D;。</p>
<p>对于<strong>移位运算符，其右侧的操作数总是被视为&#x3D;&#x3D;无符号数&#x3D;&#x3D;，并且不会对运算结果的符号性产生任何影响</strong>。结果的符号由<strong>运算符左侧的操作数</strong>和<strong>表达式的其余部分</strong>共同决定。</p>
<p>例子：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> a2(	<br>	<span class="hljs-keyword">input</span> clk,<br>	<span class="hljs-keyword">input</span> reset,<br>	<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] a,<br>	<span class="hljs-keyword">input</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] b,<br>	<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ans1,<br>	<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ans2,<br>	<span class="hljs-keyword">output</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] ans3<br>    );<br>    <span class="hljs-keyword">assign</span> ans1 = (<span class="hljs-number">1&#x27;b1</span>==<span class="hljs-number">1&#x27;b1</span>) ? a&gt;&gt;&gt;b : <span class="hljs-number">0</span>;<span class="hljs-comment">//a为无符号数，所以将进行逻辑右移，即高位补0.</span><br>    <span class="hljs-keyword">assign</span> ans2 = (<span class="hljs-number">1&#x27;b1</span>==<span class="hljs-number">1&#x27;b1</span>) ? <span class="hljs-built_in">$signed</span>(a)&gt;&gt;&gt;b : <span class="hljs-number">0</span>;<span class="hljs-comment">//0默认为有符号数，所以该式子根据最外层表达式符号确定为有符号，再向内传播则右移运算为算术右移，3=4‘b0011，右移1位为4’b0001;-2=4‘b1110,右移一位为4’b1111.</span><br>    <span class="hljs-keyword">assign</span> ans3 = (<span class="hljs-number">1&#x27;b1</span>==<span class="hljs-number">1&#x27;b1</span>) ? <span class="hljs-built_in">$signed</span>(a)&gt;&gt;&gt;b : <span class="hljs-number">4&#x27;b0</span>;<span class="hljs-comment">//4‘b0为无符号数，所以将进行逻辑右移，即高位补0.</span><br><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>Testbench部分内容如下所示：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>		<span class="hljs-comment">// Initialize Inputs</span><br>		clk = <span class="hljs-number">0</span>;<br>		reset = <span class="hljs-number">0</span>;<br>		a = <span class="hljs-number">0</span>;<br>		b = <span class="hljs-number">0</span>;<br><br>		<span class="hljs-comment">// Wait 100 ns for global reset to finish</span><br>		#<span class="hljs-number">100</span>;<br>        <br>		<span class="hljs-comment">// Add stimulus here</span><br>		a=<span class="hljs-number">3</span>;<br>		b=<span class="hljs-number">1</span>;<br>		#<span class="hljs-number">2</span>;<br>		a=-<span class="hljs-number">2</span>;<br>		b=<span class="hljs-number">1</span>;<br><br>	<span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>T1. 在101ns和103ns时，ans1的值分别为（ A）。</p>
<p>A 4‘b0001;4’b0111 B 4’b0001;4’b1111 C 4’b1001;4’b0111 D 4’b1001;4’b1111</p>
<p>T2. 在101ns和103ns时，ans2的值分别为（ <strong>B</strong>）。</p>
<p>A 4‘b0001;4’b0111 B 4’b0001;4’b1111 C 4’b1001;4’b0111 D 4’b1001;4’b1111</p>
<p>T3. 在101ns和103ns时，ans3的值分别为（A ）。</p>
<p>A 4‘b0001;4’b0111 B 4’b0001;4’b1111 C 4’b1001;4’b0111 D 4’b1001;4’b1111</p>
<p><strong>若运算子是否为有符号数对运算式的结果有影响，则应先通过&#x3D;&#x3D;最外层表达式符号的确定&#x3D;&#x3D;和&#x3D;&#x3D;向内传播&#x3D;&#x3D;两个原则来判断所有运算子的有无符号情况，再进行计算。</strong></p>
<p>对于<strong>三目运算符</strong>，其 <code>?</code>前的布尔表达式是自决定的表达式，不会对最外层表达式的符号造成影响。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一、使用 <code>$signed()</code> 尽量使得运算数间有&#x2F;无符号相同（移位运算是个例外），比如进行加法时，两个操作数都有符号，或者都没有符号，这样容易确定结果的符号。同时将 <code>$signed()</code> 用于较为简单的表达式，例如推荐下面的第一种写法而尽量避免第二种写法。第二种写法不仅可读性较差，还容易导致意想不到的问题。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">assign</span> a = <span class="hljs-built_in">$signed</span>(b) &gt; <span class="hljs-built_in">$signed</span>(c);<br><br><span class="hljs-keyword">assign</span> a = ((<span class="hljs-built_in">$signed</span>(b) + <span class="hljs-built_in">$signed</span>(c)) &gt;&gt; d) &gt; <span class="hljs-built_in">$signed</span>(e);<br></code></pre></td></tr></table></figure>

<p>二、对于复杂的表达式避免使用 <code>$signed()</code> ，如果希望使用 <code>$signed()</code> 可以将这一部分抽离出来单独作为一个变量，比如</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] in_a,in_b,out;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] op;<br><span class="hljs-comment">// wrong !!!</span><br><span class="hljs-keyword">assign</span> out = op == <span class="hljs-number">0</span>? in_a + in_b:<br>             op == <span class="hljs-number">1</span>? in_a - in_b:<br>             op == <span class="hljs-number">2</span>? in_a &gt;&gt;&gt; in_b:<br>             <span class="hljs-built_in">$signed</span>(in_a) &gt;&gt;&gt; in_b;<br><span class="hljs-comment">// correct</span><br><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] shift;<br><span class="hljs-keyword">assign</span> shift = <span class="hljs-built_in">$signed</span>(in_a) &gt;&gt;&gt; in_b;<br><span class="hljs-keyword">assign</span> out = op == <span class="hljs-number">0</span>? in_a + in_b:<br>             op == <span class="hljs-number">1</span>? in_a - in_b:<br>             op == <span class="hljs-number">2</span>? in_a &gt;&gt;&gt; in_b:<br>    shift;<span class="hljs-comment">//《==》assign out=(op==0)?(in_a+in_b):((op==1)?(in_a-in_b):((op==2)?(in_a&gt;&gt;&gt;in_b):shift));</span><br></code></pre></td></tr></table></figure>

<p>三、如果你实在担心使用 <code>$signed()</code> 会出现意想不到的 bug，那么最简单的方式就是避开它。比如符号拓展可以写成如下</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] unsignedValue = <span class="hljs-number">2&#x27;b11</span>;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] extendedValue;<br><span class="hljs-comment">// use $signed()</span><br><span class="hljs-keyword">assign</span> extendedValue = <span class="hljs-built_in">$signed</span>(unsignedValue);<br><span class="hljs-comment">// do not use $signed()</span><br><span class="hljs-keyword">assign</span> extendedValue = &#123;&#123;<span class="hljs-number">30</span>&#123;unsignedValue[<span class="hljs-number">1</span>]&#125;&#125;,unsignedValue&#125;;<br></code></pre></td></tr></table></figure>

<p>四、<strong>最简单也是最重要的一点，当你不确定 <code>$signed()</code> 的行为时，不妨自行编写一个简单的testbench观察一下，通过观察结果可以直截了当地做出判断。</strong></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>1.在Verilog中负数在存储时会以补码的形式存储，但使用时仍会被看作是无符号数，使用有符号数表示&#x3D;&#x3D;一定&#x3D;&#x3D;要使用<code>$signed()</code>。</p>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>类似 C 语言，Verilog HDL 也提供了编译预处理指令。下面对其中的宏定义部分作一简要介绍。</p>
<p>在 Verilog HDL 语言中，为了和一般的语句相区别，编译预处理命令**以符号 &#96;（反引号，backtick）开头**（位于主键盘左上角，其对应的上键盘字符为  <code>~</code>。注意这个符号不同于单引号）。这些预处理命令的有效作用范围为定义命令之后到本文结束或到其他命令定义替代该命令之处。</p>
<p>宏定义用一个指定的标识符(即名字)来代表一个字符串，它的一般形式为：&#96;&#96;define 标识符(宏名) 字符串(宏内容)&#96;。它的作用是指定用标识符来代替字符串，在编译预处理时，把程序中该命令以后所有的标识符都替换成字符串。举例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">define</span> WORDSIZE 8</span><br><span class="hljs-comment">// 省略模块定义</span><br> <span class="hljs-keyword">reg</span>[<span class="hljs-number">1</span>:`WORDSIZE] data;<br><span class="hljs-comment">// 相当于定义 reg[1:8] data;</span><br></code></pre></td></tr></table></figure>

<p>注意，**引用宏名时也必须在宏名前加上符号&#96; **，以表明该名字是经过宏定义的名字。</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>请不要滥用宏：编译器在编译时，会将宏“展开”（即<em>替换</em>）为对应的字符串。如果宏的内容较长，且展开次数较多（在代码中使用宏的次数较多），会带来较大的开销，导致仿真编译较慢，在线评测时可能会编译超时。因此，如果是希望定义类似“变量”的东西，在可以使用 <code>wire</code> 时，请使用 <code>wire</code>，而不是使用宏。</p>
<h3 id="数据位宽"><a href="#数据位宽" class="headerlink" title="数据位宽 [+:] [-:]"></a>数据位宽 [+:] [-:]</h3><p>+: 和-: 主要用来进行位宽度选择，语法如下：</p>
<p>reg [31:0] value;<br>value[base_express +: width_express];<br>其中base_express表示起始bit位置，width_express表示位宽。</p>
<p>例：<br>reg [15:0] big_value;<br>big_value[0+:8] （注意不是big_value[0+:7]）等价于 big_value[7:0]；<br>big_value[8+:8] （注意不是big_value[8+:7]）等价于 big_value[15:8]；<br>big_value[7-:8] （注意不是big_value[7-:7] ）等价于 big_value[7:0]；<br>big_value[15-:8]（注意不是big_value[15-:7]）等价于 big_value[15:8]。</p>
<h2 id="Verilog工程的设计开发调试"><a href="#Verilog工程的设计开发调试" class="headerlink" title="Verilog工程的设计开发调试"></a>Verilog工程的设计开发调试</h2><h3 id="不要用-initial-块、不要为寄存器赋初值"><a href="#不要用-initial-块、不要为寄存器赋初值" class="headerlink" title="不要用 initial 块、不要为寄存器赋初值"></a>不要用 initial 块、不要为寄存器赋初值</h3><p><code>initial</code> 块用于在仿真开始时对寄存器进行初始化、执行其他代码。在综合时，<code>initial</code> 块会被&#x3D;&#x3D;忽略&#x3D;&#x3D;，不起任何作用，且为 reg 指定的初始值也会被&#x3D;&#x3D;忽略&#x3D;&#x3D;。也就是说，如下的代码都是不起作用的。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> v = <span class="hljs-number">6</span>; <span class="hljs-comment">// 综合时，初始值被忽略</span><br><span class="hljs-keyword">reg</span> m;<br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    m = <span class="hljs-number">1</span>; <span class="hljs-comment">// 综合时，initial 块被忽略</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>如果你想在模块开始运行时，对寄存器进行一些初始化，请使用 reset 信号控制复位，并在 Testbench 开始的部分提供一个 reset 信号。例如，上面的代码正确写法为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>        v &lt;= <span class="hljs-number">6</span>;<br>        m &lt;= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>Testbench 正确的写法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> clk = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">reg</span> reset = <span class="hljs-number">0</span>; <span class="hljs-comment">// 只有在tb中可以直接赋初值</span><br><span class="hljs-keyword">always</span> #<span class="hljs-number">5</span> clk = ~ clk; <span class="hljs-comment">// 创建周期为10的时钟</span><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    reset = <span class="hljs-number">1</span><br>    # <span class="hljs-number">10</span> <span class="hljs-comment">// 延时一个时钟周期</span><br>    reset = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 接下来开始你的测试</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h3 id="一个寄存器只能在一个-always-块中赋值一次"><a href="#一个寄存器只能在一个-always-块中赋值一次" class="headerlink" title="一个寄存器只能在一个 always 块中赋值一次"></a>一个寄存器只能在一个 always 块中赋值一次</h3><p>Verilog 综合时，寄存器通常会被综合为 D 触发器(D-Flip-Flop)。通过之前的学习知道，D 触发器只有一个时钟输入、一个数据输入。因此，每个寄存器只能属于一个时钟域（“时钟域”指驱动触发器更新的时钟所表示的“范围”）。例如，以下代码会使 <code>a</code> 寄存器属于两个时钟域，因此是<em>不可综合</em>的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 以下代码不可综合</span><br><span class="hljs-keyword">reg</span> a;<br><span class="hljs-keyword">wire</span> b, c;<br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk_1) <span class="hljs-keyword">begin</span><br>    a &lt;= b;<span class="hljs-comment">//a的第一次非阻塞赋值</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk_2) <span class="hljs-keyword">begin</span><br>    a &lt;= c;<span class="hljs-comment">//a的第二次非阻塞赋值</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>除了注意时钟域的归属外，我们也需保证在每个时钟周期中，寄存器被至多赋值一次，不能重复赋值。例如，以下的代码是不可综合的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> n;<br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (a)<br>        n &lt;= <span class="hljs-number">1&#x27;b1</span>;<br><br>    <span class="hljs-comment">// 一些其他代码</span><br><br>    n &lt;= <span class="hljs-number">1&#x27;b0</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是“赋值一次”的含义。如果使用 <code>if</code> &#x2F; <code>else</code> &#x2F; <code>case</code> 语句进行条件判断，在<strong>不同且互斥</strong>的情况下对同一个寄存器进行赋值，是完全合法的。例如下面的代码：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> d;<br><span class="hljs-keyword">wire</span> a, b, c;<br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (c)<br>        d &lt;= b;<br>    <span class="hljs-keyword">else</span><br>        d &lt;= a;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>上述代码将被综合成如下硬件：</p>
<p><img src="/img/d-flip-flop-mux.svg" alt="硬件图"></p>
<h3 id="组合逻辑相关注意事项"><a href="#组合逻辑相关注意事项" class="headerlink" title="组合逻辑相关注意事项"></a>组合逻辑相关注意事项</h3><p>我们一般会将代码分为“时序逻辑”和“组合逻辑”。时序逻辑使用 &#x3D;&#x3D;<code>@(posedge clk)</code>&#x3D;&#x3D; 来表达，而组合逻辑使用 &#x3D;&#x3D;<code>@(*)</code>&#x3D;&#x3D;来表达。在编写组合逻辑时，依照以下准则编写代码，可避免综合后产生奇怪的故障。</p>
<ol>
<li>在时序逻辑中，永远使用非阻塞赋值（<code>&lt;=</code>）；在组合逻辑中，永远使用阻塞赋值（<code>=</code>）；</li>
<li>每个组合逻辑运算结果仅在一个 <code>always @(*)</code> 中修改；</li>
<li>在 <code>always @(*)</code> 中，为每个运算结果赋初值，避免 latch （锁存器）的产生。</li>
</ol>
<p>一段实例代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 注意以下 count_n 并不是一个寄存器，而是由组合逻辑生成的运算结果；count 才是实际存放计数值的寄存器。</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] count_n, count;<br><span class="hljs-keyword">wire</span> add, set;<br><span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] set_value;<br><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    count_n = count; <span class="hljs-comment">// 修改了 count_n，因此先赋初值</span><br>    <span class="hljs-keyword">if</span> (set)<br>        count_n = set_value;<br>    <span class="hljs-keyword">if</span> (add)<br>        count_n = count_n + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 阻塞赋值类似于 C 语言，按顺序执行，以最后赋值的为准</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset)<br>        count &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        count &lt;= count_n;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h3 id="不要使用乘除法-用位运算来代替乘除法"><a href="#不要使用乘除法-用位运算来代替乘除法" class="headerlink" title="不要使用乘除法 - 用位运算来代替乘除法"></a>不要使用乘除法 - 用位运算来代替乘除法</h3><p>FPGA 及 ASIC 硬件中，实现乘法和除法的代价是较高的，需要专门的乘法器、除法器，逻辑门的数量较多。在编写 Verilog 代码时，若非必要，则不要使用乘除法。</p>
<p>很多乘除法操作可以使用&#x3D;&#x3D;移位或位拼接&#x3D;&#x3D;来代替。移位运算在硬件中实现非常直接，使用的逻辑门数量也较少。使用位移运算代替乘除法的方法如下：</p>
<ul>
<li>乘以2^n^：<ul>
<li>左移 n 位，例如：<code>a * 8</code> 可替换为 <code>a &lt;&lt; 3</code>；</li>
<li>在变量后面拼接 n 个 0，例如 <code>a * 8</code> 可替换为 <code>&#123;a, 3&#39;b0&#125;</code>。</li>
</ul>
</li>
<li>除以2^n^：<ul>
<li>右移 n 位，例如 <code>a / 8</code> 可替换为 <code>a &gt;&gt; 3</code>；</li>
<li>取变量的高位，例如 <code>a / 8</code> 可替换为 <code>a[7:3]</code>（若 <code>a</code> 一共有 8 位）。</li>
</ul>
</li>
<li>求模 2^n^ - 取 n 位以后的低位，例如：<code>a % 8</code> 可以替换为 <code>a[2:0]</code>。</li>
</ul>
<p>在使用移位运算符时，请注意移位运算符的优先级问题。</p>
<h3 id="Verilog代码规范"><a href="#Verilog代码规范" class="headerlink" title="Verilog代码规范"></a>Verilog代码规范</h3><h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><h5 id="VC-001-信号名称采用-snake-case，PascalCase-或者-camelCase"><a href="#VC-001-信号名称采用-snake-case，PascalCase-或者-camelCase" class="headerlink" title="VC-001 信号名称采用 snake_case，PascalCase 或者 camelCase"></a>VC-001 信号名称采用 <code>snake_case</code>，<code>PascalCase</code> 或者 <code>camelCase</code></h5><ul>
<li><code>snake_case</code>，即变量名全小写，单词之间用下划线分隔。</li>
<li><code>PascalCase</code>，即单词的首字母大写以区分单词。</li>
<li><code>camelCase</code>，即变量第一个单词小写，后续单词首字母大写。</li>
</ul>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> DM(<br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> mem_write, <span class="hljs-comment">//写入使能信号</span><br>  <span class="hljs-comment">//或者</span><br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> MemWrite, <span class="hljs-comment">//写入使能信号</span><br>  <span class="hljs-comment">//或者</span><br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span> memWrite, <span class="hljs-comment">//写入使能信号</span><br>  ...<span class="hljs-comment">//省略其他信号</span><br>);<br>...<span class="hljs-comment">//省略内容</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>请统一整个程序的命名风格。</p>
<h5 id="VC-002-信号极性为低有效用-n-后缀表示"><a href="#VC-002-信号极性为低有效用-n-后缀表示" class="headerlink" title="VC-002 信号极性为低有效用 _n 后缀表示"></a>VC-002 信号极性为低有效用 <code>_n</code> 后缀表示</h5><p>对于复位和使能信号，例如 <code>rst</code> 和 <code>en</code>，如果添加了 <code>_n</code> 后缀，表示值为 0 时生效（低有效，Active Low），值为 1 时不生效。</p>
<p>如果没有添加 <code>_n</code> 后缀，表示值为 1 时生效（高有效，Active High），值为 0 时不生效。详细解释见下面的表格：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>极性</th>
<th>1’b1</th>
<th>1’b0</th>
</tr>
</thead>
<tbody><tr>
<td>rst</td>
<td>高有效</td>
<td>复位</td>
<td>不复位</td>
</tr>
<tr>
<td>rst_n</td>
<td>低有效</td>
<td>不复位</td>
<td>复位</td>
</tr>
<tr>
<td>en</td>
<td>高有效</td>
<td>写入</td>
<td>不写入</td>
</tr>
<tr>
<td>en_n</td>
<td>低有效</td>
<td>不写入</td>
<td>写入</td>
</tr>
</tbody></table>
<p>当代码中需要混合使用 <code>rst</code> 和 <code>rst_n</code> 的时候，采用以下的方式来转换：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> test(<br>  <span class="hljs-keyword">input</span> rst_n<br>);<br>  <span class="hljs-keyword">wire</span> rst;<br><br>  <span class="hljs-comment">// GOOD</span><br>  <span class="hljs-keyword">assign</span> rst = ~rst_n;<br><br>  <span class="hljs-comment">// GOOD</span><br>  <span class="hljs-comment">// Verilog</span><br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    rst = ~rst_n;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-003-多路选择器标明规格"><a href="#VC-003-多路选择器标明规格" class="headerlink" title="VC-003 多路选择器标明规格"></a>VC-003 多路选择器标明规格</h5><p>后续开发中可能会使用多种多路选择器，表明多路选择器的规格对于代码可读性有显著提升。 例如，4 选 32 位 1 的 <code>MUX</code>，模块的命名如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> Mux4_1_32(<br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] sel,<span class="hljs-comment">//控制位</span><br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in0,<br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in1,<br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in2,<br>  <span class="hljs-keyword">input</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] in3,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">wire</span>[<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] out<br>);<br></code></pre></td></tr></table></figure>

<h5 id="VC-004-魔数（magic-number）的命名"><a href="#VC-004-魔数（magic-number）的命名" class="headerlink" title="VC-004 魔数（magic number）的命名"></a>VC-004 魔数（magic number）的命名</h5><p>编写状态机的时候，各个状态一定要命名，之后调用的时候使用命名，而不是数字，减少代码中 magic number 的出现。建议使用 <code>parameter</code>，<code>localparam</code> 或者宏定义命名。 例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">localparam</span> sInit = <span class="hljs-number">2&#x27;d0</span>;<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">parameter</span> sInit = <span class="hljs-number">2&#x27;d0</span>;<br><span class="hljs-comment">// or</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> sInit 2&#x27;d0</span><br></code></pre></td></tr></table></figure>

<p>如果仿真工具不支持在波形中显示为对应的状态名称，可以采用以下的方法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">ifndef</span> SYNTHESIS</span><br><span class="hljs-keyword">reg</span> [<span class="hljs-number">39</span>:<span class="hljs-number">0</span>] state_string; <span class="hljs-comment">// 40 bits = 5 byte,1byt存储1个字符</span><br><br>  <span class="hljs-keyword">always</span> @ (*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(state)<br>      sInit: state_string = <span class="hljs-string">&quot;sInit&quot;</span>;<br>      sIdle: state_string = <span class="hljs-string">&quot;sIdle&quot;</span>;<br>      sWork: state_string = <span class="hljs-string">&quot;sWork&quot;</span>;<br>      sDone: state_string = <span class="hljs-string">&quot;sDone&quot;</span>;<br>      <span class="hljs-keyword">default</span>: state_string = <span class="hljs-string">&quot;?????&quot;</span>;<br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<p>此时在仿真波形中，<code>state_string</code> 信号就可以看到状态的名称了。</p>
<p>另外，之后 P4 的学习，涉及到对指令的解析，也尽量使用宏定义等方式代替数字。 例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> swop 6&#x27;b101011</span><br>...<br><span class="hljs-keyword">assign</span> sw = (`swop == op);<br><br><span class="hljs-comment">// NOT GOOD</span><br><span class="hljs-keyword">assign</span> sw = (<span class="hljs-number">6&#x27;b101011</span> == op);<br>```<span class="hljs-keyword">endcase</span><br></code></pre></td></tr></table></figure>

<h4 id="组合逻辑的编写"><a href="#组合逻辑的编写" class="headerlink" title="组合逻辑的编写"></a>组合逻辑的编写</h4><h5 id="VC-005-信号仅在一个-always-块中赋值"><a href="#VC-005-信号仅在一个-always-块中赋值" class="headerlink" title="VC-005 信号仅在一个 always 块中赋值"></a>VC-005 信号仅在一个 always 块中赋值</h5><p>通常情况下，一个信号只会在一个 <code>always</code> 块中赋值。如果一个信号在多个 <code>always</code> 块中赋值，其结果是不可预测的。</p>
<h5 id="VC-006-组合逻辑采用-always-块或者-assign-编写"><a href="#VC-006-组合逻辑采用-always-块或者-assign-编写" class="headerlink" title="VC-006 组合逻辑采用 always @(*) 块或者 assign 编写"></a>VC-006 组合逻辑采用 <code>always @(*)</code> 块或者 <code>assign</code> 编写</h5><p>组合逻辑的 <code>always</code> 块，使用以下的写法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  c = a + b;<br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">assign</span> c = a + b;<br></code></pre></td></tr></table></figure>

<h5 id="VC-007-组合逻辑-always-块中仅使用阻塞赋值"><a href="#VC-007-组合逻辑-always-块中仅使用阻塞赋值" class="headerlink" title="VC-007 组合逻辑 always 块中仅使用阻塞赋值"></a>VC-007 组合逻辑 <code>always</code> 块中仅使用阻塞赋值</h5><p>表示组合逻辑的 <code>always</code> 块中所有的赋值请使用阻塞赋值（<code>=</code>）。使用非阻塞逻辑(<code>&lt;=</code>)并不能模拟出实际组合逻辑的行为.</p>
<h5 id="VC-008-组合逻辑-always-块中保证每个分支都进行赋值"><a href="#VC-008-组合逻辑-always-块中保证每个分支都进行赋值" class="headerlink" title="VC-008 组合逻辑 always 块中保证每个分支都进行赋值"></a>VC-008 组合逻辑 <code>always</code> 块中保证每个分支都进行赋值</h5><p>如果组合逻辑中存在分支没有被赋值，那么实际综合中会综合出锁存器，FPGA 的底层基本组件并不存在锁存器，锁存器是使用查找表和寄存器组成，资源开销大。因此，如果使用了条件语句 <code>if</code> 或者 <code>switch</code>，需要保证信号在每个可能的分支途径下都进行了&#x3D;&#x3D;赋值&#x3D;&#x3D;，其中 <code>switch</code> 语句一定要写 <code>default</code> 分支，并对信号赋值</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset_n) <span class="hljs-keyword">begin</span><br>    c = a + b;<br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    c = <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset_n) <span class="hljs-keyword">begin</span><br>    c = a + b;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// GOOD</span><br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(status)<br>     `S0:<br>      <span class="hljs-keyword">begin</span><br>        wire1 = <span class="hljs-comment">//...</span><br>        wire2 = <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">begin</span><br>        wire1 = <span class="hljs-comment">//...</span><br>        wire2 = <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-comment">// BAD</span><br>  <span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">case</span>(status)<br>     `S0:<br>      <span class="hljs-keyword">begin</span><br>        wire1 = <span class="hljs-comment">//...</span><br>        wire2 = <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">end</span><br>      <span class="hljs-comment">//... </span><br>      `S7:<br>      <span class="hljs-keyword">begin</span><br>        wire1 = <span class="hljs-comment">//...</span><br>      <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">endcase</span><br>  <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>另外，组合逻辑的 <code>always</code> 块中不要列举敏感信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @ (b, c) <span class="hljs-keyword">begin</span><br>  a = b + c;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">//GOOD</span><br><span class="hljs-keyword">always</span> @(*) <span class="hljs-keyword">begin</span><br>    a=b+c;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h4 id="时序逻辑的编写"><a href="#时序逻辑的编写" class="headerlink" title="时序逻辑的编写"></a>时序逻辑的编写</h4><h5 id="VC-009-时序逻辑在-always-posedge-clock-中实现"><a href="#VC-009-时序逻辑在-always-posedge-clock-中实现" class="headerlink" title="VC-009 时序逻辑在 always @(posedge clock) 中实现"></a>VC-009 时序逻辑在 <code>always @(posedge clock)</code> 中实现</h5><p>当需要表示时序逻辑时，不能使用组合逻辑的写法，一定使用以下的写法：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  c &lt;= a + b;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-010-时序逻辑-always-块中仅使用非阻塞赋值"><a href="#VC-010-时序逻辑-always-块中仅使用非阻塞赋值" class="headerlink" title="VC-010 时序逻辑 always 块中仅使用非阻塞赋值"></a>VC-010 时序逻辑 <code>always</code> 块中仅使用非阻塞赋值</h5><p>时序逻辑 <code>always</code> 块中，所有的赋值请使用非阻塞赋值（<code>&lt;=</code>）。</p>
<h5 id="VC-011-不要使用下降沿触发，特殊协议除外"><a href="#VC-011-不要使用下降沿触发，特殊协议除外" class="headerlink" title="VC-011 不要使用下降沿触发，特殊协议除外"></a>VC-011 不要使用下降沿触发，特殊协议除外</h5><p>通常情况下，请不要使用下降沿触发：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD: do not use negedge</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">negedge</span> clock) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-012-不要使用非时钟-复位信号的边沿触发"><a href="#VC-012-不要使用非时钟-复位信号的边沿触发" class="headerlink" title="VC-012 不要使用非时钟 &#x2F; 复位信号的边沿触发"></a>VC-012 不要使用非时钟 &#x2F; 复位信号的边沿触发</h5><p>通常情况下，不要使用除了时钟和复位以外的信号做边沿触发。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD: do not use non-clock/reset signals</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> signal) <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-013-时序逻辑中不要使用时钟信号"><a href="#VC-013-时序逻辑中不要使用时钟信号" class="headerlink" title="VC-013 时序逻辑中不要使用时钟信号"></a>VC-013 时序逻辑中不要使用时钟信号</h5><p>在时序逻辑中，请不要在敏感列表以外的地方使用时钟信号：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @ (<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (clock) <span class="hljs-keyword">begin</span><br>    a &lt;= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-014-使用同步复位，而不是异步复位"><a href="#VC-014-使用同步复位，而不是异步复位" class="headerlink" title="VC-014 使用同步复位，而不是异步复位"></a>VC-014 使用同步复位，而不是异步复位</h5><p>对于 FPGA，请使用同步复位，因为异步复位容易受到毛刺的影响。 代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// Verilog</span><br><span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clock) <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> (reset) <span class="hljs-keyword">begin</span><br>    c &lt;= <span class="hljs-number">1&#x27;b0</span>;<br>  <span class="hljs-keyword">end</span> <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>    c &lt;= a + b;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h4 id="模块的编写和实例化"><a href="#模块的编写和实例化" class="headerlink" title="模块的编写和实例化"></a>模块的编写和实例化</h4><h5 id="VC-015-不要在内部模块中使用-inout"><a href="#VC-015-不要在内部模块中使用-inout" class="headerlink" title="VC-015 不要在内部模块中使用 inout"></a>VC-015 不要在内部模块中使用 <code>inout</code></h5><p><strong>FPGA 内部的模块之间请不要使用 <code>inout</code>，仿真环境除外。</strong></p>
<h5 id="VC-016-模块内部变量的定义和声明尽量统一"><a href="#VC-016-模块内部变量的定义和声明尽量统一" class="headerlink" title="VC-016 模块内部变量的定义和声明尽量统一"></a>VC-016 模块内部变量的定义和声明尽量统一</h5><p>对于大模块的开发会使用大量的 <code>wire</code> 和 <code>reg</code> 变量，这些变量尽量统一在一个地方定义，后续增量开发在相应地方添加变量，而不是在需要使用的时候在旁边随手定义。另外，以免出现调用未声明变量的问题，可以添加宏定义 <code>default_nettype</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br>  <span class="hljs-keyword">wire</span> RegWrite, MemtoReg, MemWrite, Busy, MdutoGRF;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">0</span>] ALUop;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] Rs, Rt, Rd, WriteReg, shamt, ExcCode, ExcCodetmp, OvResult;<br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Imm, RD1, RD2, SrcA, SrcB, ALUResult, WriteData, PC;<br><span class="hljs-comment">// Bad</span><br>  <span class="hljs-keyword">wire</span> RegWrite;<br>  <span class="hljs-comment">//...... 省略代码</span><br>  <span class="hljs-keyword">wire</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] Imm, RD1, RD2, SrcA, SrcB;<br>  <span class="hljs-comment">//...... 省略代码</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-017-模块的实例化多换行"><a href="#VC-017-模块的实例化多换行" class="headerlink" title="VC-017 模块的实例化多换行"></a>VC-017 模块的实例化多换行</h5><p>后期开发中，一个模块可能有几十个端口。如果模块实例化的时候，端口挤在一起，可读性就会非常差，建议一个端口换一行，<code>input</code> 和 <code>output</code> 分开写，例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// 模块实例化</span><br><span class="hljs-comment">// GOOD</span><br>    test int_test(<br>        <span class="hljs-variable">.clk</span>(clk),<br>        <span class="hljs-variable">.reset</span>(reset),<br>        <span class="hljs-variable">.addr</span>(addr),<br>        <span class="hljs-variable">.we</span>(we),<br>        <span class="hljs-variable">.data_in</span>(data_in),<br>        <span class="hljs-variable">.data_out</span>(data_out)<br>    );<br><span class="hljs-comment">// NOT GOOD</span><br>    test int_test(<span class="hljs-variable">.clk</span>(clk),<span class="hljs-variable">.reset</span>(reset),<span class="hljs-variable">.addr</span>(addr),<span class="hljs-variable">.we</span>(we),<span class="hljs-variable">.data_in</span>(data_in),<span class="hljs-variable">.data_out</span>(data_out));<br></code></pre></td></tr></table></figure>

<h4 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h4><h5 id="VC-018-符号两侧空格部分规则"><a href="#VC-018-符号两侧空格部分规则" class="headerlink" title="VC-018 符号两侧空格部分规则"></a>VC-018 符号两侧空格部分规则</h5><ul>
<li>单目运算符与变量间&#x3D;&#x3D;不添加空格&#x3D;&#x3D;，如 <code>~</code>、<code>!</code>。</li>
<li>双目运算符（除逗号外）和三目运算符两侧添加空格，如 <code>+</code>、<code>=</code>、<code>&lt;</code>、<code>&amp;&amp;</code>。</li>
<li>分号和逗号要紧附前面内容，不应添加空格。</li>
<li>避免连续使用多个空格。</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">assign</span> d =  a + &#123;<span class="hljs-number">1&#x27;b0</span>, b&#125;;<br><span class="hljs-comment">// BAD  </span><br><span class="hljs-keyword">assign</span> d=a+&#123;<span class="hljs-number">1&#x27;b0</span>,b&#125;;<br></code></pre></td></tr></table></figure>

<h5 id="VC-019-换行的使用"><a href="#VC-019-换行的使用" class="headerlink" title="VC-019 换行的使用"></a>VC-019 换行的使用</h5><ul>
<li>对于不同逻辑的代码块建议换行分开，并<strong>加上相应注释区分</strong></li>
<li>对于同一逻辑，但是表达式复杂的语句，使用换行进行语义分割，如</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">assign</span> d = (op == <span class="hljs-number">0</span>) ? a + b :<br>           (op == <span class="hljs-number">1</span>) ? a - b :<br>           (op == <span class="hljs-number">2</span>) ? a &amp; b :<br>                       a | b;<br><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">assign</span> d = (op == <span class="hljs-number">0</span>) ? a + b :(op == <span class="hljs-number">1</span>) ? a - b :(op == <span class="hljs-number">2</span>) ? a &amp; b : a | b;<span class="hljs-comment">//太乱了</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-020-模块缩进"><a href="#VC-020-模块缩进" class="headerlink" title="VC-020 模块缩进"></a>VC-020 模块缩进</h5><p>对于对称的关键字，比如 <code>begin &amp; end</code>，<code>case &amp; endcase</code> ,<code>jork-join</code>等，采用缩进的方式对其进行<strong>优化对齐</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// GOOD</span><br><span class="hljs-keyword">always</span> @(*)<span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">if</span> ()  <span class="hljs-keyword">begin</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">// BAD</span><br><span class="hljs-keyword">always</span> @(*)<span class="hljs-keyword">begin</span><br><span class="hljs-keyword">if</span> ()  <span class="hljs-keyword">begin</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h5 id="VC-021-显式声明位宽"><a href="#VC-021-显式声明位宽" class="headerlink" title="VC-021 显式声明位宽"></a>VC-021 显式声明位宽</h5><p>关于数据位宽有两点说明：</p>
<ul>
<li><p>使用常数时，<strong>声明数据位宽</strong>，避免连线时出现位宽不一致的 Bug。</p>
</li>
<li><p>如果模块要使用数据的某一部分位，如 <code>instruction[25:21]</code>，使用 <code>wire</code> 变量直接截取，重新赋予一个合理的命名，减少字面量以增强可读性。如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">wire</span> [<span class="hljs-number">5</span>:<span class="hljs-number">1</span>] piece = instruction[<span class="hljs-number">25</span>:<span class="hljs-number">21</span>]<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="VC-022-模块抽象"><a href="#VC-022-模块抽象" class="headerlink" title="VC-022 模块抽象"></a>VC-022 模块抽象</h5><p>  对重复使用的复杂代码进行抽象，而不是简单的复制粘贴。</p>
<h3 id="综合工程的要求"><a href="#综合工程的要求" class="headerlink" title="综合工程的要求"></a>综合工程的要求</h3><h4 id="一、前提"><a href="#一、前提" class="headerlink" title="一、前提"></a>一、前提</h4><p>Verilog语法检测通过</p>
<h4 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h4><ul>
<li><p>不使用&#x3D;&#x3D;<code>initial</code>&#x3D;&#x3D;、<code>fork</code>、<code>join</code>、<code>casex</code>、<code>casez</code>、&#x3D;&#x3D;延时语句（例如 <code>#10</code>）&#x3D;&#x3D;、&#x3D;&#x3D;系统任务（例如 <code>$display</code>）&#x3D;&#x3D;等语句，具体可自行查阅学习。</p>
</li>
<li><p>不与 x 和 z 值进行比较</p>
</li>
<li><p>用 <code>always</code> 过程块描述<strong>组合</strong>逻辑时，应在敏感信号列表中列出所有的输入信号（或<strong>使用星号</strong>*）。</p>
</li>
<li><p>用 <code>always</code> 过程块描述<strong>时序</strong>逻辑时，敏感信号只能为<strong>时钟信号</strong>。</p>
</li>
<li><p><strong>所有的内部寄存器都应该能够被复位</strong>。</p>
</li>
<li><p>不能在一个以上的 <code>always</code> 过程块中对<strong>同一个变量</strong>赋值。而对同一个赋值对象不能既使用阻塞式赋值，又使用非阻塞式赋值。</p>
</li>
<li><p>尽量避免出现锁存器（latch），具体避免方法有许多。例如，如果不打算把变量推导成锁存器，那么必须在 <code>if</code> 语句或 <code>case</code> 语句的所有条件分支中都对变量明确地赋值。</p>
</li>
<li><p>避免混合使用上升沿和下降沿触发的触发器。</p>
</li>
</ul>
<h2 id="Verilog高级特性与自动化测试"><a href="#Verilog高级特性与自动化测试" class="headerlink" title="Verilog高级特性与自动化测试"></a>Verilog高级特性与自动化测试</h2><h3 id="编译预处理"><a href="#编译预处理" class="headerlink" title="编译预处理"></a>编译预处理</h3><p>可类比C语言中的<code>#define</code>等语句。</p>
<h4 id="1-宏定义-define"><a href="#1-宏定义-define" class="headerlink" title="1.宏定义 &#96;&#96;define&#96;"></a>1.宏定义 &#96;&#96;define&#96;</h4><p>见时序逻辑建模常用语法中的宏定义。</p>
<h4 id="2-文件包含-include"><a href="#2-文件包含-include" class="headerlink" title="2.文件包含&#96;&#96;include&#96;"></a>2.文件包含&#96;&#96;include&#96;</h4><p>所谓”文件包含”处理是一个源文件可以将另外一个源文件的全部内容包含进来，即将另外的文件包含到本文件之中。Verilog HDL 语言提供了 &#96;&#96;include&#96; 命令用来实现”文件包含”的操作。其一般形式为:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;文件名&quot;</span><br></code></pre></td></tr></table></figure>

<p>在编译的时候，需要对 &#96;&#96;&#96;&#96;include&#96;&#96;&#96; 命令进行”文件包含”预处理：将 File2.v 的全部内容复制插入到 &#96;&#96;include “File2.v”&#96; 命令出现的地方，即将 File2.v 被包含到 File1.v 中。在接着往下进行编译中，将”包含”以后的 File1.v 作为一个源文件单位进行编译。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// define.v</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WIDTH 8</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> CYCLE 100</span><br><span class="hljs-comment">// counter.v</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;<span class="hljs-keyword">define</span>.v&quot;</span><span class="hljs-comment">//将define.v中内容插入到此处</span><br><span class="hljs-keyword">module</span> counter(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> reset,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [`WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] count<br>);<br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset)<br>      count &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (count + <span class="hljs-number">1</span> == `CYCLE)<br>        count &lt;= <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">else</span><br>        count &lt;= count + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>在经过预处理后，counter.v将变成：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// counter.v</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WIDTH 8</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> CYCLE 100</span><br><span class="hljs-keyword">module</span> counter(<br>  <span class="hljs-keyword">input</span> clk,<br>  <span class="hljs-keyword">input</span> reset,<br>  <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [`WIDTH-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] count<br>);<br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">if</span> (reset)<br>      count &lt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span><br>      <span class="hljs-keyword">if</span> (count + <span class="hljs-number">1</span> == `CYCLE)<br>        count &lt;= <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">else</span><br>        count &lt;= count + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>四点说明：</p>
<ol>
<li><p>一个 &#96;&#96;&#96;&#96;include&#96;&#96;&#96; 命令只能指定一个被包含的文件，如果要包含 n 个文件，要用 n 个 &#96;&#96;include&#96; 命令。注意下面的写法是非法的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;aaa.v&quot;&quot;bbb.v&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>&#96;&#96;include&#96; 命令可以出现在 Verilog HDL 源程序的任何地方，被包含文件名可以是相对路径名，也可以是绝对路径名。例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;parts/count.v&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>可以将多个 &#96;&#96;&#96;&#96;include&#96;&#96;&#96;命令写在一行，这一行除 &#96;&#96;include&#96; 命令以外，只可以含有空格和单行注释。例如下面的写法是&#x3D;&#x3D;合法&#x3D;&#x3D;的：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;fileB&quot; `<span class="hljs-keyword">include</span> &quot;fileC&quot; </span><span class="hljs-comment">// including fileB and fileC</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如果文件 1 包含文件 2，而文件 2 要用到文件 3 的内容，则可以在文件 1 用两个 &#96;&#96;include&#96; 命令分别包含文件 2 和文件 3，而且<strong>文件 3 应出现在文件 2 之前</strong>。</p>
</li>
</ol>
<hr>
<p><strong>补充：宏文件的引用</strong></p>
<p>在具体代码实践中，我们定义的宏常常在多个文件中都需要使用。如果在每个文件中都采用复制粘贴的方式，那么在修改的时候就会有很大的工程量，所以我们常常单独开一个文件进行宏的定义，在其他文件中对这个“宏文件”进行引用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// macro.v</span><br><span class="hljs-meta">`<span class="hljs-keyword">define</span> WORDSIZE 8</span><br><br><span class="hljs-comment">// test1.v</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;macro.v&quot;</span><br><br><span class="hljs-keyword">module</span> test1 <span class="hljs-keyword">reg</span>[<span class="hljs-number">1</span>:`WORDSIZE] data;<br>  <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// test2.v</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;macro.v&quot;</span><br><br><span class="hljs-keyword">module</span> test2 <span class="hljs-keyword">reg</span>[<span class="hljs-number">1</span>:`WORDSIZE] data;<br>  <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p><code>macro.v</code> 是我们定义的一个“宏文件”，在其他需要使用到这个“宏文件”的文件头部，使用 &#96;&#96;include “macro.v”&#96; 就可以使用“宏文件”中定义的宏了。</p>
<h5 id="注意：不要-include-电路模块文件"><a href="#注意：不要-include-电路模块文件" class="headerlink" title="注意：不要 include 电路模块文件"></a>注意：<strong>不要 include 电路模块文件</strong></h5><p>在一个 .v 文件中使用其他 .v 文件定义的电路模块，请不要用 &#96;&#96;include&#96; 命令包含模块定义的文件，而是将定义和使用模块的 .v 文件全部加入工程中，一起编译，否则在线评测时可能造成 “模块重复定义” 错误。一个反例如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// aaa.v</span><br><span class="hljs-keyword">module</span> aaa(a, b, out);<br>  <span class="hljs-keyword">input</span> a, b;<br>  <span class="hljs-keyword">output</span> out;<br>  <span class="hljs-keyword">wire</span> out;<br>  <span class="hljs-keyword">assign</span> out = a ^ b;<br><span class="hljs-keyword">endmodule</span><br><br><span class="hljs-comment">// bbb.v</span><br><span class="hljs-meta">`<span class="hljs-keyword">include</span> &quot;aaa.v&quot;</span><br><span class="hljs-keyword">module</span> bbb(c, d, e, out);<br>  <span class="hljs-keyword">input</span> c, d, e;<br>  <span class="hljs-keyword">output</span> out;<br>  <span class="hljs-keyword">wire</span> out_a;<br>  <span class="hljs-keyword">wire</span> out;<br>  aaa aaa(<span class="hljs-variable">.a</span>(c), <span class="hljs-variable">.b</span>(d), <span class="hljs-variable">.out</span>(out_a));<br>  <span class="hljs-keyword">assign</span> out = e &amp; out_a;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>经过编译器的预处理（将文件 aaa.v 的内容复制到 bbb.v 中），文件 bbb.v 的完整内容为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">// bbb.v</span><br><span class="hljs-keyword">module</span> aaa(a, b, out);<br>  <span class="hljs-keyword">input</span> a, b;<br>  <span class="hljs-keyword">output</span> out;<br>  <span class="hljs-keyword">wire</span> out;<br>  <span class="hljs-keyword">assign</span> out = a ^ b;<br><span class="hljs-keyword">endmodule</span><br><span class="hljs-keyword">module</span> bbb(c, d, e, out);<br>  <span class="hljs-keyword">input</span> c, d, e;<br>  <span class="hljs-keyword">output</span> out;<br>  <span class="hljs-keyword">wire</span> out_a;<br>  <span class="hljs-keyword">wire</span> out;<br>  aaa aaa(<span class="hljs-variable">.a</span>(c), <span class="hljs-variable">.b</span>(d), <span class="hljs-variable">.out</span>(out_a));<br>  <span class="hljs-keyword">assign</span> out = e &amp; out_a;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>评测机将 aaa.v 与 bbb.v 共同编译，模块 <code>aaa</code> 发生重复定义，导致编译错误。</p>
<p>只有在需要引用宏文件时才使用 &#96;&#96;include&#96;。</p>
<h4 id="3-timescale"><a href="#3-timescale" class="headerlink" title="3.&#96;timescale"></a>3.&#96;timescale</h4><figure class="highlight plaintext"><figcaption><span>命令用来说明跟在该命令后的模块的**时间单位**和**时间精度**。使用 ``timescale` 命令可以在同一个设计里包含采用了不同的时间单位的模块。例如，一个设计中包含了两个模块，其中一个模块的时间延迟单位为纳秒 (ns)，另一个模块的时间延迟单位为皮秒 (ps)。EDA 工具仍然可以对这个设计进行仿真测试。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs `timescale```"><br>``timescale` 命令的格式如下：<br><br>```verilog<br>`timescale [时间单位]/[时间精度]<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-meta">`<span class="hljs-keyword">timescale</span> 1ns/1ps;</span><br></code></pre></td></tr></table></figure>

<p>在这个命令之后，模块中所有的时间值都表示是 1ns 的整数倍。这是因为在 &#96;&#96;&#96;&#96;timescale&#96;&#96;&#96; 命令中，定义了时间单位是 1ns。模块中的延迟时间可表达为带3位小数的实型数，因为 &#96;&#96;timescale&#96; 命令定义时间精度为 1ps。</p>
<h4 id="4-条件编译命令-ifdef-else-elsif-endif-ifndef"><a href="#4-条件编译命令-ifdef-else-elsif-endif-ifndef" class="headerlink" title="4.条件编译命令 &#96;&#96;&#96;&#96;ifdef,else,elsif,endif,ifndef&#96;&#96;&#96;"></a>4.条件编译命令 &#96;&#96;&#96;&#96;ifdef,<code>else,</code>elsif,<code>endif,</code>ifndef&#96;&#96;&#96;</h4><p>和 C 语言类似，这些条件编译编译指令用于包含 Verilog HDL 的可选行编译期间的源描述。 &#96;&#96;&#96;ifdef<code>编译器指令检查 text_macro_name 的定义，如果定义了 text_macro_name，那么 ’ifdef 指令后面的行被包含在内。如果未定义 text_macro_name 并且存在 ‘else指令，则编译 </code>else<code> 后的源描述。(部分</code>用‘代替)</p>
<p>’ifndef 编译器指令检查 text_macro_name 的定义。如果未定义 text_macro_name，则包含 ‘ifndef 指令后面的行。如果定义了 text_macro_name 并且存在’else 指令，则编译 ’else 后的源描述。如果 ‘elsif 指令存在（注意不是 ’else），编译器会检查 text_macro_name 的定义。如果定义存在，则包含 &#96;&#96;elsif<code> 指令后面的行。(部分</code>用‘代替)</p>
<p>’elseif 指令等同于编译器指令序列 ‘else ’ifdef …‘endif。该指令不需要相应的 ’endif指令。该指令必须以 ‘ifdef 或 ’ifndef 指令开头。(部分&#96;用‘代替)</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> and_op (a, b, c);<br><span class="hljs-keyword">output</span> a;<br><span class="hljs-keyword">input</span> b, c;<br><span class="hljs-meta">`<span class="hljs-keyword">ifdef</span> behavioral</span><br>  <span class="hljs-keyword">wire</span> a = b &amp; c;<br><span class="hljs-meta">`<span class="hljs-keyword">else</span></span><br>  <span class="hljs-keyword">and</span> a1(a, b, c);<br><span class="hljs-meta">`<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>大家可以充分利用条件编译指令来灵活控制自己的代码。</p>
<h3 id="系统任务"><a href="#系统任务" class="headerlink" title="系统任务"></a>系统任务</h3><p>Verilog 中还提供了很多系统任务，类似于 C 中的库函数，使用这些系统任务可以方便地进行测试。</p>
<h4 id="输出信息"><a href="#输出信息" class="headerlink" title="输出信息"></a>输出信息</h4><p>格式：<code>$display(p1, p2, ..., pn)</code>;</p>
<p>这个系统任务的作用是用来输出信息，即将参数 p2 到 pn 按参数 p1 给定的格式输出。用法和 C 语言中的 printf 类似。下面用一个例子简单介绍其用法。</p>
<p>例如：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> disp;<br>    <span class="hljs-keyword">reg</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] a;<br>    <span class="hljs-keyword">reg</span>[<span class="hljs-number">4</span>:<span class="hljs-number">0</span>] b;<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        a = <span class="hljs-number">10</span>;<br>        b = <span class="hljs-number">20</span>;<br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;a = %d,b = %d\n&quot;</span>,a,b);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>其输出结果为： a &#x3D; 10,b &#x3D; 20</p>
<p>其中 <code>%d</code> 表示以十进制的形式输出，<code>\n</code> 为换行符。</p>
<p>在此说明几种常用的输出格式：</p>
<table>
<thead>
<tr>
<th align="left">输出格式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">%h 或 %H</td>
<td align="left">以十六进制数的形式输出</td>
</tr>
<tr>
<td align="left">%d 或 %D</td>
<td align="left">以十进制数的形式输出</td>
</tr>
<tr>
<td align="left">%b 或 %B</td>
<td align="left">以二进制数的形式输出</td>
</tr>
<tr>
<td align="left">%c 或 %C</td>
<td align="left">以 ASCII 码字符的形式输出</td>
</tr>
<tr>
<td align="left">%s 或 %S</td>
<td align="left">以字符串的形式输出</td>
</tr>
</tbody></table>
<h4 id="监控变量"><a href="#监控变量" class="headerlink" title="监控变量"></a>监控变量</h4><p>格式：</p>
<ul>
<li><code>$monitor(p1, p2, ..., pn);</code></li>
<li><code>$monitor;</code></li>
<li><code>$monitoron;</code></li>
<li><code>$monitoroff;</code></li>
</ul>
<p>任务 <code>$monitor</code> 提供了监控和输出参数列表中的表达式或变量值的功能。其参数列表中输出控制格式字符串和输出列表的规则和 <code>$display</code> 中的一样。当启动带有一个或多个参数的 <code>$monitor</code> 任务时，仿真器则建立一个处理机制，使得<strong>每当参数列表中变量或表达式的值发生变化</strong>时，整个参数列表中变量或表达式的值都将<strong>输出显示</strong>。如果同一时刻，两个或多个参数的值发生变化，则在该时刻<strong>只</strong>输出显示<strong>一次</strong>。</p>
<p><code>$monitoron</code> 和 <code>$monitoroff</code> 任务的作用是通过打开和关闭监控标志来控制监控任务 <code>$monitor</code> 的启动和停止，这样使得程序员可以很容易地控制 <code>$monitor</code> 何时发生。其中 <code>$monitoroff</code> 任务用于关闭监控标志，停止监控任务 <code>$monitor</code> ， <code>$monitoron</code> 则用于打开监控标志，启动 <code>$monitor</code> 监控任务。 <strong><code>$monitor</code> 与 <code>$display</code> 的不同处还在于 <code>$monitor</code> 往往在 <code>initial</code> 块中调用，只要不调用 <code>$monitoroff</code>， <code>$monitor</code> 便不间断地对所设定的信号进行监视。</strong></p>
<h4 id="读取文件到存储器"><a href="#读取文件到存储器" class="headerlink" title="读取文件到存储器"></a>读取文件到存储器</h4><h5 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h5><ul>
<li><code>$readmemh(&quot;&lt;数据文件名&gt;&quot;, &lt;存储器名&gt;);</code></li>
<li><code>$readmemh(&quot;&lt;数据文件名&gt;&quot;, &lt;存储器名&gt;, &lt;起始地址&gt;);</code></li>
<li><code>$readmemh(&quot;&lt;数据文件名&gt;&quot;, &lt;存储器名&gt;, &lt;起始地址&gt;, &lt;结束地址&gt;);</code></li>
</ul>
<h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p> <code>$readmemh</code> 函数会根据绝对&#x2F;相对路径找到需要访问的文件，按照 ASCII 的解码方式将文件字节流解码并读入容器。文件中的内容<strong>必须是十六进制数字 0~f 或是不定值 x，高阻值 z（字母大小写均可），不需要前导 0x，不同的数用空格或换行隔开</strong>。假设存储器名为 arr，起始地址为 s，结束地址为 d，那么文件中用空格隔开的数字会依次读入到 arr[s],arr[s+1]… 到 arr[d]。假如<strong>数字的位数大于数组元素的位数，那么只有低位会被读入，剩下的高位会被忽略</strong>。</p>
<p>此系统任务用来从文件中读取数据到存储器中，类似于 C 语言中的 fread 函数。</p>
<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> im;<br>    <span class="hljs-keyword">reg</span> [<span class="hljs-number">31</span>:<span class="hljs-number">0</span>] im_reg [<span class="hljs-number">0</span>:<span class="hljs-number">2047</span>];<br>    <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$readmemh</span>(<span class="hljs-string">&quot;code.txt&quot;</span>, im_reg);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>仿真后即可将 code.txt 中的内容读入 <code>im_reg</code> 存储器中。</p>
<h5 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h5><p>表示存储器数量的中括号内的范围如果是从高到低的，例如 <code>reg [31:0] img_reg [2047:0]</code> ，则采用 <code>$readmemh(&quot;&lt;数据文件名&gt;&quot;, &lt;存储器名&gt;, &lt;起始地址&gt;);</code> 这种格式进行读入会在 ISE 和 VCS 上会得到不同的结果：在 ISE 中读入的数据从起始地址<strong>依次向低下标填充</strong>，而 VCS 中读入的数据从起始地址<strong>依次向高下标填充</strong>。</p>
<p>例如以下代码片段，读取文件后按下标顺序输出存储器的内容：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] mem [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">integer</span> i;<br><br><span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>    <span class="hljs-built_in">$readmemh</span>(<span class="hljs-string">&quot;code.txt&quot;</span>, mem, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i = i + <span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span><br>        <span class="hljs-built_in">$display</span>(<span class="hljs-string">&quot;%1d: %02x&quot;</span>, i, mem[i]);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>数据文件 <code>code.txt</code> 内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">01<br>02<br></code></pre></td></tr></table></figure>

<p>这段代码在 ISE 和 VCS 中分别仿真会得到不同的结果，其中 ISE 仿真输出为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-number">0</span>: <span class="hljs-number">02</span><br><span class="hljs-number">1</span>: <span class="hljs-number">01</span><br><span class="hljs-number">2</span>: xx<br><span class="hljs-number">3</span>: xx<br></code></pre></td></tr></table></figure>

<p>而 VCS 仿真输出为：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-number">0</span>: xx<br><span class="hljs-number">1</span>: <span class="hljs-number">01</span><br><span class="hljs-number">2</span>: <span class="hljs-number">02</span><br><span class="hljs-number">3</span>: xx<br></code></pre></td></tr></table></figure>

<p>要避免上述差异带来的影响，请按&#x3D;&#x3D;从低到高&#x3D;&#x3D;的范围声明存储器的数量，例如上述代码修改为 <code>reg [7:0] mem [0:3]</code> ；或在使用&#x3D;&#x3D;从高到低&#x3D;&#x3D;范围时显式给出 readmemh 的结束地址，例如 <code>$readmemh(&quot;code.txt&quot;, mem, 1, 3)</code> ，其中结束地址可以超过实际填充了数据的地址，只需大于起始地址。</p>
<h3 id="层次化事件队列"><a href="#层次化事件队列" class="headerlink" title="层次化事件队列"></a>层次化事件队列</h3><p>由于Verilog 是硬件描述语言（HDL），语句的执行顺序与 C 语言程序有很大差异。层次化事件队列是硬件仿真（Simulation）时，用于规定“不同事件执行的优先级关系”，在这里我们可以一般将一个事件理解为需要运行的一条语句（当然，有的语句由多个事件组成，例如非阻塞赋值需要被拆分为计算等号右边的值（RHS）和将结果赋予等号的左边变量（LHS），赋值事件在计算事件执行结束时才能加入队列。根据事件的优先级，Verilog 将其分为 4 个队列<strong>（队列间的优先级不同，从上到下优先级依次递减，只有当优先级高的队列中所有任务完成后，才会继续完成优先级较低的任务）</strong></p>
<ol>
<li><p>动态事件队列（动态事件队列在队列内部执行顺序无硬性规定，但在同一个<code>begin-end</code>语句块中的语句应当严格按照源代码中的顺序执行；且多个非阻塞赋值应当按照语句执行顺序进行）</p>
<ul>
<li>阻塞赋值</li>
<li>计算非阻塞赋值语句右边的表达式（RHS）</li>
<li>连续赋值（如 <code>assign</code>）</li>
<li>执行 <code>display</code> 命令</li>
<li>……</li>
</ul>
</li>
<li><p>停止运行的时间队列（#0）（不推荐使用）</p>
</li>
<li><p>非阻塞事件队列：更新非阻塞赋值语句 LHS（左边变量）的值。</p>
</li>
<li><p>监控事件队列（执行 <code>monitor</code>，<code>strobe</code> 命令）</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>1.为何“阻塞与非阻塞的区别”视频教程的代码中，阻塞赋值与非阻塞赋值最终的结果存在不同（请对比两种赋值方式在更新等号左边变量操作（LHS）的优先级）？（因为阻塞赋值更新等号左边变量操作的优先级大于非阻塞赋值的，导致阻塞赋值中c同b同步被赋值为a的值，而非阻塞赋值中，c需要等一个周期才被赋为a的值。）</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> blocked_and_non_blocked(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">input</span> a,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> b_blocked,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> c_blocked,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> b_non_blocked,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> c_non_blocked<br>    );<br><br>  <span class="hljs-comment">// 阻塞赋值</span><br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>     b_blocked = a;<br>     c_blocked = b_blocked;<br>  <span class="hljs-keyword">end</span><br>  <span class="hljs-comment">// 非阻塞赋值</span><br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>     b_non_blocked &lt;= a;<br>     c_non_blocked &lt;= b_non_blocked;<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<p>2.有时在 <code>always</code> 语句块中，使用 <code>display</code>、<code>strobe</code>、<code>monitor</code> 三种输出语句会得到不同结果，这是为什么？（例如下面的代码，同一时刻的 <code>display</code> 和 <code>monitor</code> 所输出的值为何相差 1？）（因为优先级：执行<code>display</code>命令&gt;LHS&gt;执行<code>monitor</code>命令，所以在<code>always</code>块中，display命令输出的总是LHS之前的值，而monitor输出的则是LHS之后的值，又因为LHS执行后值加一，所以同一时刻的display和monitor输出的值相差1）。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">module</span> display_monitor_diff(<br>    <span class="hljs-keyword">input</span> clk,<br>    <span class="hljs-keyword">output</span> <span class="hljs-keyword">reg</span> [<span class="hljs-number">3</span>:<span class="hljs-number">0</span>] out<br>    );<br><br>  <span class="hljs-keyword">initial</span> <span class="hljs-keyword">begin</span><br>     out = <span class="hljs-number">0</span>;<br>     <span class="hljs-built_in">$monitor</span>(<span class="hljs-built_in">$time</span>,<span class="hljs-string">&quot;monitor out = %d&quot;</span>,out);<br>  <span class="hljs-keyword">end</span><br><br>  <span class="hljs-keyword">always</span> @(<span class="hljs-keyword">posedge</span> clk) <span class="hljs-keyword">begin</span><br>     out &lt;= out + <span class="hljs-number">1</span>;<br>     <span class="hljs-built_in">$display</span>(<span class="hljs-built_in">$time</span>,<span class="hljs-string">&quot;display out = %d&quot;</span>,out);<br>  <span class="hljs-keyword">end</span><br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-number">0</span> monitor <span class="hljs-keyword">out</span> =  <span class="hljs-number">0</span><br><span class="hljs-number">20</span> display <span class="hljs-keyword">out</span> =  <span class="hljs-number">0</span><br><span class="hljs-number">20</span> monitor <span class="hljs-keyword">out</span> =  <span class="hljs-number">1</span><br><span class="hljs-number">60</span> display <span class="hljs-keyword">out</span> =  <span class="hljs-number">1</span><br><span class="hljs-number">60</span> monitor <span class="hljs-keyword">out</span> =  <span class="hljs-number">2</span><br>......<br></code></pre></td></tr></table></figure>

<p>3.在一个 <code>always</code> 语句块中同时使用阻塞赋值与非阻塞赋值存在什么风险（提示：请结合同一事件队列中的任务顺序无硬性规定这一特点）？由这个结论，在书写语句块时应该遵循哪些规范？</p>
</li>
</ol>
<h3 id="default-nettype"><a href="#default-nettype" class="headerlink" title="&#96;default nettype"></a>&#96;default nettype</h3><figure class="highlight plaintext"><figcaption><span>用于设置缺省类型，在代码文件的任意位置加入 'default_nettype宏(用'代替)，都可以使得该代码文件中所有变量的缺省类型改变。若代码中有两个以上的 ``default_nettype` 宏，则将会以最后一条为准。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs default_nettype``"><br>若需要取消缺省类型，即若不显式声明类型就会报错，则应该使用 ``default_nettype none`。以上的示例将会由于 temp 和 b 都未显式指定类型而报错。<br><br>```verilog<br>module test(input temp);<br>    wire [3:0] a;<br>    assign a=4&#x27;b1000;<br>    assign b=a;<br>endmodule<br>`default_nettype none<br></code></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://ywxy12138.github.io">聿尛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://ywxy12138.github.io/2024/08/28/Verilog%E4%B8%8E%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7/">http://ywxy12138.github.io/2024/08/28/Verilog与仿真工具/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ywxy12138.github.io" target="_blank">yumooo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Verilog/">Verilog</a></div><div class="post_share"><div class="social-share" data-image="/img/HDL.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/23/C%E8%AF%AD%E8%A8%80/" title="C语言"><img class="cover" src="/img/C.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C语言</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/02/%E8%AE%A1%E7%BB%84/" title="计组"><img class="cover" src="/img/OIP-C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计组</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E8%8A%B1%E9%AC%98.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">聿尛</div><div class="author-info__description">孤独永恒，死亡永生。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ywxy12138"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无可奈何花落去，似曾相识燕归来！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Verilog%E4%B8%8E%E4%BB%BF%E7%9C%9F%E5%B7%A5%E5%85%B7"><span class="toc-number">1.</span> <span class="toc-text">Verilog与仿真工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Verilog%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.1.</span> <span class="toc-text">Verilog建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%BA%A7%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">结构级建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E7%BA%A7%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">行为级描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5-assign"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">连续赋值语句 assign</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E4%B8%8E%E6%9C%89%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">过程控制语句与有关结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">变量和模块输出间的关系</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%98%E5%8C%96%E8%A7%84%E5%BE%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">变量变化规律的描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%92%8C%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">1.1.2.2.2.1.</span> <span class="toc-text">两种基本结构和语句块</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.2.2.2.2.</span> <span class="toc-text">常见的过程控制语句</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E6%8F%8F%E8%BF%B0%E7%9A%84%E4%B8%80%E8%88%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">过程控制语句描述的一般用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ISE%E5%85%A5%E9%97%A8"><span class="toc-number">1.2.</span> <span class="toc-text">ISE入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.1.</span> <span class="toc-text">输入输出设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%9D%BF%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.2.</span> <span class="toc-text">语言模板辅助工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">语言模板的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VCS%E5%85%A5%E9%97%A8"><span class="toc-number">1.3.</span> <span class="toc-text">VCS入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#VCS%E4%B8%8EVerdi%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">VCS与Verdi简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VCS%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.2.</span> <span class="toc-text">VCS项目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">编译项目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Verilog%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">Verilog语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">模块的定义方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">常用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wire%E5%9E%8B"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">wire型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reg%E5%9E%8B"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">reg型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-reg-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BB%BA%E6%A8%A1%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.4.2.2.1.</span> <span class="toc-text">利用 reg 数据类型建模存储器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#memory%E5%9E%8B"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">memory型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">数字字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#integer%E5%9E%8B"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">integer型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parameter-%E5%9E%8B"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">parameter 型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">几个实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">组合逻辑建模常用语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#assign-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">assign 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">常用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">常用实现方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">时序逻辑建模常用语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#always-%E5%9D%97"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">always 块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initial-%E5%9D%97"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">initial 块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">if语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">case语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">for语句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.4.5.1.</span> <span class="toc-text">循环变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9D%9F%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.4.5.2.</span> <span class="toc-text">循环结束条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-%E8%AF%AD%E5%8F%A5%E5%AF%B9%E5%BA%94%E5%AE%9E%E9%99%85%E7%BA%BF%E8%B7%AF"><span class="toc-number">1.4.4.5.3.</span> <span class="toc-text">for 语句对应实际线路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.4.5.4.</span> <span class="toc-text">for语句应用示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">while语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.4.7.</span> <span class="toc-text">时间控制语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.4.8.</span> <span class="toc-text">常用实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%85%B8%E5%9E%8B%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.5.</span> <span class="toc-text">模块的典型内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.4.6.</span> <span class="toc-text">阻塞赋值与非阻塞赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">非阻塞赋值语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">阻塞赋值语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.4.7.</span> <span class="toc-text">块语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9D%97"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">顺序块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.4.7.1.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.4.7.1.2.</span> <span class="toc-text">格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%9D%97"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">并行块</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.4.7.2.1.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F-1"><span class="toc-number">1.4.7.2.2.</span> <span class="toc-text">格式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E5%90%8D"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">块名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.8.</span> <span class="toc-text">有符号数的处理方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E5%BC%95%E5%85%A5%EF%BC%9A"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">例子引入：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">原理简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">概念定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8E%9F%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%82"><span class="toc-number">1.4.8.3.1.</span> <span class="toc-text">表达式和原子表达式。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%86%B3%E5%AE%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F-self-determined-expression-%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%86%B3%E5%AE%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F-context-determined-expression-%E3%80%82"><span class="toc-number">1.4.8.3.2.</span> <span class="toc-text">自决定表达式(self-determined expression)和上下文决定表达式(context-determined expression)。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%96%E5%B1%82%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%A6%E5%8F%B7%E7%9A%84%E7%A1%AE%E5%AE%9A"><span class="toc-number">1.4.8.4.</span> <span class="toc-text">最外层表达式符号的确定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%86%85%E4%BC%A0%E6%92%AD"><span class="toc-number">1.4.8.5.</span> <span class="toc-text">向内传播</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">1.4.8.6.</span> <span class="toc-text">一些特殊情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.8.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.4.8.8.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.9.</span> <span class="toc-text">宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E5%AE%BD"><span class="toc-number">1.4.10.</span> <span class="toc-text">数据位宽 [+:] [-:]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Verilog%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E8%B0%83%E8%AF%95"><span class="toc-number">1.5.</span> <span class="toc-text">Verilog工程的设计开发调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%94%A8-initial-%E5%9D%97%E3%80%81%E4%B8%8D%E8%A6%81%E4%B8%BA%E5%AF%84%E5%AD%98%E5%99%A8%E8%B5%8B%E5%88%9D%E5%80%BC"><span class="toc-number">1.5.1.</span> <span class="toc-text">不要用 initial 块、不要为寄存器赋初值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%AA%E8%83%BD%E5%9C%A8%E4%B8%80%E4%B8%AA-always-%E5%9D%97%E4%B8%AD%E8%B5%8B%E5%80%BC%E4%B8%80%E6%AC%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">一个寄存器只能在一个 always 块中赋值一次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.3.</span> <span class="toc-text">组合逻辑相关注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B9%98%E9%99%A4%E6%B3%95-%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E6%9D%A5%E4%BB%A3%E6%9B%BF%E4%B9%98%E9%99%A4%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">不要使用乘除法 - 用位运算来代替乘除法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Verilog%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.5.5.</span> <span class="toc-text">Verilog代码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">命名</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-001-%E4%BF%A1%E5%8F%B7%E5%90%8D%E7%A7%B0%E9%87%87%E7%94%A8-snake-case%EF%BC%8CPascalCase-%E6%88%96%E8%80%85-camelCase"><span class="toc-number">1.5.5.1.1.</span> <span class="toc-text">VC-001 信号名称采用 snake_case，PascalCase 或者 camelCase</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-002-%E4%BF%A1%E5%8F%B7%E6%9E%81%E6%80%A7%E4%B8%BA%E4%BD%8E%E6%9C%89%E6%95%88%E7%94%A8-n-%E5%90%8E%E7%BC%80%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.5.5.1.2.</span> <span class="toc-text">VC-002 信号极性为低有效用 _n 后缀表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-003-%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8%E6%A0%87%E6%98%8E%E8%A7%84%E6%A0%BC"><span class="toc-number">1.5.5.1.3.</span> <span class="toc-text">VC-003 多路选择器标明规格</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-004-%E9%AD%94%E6%95%B0%EF%BC%88magic-number%EF%BC%89%E7%9A%84%E5%91%BD%E5%90%8D"><span class="toc-number">1.5.5.1.4.</span> <span class="toc-text">VC-004 魔数（magic number）的命名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%9A%84%E7%BC%96%E5%86%99"><span class="toc-number">1.5.5.2.</span> <span class="toc-text">组合逻辑的编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-005-%E4%BF%A1%E5%8F%B7%E4%BB%85%E5%9C%A8%E4%B8%80%E4%B8%AA-always-%E5%9D%97%E4%B8%AD%E8%B5%8B%E5%80%BC"><span class="toc-number">1.5.5.2.1.</span> <span class="toc-text">VC-005 信号仅在一个 always 块中赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-006-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E9%87%87%E7%94%A8-always-%E5%9D%97%E6%88%96%E8%80%85-assign-%E7%BC%96%E5%86%99"><span class="toc-number">1.5.5.2.2.</span> <span class="toc-text">VC-006 组合逻辑采用 always @(*) 块或者 assign 编写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-007-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91-always-%E5%9D%97%E4%B8%AD%E4%BB%85%E4%BD%BF%E7%94%A8%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.5.5.2.3.</span> <span class="toc-text">VC-007 组合逻辑 always 块中仅使用阻塞赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-008-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91-always-%E5%9D%97%E4%B8%AD%E4%BF%9D%E8%AF%81%E6%AF%8F%E4%B8%AA%E5%88%86%E6%94%AF%E9%83%BD%E8%BF%9B%E8%A1%8C%E8%B5%8B%E5%80%BC"><span class="toc-number">1.5.5.2.4.</span> <span class="toc-text">VC-008 组合逻辑 always 块中保证每个分支都进行赋值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E7%9A%84%E7%BC%96%E5%86%99"><span class="toc-number">1.5.5.3.</span> <span class="toc-text">时序逻辑的编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-009-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E5%9C%A8-always-posedge-clock-%E4%B8%AD%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.5.3.1.</span> <span class="toc-text">VC-009 时序逻辑在 always @(posedge clock) 中实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-010-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91-always-%E5%9D%97%E4%B8%AD%E4%BB%85%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.5.5.3.2.</span> <span class="toc-text">VC-010 时序逻辑 always 块中仅使用非阻塞赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-011-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%99%8D%E6%B2%BF%E8%A7%A6%E5%8F%91%EF%BC%8C%E7%89%B9%E6%AE%8A%E5%8D%8F%E8%AE%AE%E9%99%A4%E5%A4%96"><span class="toc-number">1.5.5.3.3.</span> <span class="toc-text">VC-011 不要使用下降沿触发，特殊协议除外</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-012-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E9%9D%9E%E6%97%B6%E9%92%9F-%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7%E7%9A%84%E8%BE%B9%E6%B2%BF%E8%A7%A6%E5%8F%91"><span class="toc-number">1.5.5.3.4.</span> <span class="toc-text">VC-012 不要使用非时钟 &#x2F; 复位信号的边沿触发</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-013-%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91%E4%B8%AD%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.5.5.3.5.</span> <span class="toc-text">VC-013 时序逻辑中不要使用时钟信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-014-%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E5%A4%8D%E4%BD%8D%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%BC%82%E6%AD%A5%E5%A4%8D%E4%BD%8D"><span class="toc-number">1.5.5.3.6.</span> <span class="toc-text">VC-014 使用同步复位，而不是异步复位</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BC%96%E5%86%99%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.5.5.4.</span> <span class="toc-text">模块的编写和实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-015-%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%86%85%E9%83%A8%E6%A8%A1%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8-inout"><span class="toc-number">1.5.5.4.1.</span> <span class="toc-text">VC-015 不要在内部模块中使用 inout</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-016-%E6%A8%A1%E5%9D%97%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E%E5%B0%BD%E9%87%8F%E7%BB%9F%E4%B8%80"><span class="toc-number">1.5.5.4.2.</span> <span class="toc-text">VC-016 模块内部变量的定义和声明尽量统一</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-017-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%A4%9A%E6%8D%A2%E8%A1%8C"><span class="toc-number">1.5.5.4.3.</span> <span class="toc-text">VC-017 模块的实例化多换行</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.5.5.5.</span> <span class="toc-text">代码风格</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-018-%E7%AC%A6%E5%8F%B7%E4%B8%A4%E4%BE%A7%E7%A9%BA%E6%A0%BC%E9%83%A8%E5%88%86%E8%A7%84%E5%88%99"><span class="toc-number">1.5.5.5.1.</span> <span class="toc-text">VC-018 符号两侧空格部分规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-019-%E6%8D%A2%E8%A1%8C%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.5.5.2.</span> <span class="toc-text">VC-019 换行的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-020-%E6%A8%A1%E5%9D%97%E7%BC%A9%E8%BF%9B"><span class="toc-number">1.5.5.5.3.</span> <span class="toc-text">VC-020 模块缩进</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-021-%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E4%BD%8D%E5%AE%BD"><span class="toc-number">1.5.5.5.4.</span> <span class="toc-text">VC-021 显式声明位宽</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#VC-022-%E6%A8%A1%E5%9D%97%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.5.5.5.5.</span> <span class="toc-text">VC-022 模块抽象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">1.5.6.</span> <span class="toc-text">综合工程的要求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%89%8D%E6%8F%90"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">一、前提</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E3%80%81"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">二、</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Verilog%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">1.6.</span> <span class="toc-text">Verilog高级特性与自动化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">编译预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%8F%E5%AE%9A%E4%B9%89-define"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">1.宏定义 &#96;&#96;define&#96;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-include"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">2.文件包含&#96;&#96;include&#96;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E4%B8%8D%E8%A6%81-include-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">注意：不要 include 电路模块文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-timescale"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">3.&#96;timescale</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4-ifdef-else-elsif-endif-ifndef"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">4.条件编译命令 &#96;&#96;&#96;&#96;ifdef,else,elsif,endif,ifndef&#96;&#96;&#96;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.6.2.</span> <span class="toc-text">系统任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">输出信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">监控变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">读取文件到存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text">格式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.6.2.3.2.</span> <span class="toc-text">功能：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%A6%82%EF%BC%9A"><span class="toc-number">1.6.2.3.3.</span> <span class="toc-text">例如：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">1.6.2.3.4.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%8C%96%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">层次化事件队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#default-nettype"><span class="toc-number">1.6.4.</span> <span class="toc-text">&#96;default nettype</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/Git/" title="Git"><img src="/img/GIT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git"/></a><div class="content"><a class="title" href="/2024/09/09/Git/" title="Git">Git</a><time datetime="2024-09-09T04:48:31.000Z" title="发表于 2024-09-09 12:48:31">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/English/" title="English"><img src="/img/English.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="English"/></a><div class="content"><a class="title" href="/2024/09/09/English/" title="English">English</a><time datetime="2024-09-09T02:04:08.000Z" title="发表于 2024-09-09 10:04:08">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/07/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="超级计算机"><img src="/img/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="超级计算机"/></a><div class="content"><a class="title" href="/2024/09/07/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="超级计算机">超级计算机</a><time datetime="2024-09-07T06:45:15.000Z" title="发表于 2024-09-07 14:45:15">2024-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/05/oopre/" title="oopre"><img src="/img/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="oopre"/></a><div class="content"><a class="title" href="/2024/09/05/oopre/" title="oopre">oopre</a><time datetime="2024-09-05T06:05:14.000Z" title="发表于 2024-09-05 14:05:14">2024-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/03/MIPS/" title="MIPS"><img src="/img/MIPS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIPS"/></a><div class="content"><a class="title" href="/2024/09/03/MIPS/" title="MIPS">MIPS</a><time datetime="2024-09-03T12:51:51.000Z" title="发表于 2024-09-03 20:51:51">2024-09-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 聿尛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello, welcome to my <a target="_blank" rel="noopener" href="https://yumooo.cn">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>