<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言 | yumooo</title><meta name="author" content="聿尛"><meta name="copyright" content="聿尛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C语言一、二进制和位运算——异或的高端操作### 问题导入：  ​      袋子里一共有a个白球，b个黑球，每次从袋子里拿2个球，每个球每次被拿出的机会均等，如果拿出的是2个白球、或者2个黑球，那么就往袋子中重新放入一个白球，如果拿出的是1个白球和1个黑球，那么就往袋子中重新放入1个黑球。那么最终袋子中一定只会有1个球，请问最终的球是黑球的概率是多少？用a和b来表达这个概率。 答案：​">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言">
<meta property="og:url" content="http://ywxy12138.github.io/2024/08/23/C%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="yumooo">
<meta property="og:description" content="C语言一、二进制和位运算——异或的高端操作### 问题导入：  ​      袋子里一共有a个白球，b个黑球，每次从袋子里拿2个球，每个球每次被拿出的机会均等，如果拿出的是2个白球、或者2个黑球，那么就往袋子中重新放入一个白球，如果拿出的是1个白球和1个黑球，那么就往袋子中重新放入1个黑球。那么最终袋子中一定只会有1个球，请问最终的球是黑球的概率是多少？用a和b来表达这个概率。 答案：​">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ywxy12138.github.io/img/C.webp">
<meta property="article:published_time" content="2024-08-23T02:32:45.000Z">
<meta property="article:modified_time" content="2024-08-23T05:37:18.543Z">
<meta property="article:author" content="聿尛">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ywxy12138.github.io/img/C.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://ywxy12138.github.io/2024/08/23/C%E8%AF%AD%E8%A8%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 聿尛","link":"链接: ","source":"来源: yumooo","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-08-23 13:37:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/self/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E8%8A%B1%E9%AC%98.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/C.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="yumooo"><span class="site-name">yumooo</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-23T02:32:45.000Z" title="发表于 2024-08-23 10:32:45">2024-08-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-23T05:37:18.543Z" title="更新于 2024-08-23 13:37:18">2024-08-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="一、二进制和位运算——异或的高端操作"><a href="#一、二进制和位运算——异或的高端操作" class="headerlink" title="一、二进制和位运算——异或的高端操作"></a>一、二进制和位运算——异或的高端操作</h2><pre><code>### 问题导入：
</code></pre>
<p>​      <strong>袋子里一共有a个白球，b个黑球，每次从袋子里拿2个球，每个球每次被拿出的机会均等，如果拿出的是2个白球、或者2个黑球，那么就往袋子中重新放入一个白球，如果拿出的是1个白球和1个黑球，那么就往袋子中重新放入1个黑球。那么最终袋子中一定只会有1个球，请问最终的球是黑球的概率是多少？用a和b来表达这个概率。</strong></p>
<h3 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h3><p>​       &#x3D;&#x3D;若原始黑球数量为偶数，则最终的球是黑球的概率为0%，若原始黑球数量为奇数，则最终的球是黑球的概率为100%。完全和白球的数量无关，通过异或运算的 性质解决。&#x3D;&#x3D;</p>
<h3 id="1-异或运算性质："><a href="#1-异或运算性质：" class="headerlink" title="1.异或运算性质："></a><strong>1.异或运算性质</strong>：</h3><p>1)异或运算就是无进位相加，即1与0异或为1，0与0、1与1异或为0例：(8位)A:<code>01101110</code>     B:<code>10011101</code>   则C&#x3D;A ^ B:<code>11110011</code>  </p>
<p>2)异或运算满足交换律、结合律,即同一批数字，无论异或顺序如何，结果都一致。  </p>
<p>3)<code>0 ^ n=n</code>,<code>n ^ n=0</code>   </p>
<p>4)整体异或和(所有数字异或的结果)如果为x,若整体其中某个部分的异或和为y,则剩下部分的异或和为x ^ y,例：c&#x3D;a ^ b,a&#x3D;c ^ b,b&#x3D;a ^ c   </p>
<p>&#x3D;&#x3D;性质4在算法中的用处较多&#x3D;&#x3D;</p>
<h3 id="2-题解："><a href="#2-题解：" class="headerlink" title="2.题解："></a><strong>2.题解：</strong></h3><p>​    将白球看作0，黑球看作1。即0与1相遇产生1，0与0、1与1相遇均产生0，即为异或运算。则问题根据异或运算的性质，问题可以转化为，a个0同b个1作异或运算的结果。因此当b为偶数时，最终异或结果为0，为白球，概率为0%；当b为奇数时，最终异或结果为1，为黑球，概率为100%。   </p>
<h3 id="3-异或运算的骚操作："><a href="#3-异或运算的骚操作：" class="headerlink" title="3.异或运算的骚操作："></a><strong>3.异或运算的骚操作</strong>：</h3><h4 id="1-交换两个数："><a href="#1-交换两个数：" class="headerlink" title="1).交换两个数："></a>1).交换两个数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//前提：a和b各有各自不同的内存空间，比如：数组中的交换，若i！=j则方法成立，否则方法不成立，得到的交换结果始终为0.</span><br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b=<span class="hljs-number">20</span>;<br>a=a^b;<br>b=a^b;<br>a=a^b;<br></code></pre></td></tr></table></figure>

<h4 id="2-不用任何判断语句和比较操作，返回两个数的最大值："><a href="#2-不用任何判断语句和比较操作，返回两个数的最大值：" class="headerlink" title="2).不用任何判断语句和比较操作，返回两个数的最大值："></a>2).不用任何判断语句和比较操作，返回两个数的最大值：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">flip</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>    <span class="hljs-keyword">return</span> n^<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-comment">//非负数返回1</span><br><span class="hljs-comment">//负数返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sign</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123; <br>    flip((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">31</span>);<br>    <span class="hljs-comment">//保证无符号右移</span><br>&#125;<span class="hljs-comment">//获取某一个数的符号位的数字</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getMax</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-comment">//c可能溢出</span><br>    <span class="hljs-type">int</span> c=a-b;<br>    <span class="hljs-comment">//a的符号</span><br>    <span class="hljs-type">int</span> signa=sign(a);<br>    <span class="hljs-comment">//b的符号</span><br>    <span class="hljs-type">int</span> signb=sign(b);<br>    <span class="hljs-comment">//c的符号</span><br>    <span class="hljs-type">int</span> signc=sign(c);<br>    <span class="hljs-comment">//判断a与b的符号是否相同</span><br>    <span class="hljs-type">int</span> is_diffab=signa^signb;<br>    <span class="hljs-type">int</span> is_sameab=flip(is_diffab);<br>    <span class="hljs-comment">//return a；只存在两种情况</span><br>    <span class="hljs-comment">//1.a、b不一样时，a为非负数，即is_diffab为1时signa同时也为1</span><br>    <span class="hljs-comment">//2.a、b一样时，c为非负数，即is_sameab为1的同时signc也为1，</span><br>    <span class="hljs-comment">//也即数字逻辑电路中的与或门的组合</span><br>    <span class="hljs-type">int</span> returna=is_diffab*signa+is_sameab*signc;<span class="hljs-comment">//返回部分中a数所占的比例</span><br>    <span class="hljs-type">int</span> returnb=flip(returna);<span class="hljs-comment">//返回部分中b数所占的比例</span><br>    <span class="hljs-keyword">return</span> a*returna+b*returnb;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-找到缺失的数字"><a href="#3-找到缺失的数字" class="headerlink" title="3).  找到缺失的数字:"></a>3).  找到缺失的数字:</h3><p> 0到10，11个数中缺一个数，求缺失的数字是多少？</p>
<p>运用异或的运算性质，&#x3D;&#x3D;总异或和去异或数组中有的数字的异或和&#x3D;&#x3D;得到的结果即为所缺的那一个数字。</p>
<h3 id="4-找出数组中唯一出现奇数次的数字"><a href="#4-找出数组中唯一出现奇数次的数字" class="headerlink" title="4).找出数组中唯一出现奇数次的数字:"></a>4).找出数组中唯一出现奇数次的数字:</h3><p>遍历整个数组的同时用一个变量ans（初始化为0）存储数组中按序异或即最终异或和，该数即为所求。运用到了&#x3D;&#x3D;异或的偶消奇留&#x3D;&#x3D;的性质。   </p>
<h3 id="5-骚操作"><a href="#5-骚操作" class="headerlink" title="5).骚操作"></a>5).骚操作</h3><h4 id="①Brian-Kernighan算法——提取出二进制状态中最右侧的1"><a href="#①Brian-Kernighan算法——提取出二进制状态中最右侧的1" class="headerlink" title="①Brian Kernighan算法——提取出二进制状态中最右侧的1"></a>①Brian Kernighan算法——提取出二进制状态中最右侧的1</h4><p><code>n&amp;(~n+1)</code>或<code>(n&amp;(-n))</code></p>
<h4 id="②数组中有2种数出现了奇数次，其他的数都只出现了偶数次，返回这2种出现了奇数次的数：a、b（a！-b，显然）"><a href="#②数组中有2种数出现了奇数次，其他的数都只出现了偶数次，返回这2种出现了奇数次的数：a、b（a！-b，显然）" class="headerlink" title="②数组中有2种数出现了奇数次，其他的数都只出现了偶数次，返回这2种出现了奇数次的数：a、b（a！&#x3D;b，显然）"></a>②数组中有2种数出现了奇数次，其他的数都只出现了偶数次，返回这2种出现了奇数次的数：a、b（a！&#x3D;b，显然）</h4><p>先用eor1将数组全部数字异或和存储得到的数即为a ^ b,根据a ^ b最右侧的1(假定为第i位)(采用Brian Kernighan算法)将数组中的数分为第i位为1和第i位为0的两个阵营，再遍历一遍数组，用eor2将第i位为1的数的异或和储存下来，则eor2为a和b中的一个数，用eor1去异或eor2则可得到另一个数。</p>
<h4 id="code："><a href="#code：" class="headerlink" title="code："></a>code：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">findoddnum</span><span class="hljs-params">(<span class="hljs-type">int</span> *nums,<span class="hljs-type">int</span> len)</span>&#123;<br>         <span class="hljs-type">int</span> eor1=<span class="hljs-number">0</span>;<br>         <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">for</span>(i;i&lt;len;i++)&#123;<br>             <span class="hljs-comment">//nums中分别有a和b有奇数个，其他数均为偶数个`</span><br>             eor1^=nums[i];<br>         &#125;<br>         <span class="hljs-comment">//提取出最右侧的1</span><br>         <span class="hljs-type">int</span> rightOne=eor1&amp;(-eor1);<br>         <span class="hljs-type">int</span> eor2=<span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&amp;rightOne==<span class="hljs-number">0</span>)&#123;<br>               eor2^=nums[i]; <br>            &#125;<br>         &#125; <br>         <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,eor2,eor1^eor2);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-找出数组中唯一的出现次数小于m的数："><a href="#6-找出数组中唯一的出现次数小于m的数：" class="headerlink" title="6).找出数组中唯一的出现次数小于m的数："></a>6).找出数组中唯一的出现次数小于m的数：</h3><p>将数组中的数以二进制表示后将每一位的数相加并用一个数组储存每一位数相加和，最终在变量ans(初始化为0)上储存数组中每一位数相加和为m的整数倍的位上置0，不为m整数倍的位上置1，即可得到最终的数。    </p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>&#x3D;&#x3D;数组一共有a<del>1</del>、a<del>2</del>、……a<del>n</del>个数（去重后的），则记a<del>i</del>只出现了l次(l&lt;m),其余的数都出现了m次，则在二进制表现下除了a<del>i</del>的其余数的1位相加得到必定为m的整数倍，由于a<del>i</del>只出现了l次，则最终二进制下所有位按位相加，a<del>i</del>出现1的位上的相加和不能整除m，会余l，因此在该位上ans置1，而相加和为0(所有数该位都为0)以及m的整数倍的位都代表a<del>i</del>在该位上为0，因此在该位上ans置0&#x3D;&#x3D;。</p>
<h4 id="code：-1"><a href="#code：-1" class="headerlink" title="code："></a>code：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">findsmallnum</span><span class="hljs-params">(<span class="hljs-type">int</span> * nums,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> len)</span>&#123;<br>            <span class="hljs-type">int</span> cnt[<span class="hljs-number">32</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-comment">//cnt[i]表示第i位上有多少个1</span><br>            <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(i;i&lt;len;i++)&#123;<br>                <span class="hljs-type">int</span> j;<br>                <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">32</span>;j++)&#123;<br>                    cnt[j]+=(nums[i]&gt;&gt;j)&amp;<span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//将nums[i]的每一位都加到cnt中</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">32</span>;i++)&#123;<br>                <span class="hljs-keyword">if</span>(cnt[i]%m!=<span class="hljs-number">0</span>)&#123;<br>                    ans|=(<span class="hljs-number">1</span>&lt;&lt;i);<br>                    <span class="hljs-comment">//不是m的整数倍的位上置1，其余位上置0</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二、位运算的骚操作"><a href="#二、位运算的骚操作" class="headerlink" title="二、位运算的骚操作"></a>二、位运算的骚操作</h2><h3 id="1-判断一个整数是否为2的幂："><a href="#1-判断一个整数是否为2的幂：" class="headerlink" title="1.判断一个整数是否为2的幂："></a>1.判断一个整数是否为2的幂：</h3><p>​    借由Brian Kernighan算法，当n与二进制数只有n最右侧的1的位置上有1的数相同时，n为2的幂，且n要大于0：<br>       #### code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_twospow</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	<span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span> &amp;&amp; (n==n&amp;(-n));<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-判断一个整数是否为3的幂（int范围内）："><a href="#2-判断一个整数是否为3的幂（int范围内）：" class="headerlink" title="2.判断一个整数是否为3的幂（int范围内）："></a>2.判断一个整数是否为3的幂（int范围内）：</h3><h4 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//如果一个数是3的幂，那么这个数一定只含有3这一个质数因子</span><br><span class="hljs-comment">//1162261467是int型范围内最大的3的幂，是3的19次幂</span><br><span class="hljs-comment">//因此1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么1162261467%n==0</span><br><span class="hljs-comment">//反之如果1162261467%n！=0，说明一定有其他的因子</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_threespow</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	<span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">1162261467</span>%n==<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-已知n为非负数，返回大于等于n的最小的2的幂："><a href="#3-已知n为非负数，返回大于等于n的最小的2的幂：" class="headerlink" title="3.已知n为非负数，返回大于等于n的最小的2的幂："></a>3.已知n为非负数，返回大于等于n的最小的2的幂：</h3><h4 id="code-1"><a href="#code-1" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">minPoweroftwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	<span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">0</span>)&#123;<br>	   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	   <span class="hljs-comment">//2的幂从0开始算起，即从1开始</span><br>	&#125;<br>    <span class="hljs-comment">//若n大于0，则核心是得到n二进制最左边的一位的左侧一位置1，其余置0的数即可</span><br>    n--;<span class="hljs-comment">//防止n刚好就是2的幂的情况</span><br>    n|=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">1</span>);<br>	n|=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">2</span>);<br>	n|=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">4</span>);<br>	n|=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">8</span>);<br>	n|=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">16</span>);<span class="hljs-comment">//将n-1的最左边的1右侧均置为1 </span><br>	<span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>;<span class="hljs-comment">//最后通过加1进位得到所求答案</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-将区间-left-right-中的数全部-的结果："><a href="#4-将区间-left-right-中的数全部-的结果：" class="headerlink" title="4.将区间[left,right]中的数全部&amp;的结果："></a>4.将区间[left,right]中的数全部&amp;的结果：</h3><h4 id="code-2"><a href="#code-2" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">AllAnd</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span>&#123;<br>	<span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>		  right-=right&amp;(-right);<br>          <span class="hljs-comment">//只要[left,right]区间上满足可使right最右位1改变该位上的1都会被&amp;成0 </span><br>	&#125;<br>	<span class="hljs-keyword">return</span> right; <br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="5-将一个数按照其二进制逆序翻转得到新的数："><a href="#5-将一个数按照其二进制逆序翻转得到新的数：" class="headerlink" title="5.将一个数按照其二进制逆序翻转得到新的数："></a>5.将一个数按照其二进制逆序翻转得到新的数：</h3><h4 id="code-3"><a href="#code-3" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	n=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(n &amp; <span class="hljs-number">0xaaaaaaaa</span>)&gt;&gt;<span class="hljs-number">1</span>) | ((n &amp; <span class="hljs-number">0x55555555</span>)&lt;&lt;<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//1对1交换次序，以8位为例：该步操作实现了：abcdefgh-&gt;badcfehg,((unsigned int)(n &amp; 0xaaaaaaaa)&gt;&gt;1)得到0a0c0e0g;((n &amp; 0x55555555)&lt;&lt;1)得到了b0d0f0h0</span><br>	n=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(n &amp; <span class="hljs-number">0xcccccccc</span>)&gt;&gt;<span class="hljs-number">2</span>) | ((n &amp; <span class="hljs-number">0x33333333</span>)&lt;&lt;<span class="hljs-number">2</span>);<br>    <span class="hljs-comment">//2对2交换次序，以8位为例：该步操作实现了：badcfehg-&gt;dcbahgfe,((unsigned int)(n &amp; 0xcccccccc)&gt;&gt;2)得到00ba00fe;((n &amp; 0x33333333)&lt;&lt;2)得到了dc00hg00</span><br>	n=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(n &amp; <span class="hljs-number">0xf0f0f0f0</span>)&gt;&gt;<span class="hljs-number">4</span>) | ((n &amp; <span class="hljs-number">0x0f0f0f0f</span>)&lt;&lt;<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//4对4交换次序，以8位为例：该步操作实现了：dcbahgfe-&gt;hgfedcba,((unsigned int)(n &amp; 0xf0f0f0f0)&gt;&gt;4)得到0000dcba;((n &amp; 0x0f0f0f0f)&lt;&lt;4)得到了hgfe0000</span><br>	n=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(n &amp; <span class="hljs-number">0xff00ff00</span>)&gt;&gt;<span class="hljs-number">8</span>) | ((n &amp; <span class="hljs-number">0x00ff00ff</span>)&lt;&lt;<span class="hljs-number">8</span>);<span class="hljs-comment">//8对8交换同理 </span><br>	n=((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">16</span>) | (n&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//16对16交换同理</span><br>	<span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-求一个数的二进制表现形式有几个1"><a href="#6-求一个数的二进制表现形式有几个1" class="headerlink" title="6.求一个数的二进制表现形式有几个1:"></a>6.求一个数的二进制表现形式有几个1:</h3><h4 id="code-4"><a href="#code-4" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">searchnumone</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	n=(n &amp; <span class="hljs-number">0x55555555</span>)+((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">1</span> &amp; <span class="hljs-number">0x55555555</span>);<br>    <span class="hljs-comment">//以8位为例：abcdefgh,(n &amp; 0x55555555)得到0b0d0f0h,((unsigned int)n&gt;&gt;1 &amp; 0x55555555)得到0a0c0e0g,二者相加得到每两位中以二进制形式表示这两位中原来的1的数目，例如如果a=1,b=1,则原来ab位上为11，处理后得到10为二进制形式 </span><br>	n=(n &amp; <span class="hljs-number">0x33333333</span>)+((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">2</span> &amp; <span class="hljs-number">0x33333333</span>);<br>    <span class="hljs-comment">//以8位为例：abcdefgh,(n &amp; 0x33333333)得到00cd00gh,((unsigned int)n&gt;&gt;2 &amp; 0x33333333)得到00ab00ef,同理得到4位形式的4位中的1的数量 </span><br>	n=(n &amp; <span class="hljs-number">0x0f0f0f0f</span>)+((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">4</span> &amp; <span class="hljs-number">0x0f0f0f0f</span>);<span class="hljs-comment">//同理 </span><br>	n=(n &amp; <span class="hljs-number">0x00ff00ff</span>)+((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">8</span> &amp; <span class="hljs-number">0x00ff00ff</span>);<span class="hljs-comment">//同理 </span><br>    n=(n &amp; <span class="hljs-number">0x0000ffff</span>)+((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)n&gt;&gt;<span class="hljs-number">16</span> &amp; <span class="hljs-number">0x0000ffff</span>);<span class="hljs-comment">//同理，最终得到32位计算形式的1的数量 </span><br>	<span class="hljs-keyword">return</span> n; <br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="三、位运算——位图"><a href="#三、位运算——位图" class="headerlink" title="三、位运算——位图"></a>三、位运算——位图</h2><pre><code>### 原理：
</code></pre>
<p>用bit组成的数组来存放值，用bit状态1、0代表存在、不存在，取值和存值操作都用位运算。限制是&#x3D;&#x3D;必须为连续范围且不能过大&#x3D;&#x3D;，好处是&#x3D;&#x3D;极大的节省空间&#x3D;&#x3D;，因为1个数字只占用1个bit的空间。</p>
<h3 id="位图的实现："><a href="#位图的实现：" class="headerlink" title="位图的实现："></a>位图的实现：</h3><p>Bitset(int n):初始化位图的大小，只支持0~n-1所有数字的增删查改   </p>
<p>void add(int num):将num加入到位图中     </p>
<p>void remove(int num):将num从位图中删除   </p>
<p>void reverse(int num):如果位图里没有num，就加入：如果有就删除   </p>
<p>int contains(int num):查询num是否在位图中</p>
<h3 id="code-5"><a href="#code-5" class="headerlink" title="code:"></a>code:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//位图，利用1个整型数字的二进制位的0、1状态表示每32个数字是否在数组中，有点变相物理索引的感觉</span><br><span class="hljs-type">int</span> *arr=<span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span> ones;<span class="hljs-comment">//位图中所有1的个数</span><br><span class="hljs-type">int</span> zeros;<span class="hljs-comment">//位图中所有0的个数 </span><br><span class="hljs-type">int</span> size;<span class="hljs-comment">//位图大小 </span><br><span class="hljs-type">bool</span> is_reverse;<span class="hljs-comment">//通过is_reverse变量控制是否翻转，当第一次翻转后，1表示不存在，而0表示存在 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Bitset</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br> 	 arr=(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*((n+<span class="hljs-number">31</span>)/<span class="hljs-number">32</span>));<br> 	 <span class="hljs-type">int</span> i;<br>     <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;((n+<span class="hljs-number">31</span>)/<span class="hljs-number">32</span>);i++)&#123;<br> 		 arr[i]=<span class="hljs-number">0</span>;<br>	 &#125;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br> 	 arr[n/<span class="hljs-number">32</span>] |=<span class="hljs-number">1</span>&lt;&lt;(n%<span class="hljs-number">32</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">remove0</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	 arr[n/<span class="hljs-number">32</span>] &amp;=~(<span class="hljs-number">1</span>&lt;&lt;(n%<span class="hljs-number">32</span>));<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	 arr[n/<span class="hljs-number">32</span>] ^=<span class="hljs-number">1</span>&lt;&lt;(n%<span class="hljs-number">32</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>	<span class="hljs-keyword">return</span> ((((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)arr[n/<span class="hljs-number">32</span>])&gt;&gt;(n%<span class="hljs-number">32</span>))&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">fix</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>     <span class="hljs-type">int</span> index=i/<span class="hljs-number">32</span>;<br>     <span class="hljs-type">int</span> rebit=i%<span class="hljs-number">32</span>;<br>     <span class="hljs-keyword">if</span>(!is_reverse)&#123;<br>    	<span class="hljs-comment">//位图所有位维持原始含义</span><br>		<span class="hljs-comment">//即0表示不存在，1表示存在</span><br>    	<span class="hljs-keyword">if</span>((arr[index] &amp; (<span class="hljs-number">1</span>&lt;&lt;rebit))==<span class="hljs-number">0</span>)&#123;<br>    		zeros--;<br>    		ones++;<br>    	    arr[index] |=(<span class="hljs-number">1</span>&lt;&lt;rebit);<br>		&#125;<br>		<span class="hljs-keyword">else</span>&#123;<br>			 <span class="hljs-keyword">if</span>((arr[index] &amp; (<span class="hljs-number">1</span>&lt;&lt;rebit))!=<span class="hljs-number">0</span>)&#123;<br>				 zeros--;<br>				 ones++;<br>				 arr[index] ^=(<span class="hljs-number">1</span>&lt;&lt;rebit);<br>			  &#125;<br>		     &#125;<br>	  &#125;<br>	  <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">unfix</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>	<span class="hljs-type">int</span> index=i/<span class="hljs-number">32</span>;<br>	<span class="hljs-type">int</span> rebit=i%<span class="hljs-number">32</span>;<br>	<span class="hljs-keyword">if</span>(!is_reverse)&#123;<br>		<span class="hljs-keyword">if</span>((arr[index] &amp; (<span class="hljs-number">1</span>&lt;&lt;rebit))!=<span class="hljs-number">0</span>)&#123;<br>			ones--;<br>			zeros++;<br>			arr[index] ^=(<span class="hljs-number">1</span>&lt;&lt;rebit);<br>		&#125;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">if</span>((arr[index] &amp; (<span class="hljs-number">1</span>&lt;&lt;rebit))==<span class="hljs-number">0</span>)&#123;<br>			ones--;<br>			zeros++;<br>			arr[index] |=(<span class="hljs-number">1</span>&lt;&lt;rebit);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">flip</span><span class="hljs-params">()</span>&#123;<br>     is_reverse=!is_reverse;<br>     ones=ones^zeros;<br>     zeros=ones^zeros;<br>     ones=ones^zeros;<br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">isAllone</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> ones==size;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">isleastone</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> (ones&gt;=<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> ones;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="四、位运算——实现加减乘除："><a href="#四、位运算——实现加减乘除：" class="headerlink" title="四、位运算——实现加减乘除："></a>四、位运算——实现加减乘除：</h2><pre><code>### 加法：
</code></pre>
<p>利用每一步无进位相加即异或运算的结果 + 进位的结果（先作与运算再左移一位，即得到进位信息）不停计算，递归直到进位消失</p>
<h4 id="code-6"><a href="#code-6" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">oriadd</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>	<span class="hljs-type">int</span> ans=x;<br>	<span class="hljs-keyword">while</span>(y!=<span class="hljs-number">0</span>)&#123;<br>		ans=x^y;<br>		y=(x&amp;y)&lt;&lt;<span class="hljs-number">1</span>;<br>		x=ans;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<span class="hljs-comment">//非递归版本 </span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="减法："><a href="#减法：" class="headerlink" title="减法："></a>减法：</h3><h4 id="code：-2"><a href="#code：-2" class="headerlink" title="code："></a>code：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">neg</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//返回n的相反数 </span><br>	<span class="hljs-keyword">return</span> oriadd(~n,<span class="hljs-number">1</span>);<br>&#125; <br><span class="hljs-type">int</span> <span class="hljs-title function_">orisub</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<span class="hljs-comment">//x-y&lt;==&gt;x+(-y),-y:~y+1&lt;==&gt;oriadd(~y,1)</span><br>	<span class="hljs-keyword">return</span> oriadd(x,neg(y));<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="乘法："><a href="#乘法：" class="headerlink" title="乘法："></a>乘法：</h3><p>类似于小学的乘法过程<br>        #### code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">orimul</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(y!=<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(y&amp;<span class="hljs-number">1</span>!=<span class="hljs-number">0</span>)&#123;<br>			ans=oriadd(ans,x);<br>		&#125;<br>		y=(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)y&gt;&gt;<span class="hljs-number">1</span>;<br>		x&lt;&lt;=<span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="除法："><a href="#除法：" class="headerlink" title="除法："></a>除法：</h3><p>通过一位一位判断x是否含有y乘以2的i次方，来一位一位给ans置1，进而得到答案</p>
<h4 id="code-7"><a href="#code-7" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//需保证x和y都不是整数最小值即近似负无穷 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">oridiv</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span>&#123;<span class="hljs-comment">//x/y,允许x和y为负数 </span><br>	<span class="hljs-type">int</span> signx=(x&lt;<span class="hljs-number">0</span>) ? neg(x):x;<br>	<span class="hljs-type">int</span> signy=(y&lt;<span class="hljs-number">0</span>) ? neg(y):y; <br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-comment">//为了规避溢出风险，y左移i位同x的比较，可以转化为x右移i位同y比较，这样做不存在溢出问题 </span><br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">30</span>;i&gt;=<span class="hljs-number">0</span>;i=orisub(i,<span class="hljs-number">1</span>))&#123;<br>		<span class="hljs-keyword">if</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)signx&gt;&gt;i&gt;=signy)&#123;<br>			signx=orisub(signx,(signy&lt;&lt;i));<br>			ans|=<span class="hljs-number">1</span>&lt;&lt;i;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> (x&gt;<span class="hljs-number">0</span>)^(y&gt;<span class="hljs-number">0</span>) ? neg(ans):ans;<span class="hljs-comment">//ans表示x整除y的结果 </span><br>&#125; <br></code></pre></td></tr></table></figure>

<pre><code>        ``&#125;``  
 4.最大频率栈：
    栈的压入同一般栈相同，弹出时弹出离栈顶最近，且在栈中频率最大的值。次频表统计值在栈中一共出现的次数并且用一个栈数组来分层存储进入栈的值，加入进来的值存在栈数组中该值压入前在栈中的次数的位置，弹出时弹出最大出现次数的栈顶即可。
    code：
        `#define Maxsize 3240`
        `typedef struct node&#123;`
            `int data;`
            `struct node * pNext;`
        `&#125;NODE,*PNODE;`
        `typedef struct stack&#123;`
            `PNODE pTop;`
            `PNODE pBottom;`
        `&#125;STACK,*PSTACK;`
        `int maxnum=0;`
        `STACK array[Maxsize];//栈数组，用来实现按频率存储以及按频率弹出` 
        `int foo[Maxsize];//次频表，出现频率，frequency of occurrence` 
        `void initStack(PSTACK);`
        `void push(PSTACK,int);`
        `int pop();`
        `void initStack(PSTACK pS)&#123;`
            `pS-&gt;pTop=(PNODE)malloc(sizeof(NODE));`
            `pS-&gt;pBottom=pS-&gt;pTop;`
            `return ;`
        `&#125;`
        `void push(PSTACK pS,int val)&#123;`
            `PNODE pNew=(PNODE)malloc(sizeof(NODE));`
            `pNew-&gt;data=val;`
            `pNew-&gt;pNext=pS-&gt;pTop;`
            `pS-&gt;pTop=pNew;`
            `return ;`
        `&#125;`
        `int pop()&#123;`
            `if(array[maxnum].pBottom==array[maxnum].pTop)&#123;`
                `if(maxnum&gt;0)&#123;`
                    `maxnum--;`
                    `int hold=array[maxnum].pTop-&gt;data;`
                    `PNODE del=array[maxnum].pTop;`
                    `array[maxnum].pTop=del-&gt;pNext;`
                    `free(del);`
                    `return hold;`
                `&#125;`
                `else&#123;`
                    `return -1;`
                `&#125;`
            `&#125;`
            `else&#123;`
                    `int hold=array[maxnum].pTop-&gt;data;`
                    `PNODE del=array[maxnum].pTop;`
                    `array[maxnum].pTop=del-&gt;pNext;`
                    `free(del);`
                    `return hold;`
                `&#125;` 
        `&#125;` 
</code></pre>
<h2 id="五、链表高频问题："><a href="#五、链表高频问题：" class="headerlink" title="五、链表高频问题："></a>五、链表高频问题：</h2><p>&#x2F;&#x2F;用到的链表的结构体定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>	<span class="hljs-type">int</span> data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">pNext</span>;</span><br>&#125;NODE,*PNODE;<br></code></pre></td></tr></table></figure>

<h3 id="1-返回两个无环链表相交的第一个节点，若不相交则返回null"><a href="#1-返回两个无环链表相交的第一个节点，若不相交则返回null" class="headerlink" title="1.返回两个无环链表相交的第一个节点，若不相交则返回null"></a>1.返回两个无环链表相交的第一个节点，若不相交则返回null</h3><p>判断两个链表h1、h2(头结点)的走到尾结点e1、e2是否相等，相等即返回返回第一个相交的结点(利用长链表减去两链表长度差值，再同步移动h1、h2，判断h1与h2是否相同，第一个相同的即为第一个相交的节点)，不相等返回null。<br>           #### code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c">PNODE <span class="hljs-title function_">getIntersec</span><span class="hljs-params">(PNODE h1,PNODE h2)</span>&#123;<span class="hljs-comment">//h1、h2两个头结点 </span><br>	<span class="hljs-keyword">if</span>(h1==<span class="hljs-literal">NULL</span> || h2==<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	PNODE p=h1;<br>	PNODE q=h2;<br>	PNODE e1,e2;<br>	<span class="hljs-type">int</span> len1=<span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> len2=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>		e1=p;<br>		p=p-&gt;pNext;<br>		len1++;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(q!=<span class="hljs-literal">NULL</span>)&#123;<br>		e2=q;<br>		q=q-&gt;pNext;<br>		len2++;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(e1!=e2)&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">while</span>(len1&gt;len2)&#123;<br>			h1=h1-&gt;pNext;<br>			len1--;<br>		&#125; <br>		<span class="hljs-keyword">while</span>(len2&gt;len1)&#123;<br>			h2=h2-&gt;pNext;<br>			len2--;<br>		&#125;<br>		<span class="hljs-keyword">while</span>(h1!=h2)&#123;<br>			h1=h1-&gt;pNext;<br>			h2=h2-&gt;pNext;<br>		&#125;<br>		<span class="hljs-keyword">return</span> h1;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<pre><code> ### 2.从链表头结点每k个一组翻转链表：

        #### code:
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从当前的p结点往下数k个找到当前组的结束结点并返回 </span><br>PNODE <span class="hljs-title function_">getEnd</span><span class="hljs-params">(PNODE pS,<span class="hljs-type">int</span> k)</span>&#123;<br>	PNODE p=pS; <br>	<span class="hljs-keyword">while</span>(p-&gt;pNext!=<span class="hljs-literal">NULL</span> &amp;&amp; --k!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//先判断结点的next域是否为NULL，若为NULL则不进循环直接退出NULL前的一个结点便于后续r1或者r2的寻找；反之，若不为NULL则先--k,得到判断k-1后与0的关系，k为1时仍为该指针--k==0，跳出循环成立 </span><br>		p=p-&gt;pNext;<br>	&#125;<br>	<span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(PNODE p,PNODE q)</span>&#123;<br>	PNODE pre=<span class="hljs-literal">NULL</span>;<br>	PNODE next=<span class="hljs-literal">NULL</span>;<br>	PNODE cur=p;<br>	PNODE nexth=q-&gt;pNext; <br>	<span class="hljs-keyword">while</span>(cur!=nexth)&#123;<br>		next=cur-&gt;pNext;<span class="hljs-comment">//next指针始终指向当前讨论结点的下一个结点，便于cur结点的转移 </span><br>		cur-&gt;pNext=pre;<span class="hljs-comment">//把cur结点的指针域翻转 </span><br>		pre=cur;<span class="hljs-comment">//将cur用pre赋,这一个循环的cur结点就是下一个结点的pre </span><br>		cur=next;<span class="hljs-comment">//cur结点的转移 </span><br>	&#125;<br>	p-&gt;pNext=nexth;<span class="hljs-comment">//将这一组翻转后的尾结点同下一组的头结点连接起来 </span><br>	<span class="hljs-keyword">return</span> ; <br>&#125;<br>PNODE <span class="hljs-title function_">reverseKgroup</span><span class="hljs-params">(PNODE head,<span class="hljs-type">int</span> k)</span>&#123;<br>	PNODE start=head;<br>	PNODE end=getEnd(start,k);<br>	<span class="hljs-keyword">if</span>(end==<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">return</span> head;<br>	&#125;<span class="hljs-comment">//不足k个一组直接按原序返回 </span><br>	<span class="hljs-comment">//第一组是比较特殊的，因为涉及到了换头的问题 </span><br>	head=end;<br>	reverse(start,end);<br>	<span class="hljs-comment">//翻转后start变成了该组的尾结点 </span><br>	PNODE lastGroupEnd=start;<span class="hljs-comment">//衔接翻转后头尾颠倒的问题 </span><br>	<span class="hljs-keyword">while</span>(lastGroupEnd-&gt;pNext!=<span class="hljs-literal">NULL</span>)&#123;<br>		start=lastGroupEnd-&gt;pNext;<br>		end=getEnd(start,k);<br>		<span class="hljs-keyword">if</span>(end==<span class="hljs-literal">NULL</span>)&#123;<br>			<span class="hljs-keyword">return</span> head;<br>		&#125;<br>		reverse(start,end);<br>		lastGroupEnd-&gt;pNext=end;<br>		lastGroupEnd=start;<br>	&#125;<span class="hljs-comment">//循环多次每次k个一组 </span><br>	<span class="hljs-keyword">return</span> head; <br>&#125;<br></code></pre></td></tr></table></figure>


<pre><code>###  3.复制带有random指针的链表：
</code></pre>
<h4 id="code：-3"><a href="#code：-3" class="headerlink" title="code："></a>code：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>	<span class="hljs-type">int</span> data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">pNext</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">random</span>;</span><span class="hljs-comment">//random指针可以是指向链表中任意结点的指针，也可以为NULL </span><br>&#125;NODE,*PNODE;<span class="hljs-comment">//带随机指针的链表的结构体表达形式</span><br>PNODE <span class="hljs-title function_">initNode</span><span class="hljs-params">(PNODE p)</span>&#123;<br>	<span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)&#123;<br>		p=(PNODE)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(NODE));<br>		<span class="hljs-keyword">return</span> p;<br>	&#125;<br>	<span class="hljs-keyword">return</span> p;<br>&#125;<br>PNODE <span class="hljs-title function_">copyList</span><span class="hljs-params">(PNODE head)</span>&#123;<br>	<span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<span class="hljs-comment">//采用将复制的结点加入到对应结点的next指针上的方式创建便于random指针域复制的索引</span><br>	PNODE cur=head;<br>	PNODE next=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-comment">//将1-&gt;2-&gt;3-&gt;…变成1-&gt;1`-&gt;2-&gt;2`-&gt;3-&gt;3`-&gt;… </span><br>    <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>     next=cur-&gt;pNext;<br>	 cur-&gt;pNext=initNode(cur-&gt;pNext);<br>	 cur-&gt;pNext-&gt;pNext=next;<br>	 cur=next;	<br>	&#125;<br>	cur=head;<br>	PNODE copy=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-comment">//利用创建的新老节点之间的结构关系，设置每一个新复制的结点的random指针 </span><br>	<span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>		next=cur-&gt;pNext-&gt;pNext;<br>		copy=cur-&gt;pNext;<br>		copy-&gt;random=(cur-&gt;random==<span class="hljs-literal">NULL</span>)?<span class="hljs-literal">NULL</span>:(cur-&gt;random-&gt;pNext);<br>		cur=next;<br>	&#125;<br>	PNODE ans=head-&gt;pNext;<br>	cur=head;<br>	<span class="hljs-comment">//新老链表分离：老节点重新连在一起，新节点重新连在一起 </span><br>	<span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>		next=cur-&gt;pNext-&gt;pNext;<span class="hljs-comment">//next始终指向老链表中cur所指向节点的下一个节点 </span><br>		copy=cur-&gt;pNext;<span class="hljs-comment">//copy指针为新链表中cur对应的复制节点 </span><br>		cur-&gt;pNext=next;<br>		copy-&gt;pNext=(cur-&gt;pNext==<span class="hljs-literal">NULL</span>)?<span class="hljs-literal">NULL</span>:(next-&gt;pNext);<br>		cur=next;<br>	&#125;<br>	<span class="hljs-comment">//返回新链表的头结点</span><br>	<span class="hljs-keyword">return</span> ans; <br>&#125; <br></code></pre></td></tr></table></figure>


<pre><code> ### 4.判断链表是否为回文结构：

       #### 技巧：
</code></pre>
<p>快慢指针求中点：慢指针和快指针一开始都指向头结点，慢指针一次跳一个，快指针一次跳两个，当快指针的next域为NULL或快指针为空时停止，此时慢指针指在近似中点的节点位置<br>          ####  code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_Palidrome</span><span class="hljs-params">(PNODE head)</span>&#123;<br>	<span class="hljs-comment">//特判head为空和链表只有一个节点的情况，此时一定为回文结构 </span><br>	<span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span> || head-&gt;pNext==<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//1代表是回文结构 </span><br>	&#125;<br>	PNODE slow=head;<br>	PNODE fast=head;<br>	<span class="hljs-comment">//利用快慢指针的方法寻找链表的类似中点</span><br>	<span class="hljs-keyword">while</span>(fast-&gt;pNext!=<span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;pNext-&gt;pNext!=<span class="hljs-literal">NULL</span>)&#123;<br>		slow=slow-&gt;pNext;<br>		fast=fast-&gt;pNext-&gt;pNext;<br>	&#125;<br>	<span class="hljs-comment">//现在slow为链表的类似中点，从中点开始往后的结点开始逆序</span><br>	PNODE pre=slow;<br>	PNODE cur=pre-&gt;pNext;<br>	PNODE next=<span class="hljs-literal">NULL</span>;<br>	pre-&gt;pNext=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>		next=cur-&gt;pNext;<br>		cur-&gt;pNext=pre;<br>		pre=cur;<br>		cur=next;<br>	&#125; <br>	<span class="hljs-comment">//上述过程已完成了链表左右侧均向中间指</span><br>	<span class="hljs-comment">//head……slow……pre </span><br>	PNODE left=head;<br>	PNODE right=pre;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(left!=<span class="hljs-literal">NULL</span> &amp;&amp; right!=<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">if</span>(left-&gt;data!=right-&gt;data)&#123;<br>			ans=<span class="hljs-number">0</span>;<span class="hljs-comment">//0代表不是回文结构 </span><br>            <span class="hljs-keyword">break</span>;		<br> 		&#125;<br>		left=left-&gt;pNext;<br>		right=right-&gt;pNext;<br>	&#125;<br>	<span class="hljs-comment">//将原链表调整辉原来的样子 </span><br>	cur=pre-&gt;pNext;<br>	pre-&gt;pNext=<span class="hljs-literal">NULL</span>;<br>	next=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>		next=cur-&gt;pNext;<br>		cur-&gt;pNext=pre;<br>		pre=cur;<br>		cur=next;<br>	&#125; <br>	<span class="hljs-keyword">return</span> ans; <br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="5-找链表的第一个入环节点，如果不存在环结构，就返回NULL："><a href="#5-找链表的第一个入环节点，如果不存在环结构，就返回NULL：" class="headerlink" title="5.找链表的第一个入环节点，如果不存在环结构，就返回NULL："></a>5.找链表的第一个入环节点，如果不存在环结构，就返回NULL：</h3><h4 id="code-8"><a href="#code-8" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//仍采用快慢指针的方法，如果快指针的next域或者快指针的next域的next域为空，则返回NULL即无环结构；否则，当快慢指针相遇时，将快指针拨回链表头结点，快慢指针一起一步一步移动，再次相遇即为对应第一个入环的节点。（数学证明）</span><br>PNODE <span class="hljs-title function_">getEntercirnode</span><span class="hljs-params">(PNODE head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span> || head-&gt;pNext==<span class="hljs-literal">NULL</span> || head-&gt;pNext-&gt;pNext==<span class="hljs-literal">NULL</span>)&#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	PNODE slow=head;<br>	PNODE fast=head;<br>	<span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>		<span class="hljs-keyword">if</span>(fast-&gt;pNext==<span class="hljs-literal">NULL</span> || fast-&gt;pNext-&gt;pNext==<span class="hljs-literal">NULL</span>)&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>		&#125;<br>		slow=slow-&gt;pNext;<br>		fast=fast-&gt;pNext-&gt;pNext;<br>	&#125;<br>	fast=head;<br>	<span class="hljs-keyword">while</span>(slow!=fast)&#123;<br>		slow=slow-&gt;pNext;<br>		fast=fast-&gt;pNext;<br>	&#125;<br>	<span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-在链表上排序。要求时间复杂度O-n-logn-额外空间复杂度O-1-还要求排序有稳定性，（在数组层面上不能实现）"><a href="#6-在链表上排序。要求时间复杂度O-n-logn-额外空间复杂度O-1-还要求排序有稳定性，（在数组层面上不能实现）" class="headerlink" title="6.在链表上排序。要求时间复杂度O(n*logn),额外空间复杂度O(1),还要求排序有稳定性，（在数组层面上不能实现）"></a>6.在链表上排序。要求时间复杂度O(n*logn),额外空间复杂度O(1),还要求排序有稳定性，（在数组层面上不能实现）</h3><h4 id="code-9"><a href="#code-9" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从当前的p结点往下数k个找到当前组的结束结点并返回 </span><br>PNODE <span class="hljs-title function_">getEnd</span><span class="hljs-params">(PNODE pS,<span class="hljs-type">int</span> k)</span>&#123;<br>	PNODE p=pS; <br>	<span class="hljs-keyword">while</span>(p-&gt;pNext!=<span class="hljs-literal">NULL</span> &amp;&amp; --k!=<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//先判断结点的next域是否为NULL，若为NULL则不进循环直接退出NULL前的一个结点便于后续r1或者r2的寻找；反之，若不为NULL则先--k,得到判断k-1后与0的关系，k为1时仍为该指针--k==0，跳出循环成立 </span><br>		p=p-&gt;pNext;<br>	&#125;<br>	<span class="hljs-keyword">return</span> p;<br>&#125;<br>PNODE start;<span class="hljs-comment">//每组排序后的头结点 </span><br>PNODE end;<span class="hljs-comment">//每组排序后的尾结点 </span><br><span class="hljs-comment">//l1……r1-&gt;NULL:有序的左部分</span><br><span class="hljs-comment">//l2……r2-&gt;NULL:有序的右部分 </span><br><span class="hljs-comment">//整体merge在一起，并且保证有序</span><br><span class="hljs-comment">//将全局变量start设置为整体的头结点，全局变量end设置为整体的尾结点 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(PNODE l1,PNODE r1,PNODE l2,PNODE r2)</span>&#123;<br>	PNODE pre=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-comment">//第一次比较同样特别处理，要将start指到整体的最小值节点上去 </span><br>	<span class="hljs-keyword">if</span>(l1-&gt;data&lt;=l2-&gt;data)&#123;<br>		start=l1;<br>		pre=l1;<br>		l1=l1-&gt;pNext;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		start=l2;<br>		pre=l2;<br>		l2=l2-&gt;pNext;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">NULL</span> &amp;&amp; l2!=<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">if</span>(l1-&gt;data&lt;=l2-&gt;data)&#123;<br>			pre-&gt;pNext=l1;<br>			pre=l1;<br>			l1=l1-&gt;pNext;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>            pre-&gt;pNext=l2;<br>			pre=l2;<br>			l2=l2-&gt;pNext;		<br>		&#125; <br>	&#125;<br>	<span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">NULL</span>)&#123;<br>		pre-&gt;pNext=l1;<br>		end=r1;<br>	&#125;<span class="hljs-comment">//左部分更长，直接将已经排好序的接在末尾即可，并且是以r1作为尾结点end的 </span><br>	<span class="hljs-keyword">else</span>&#123;<br>		pre-&gt;pNext=l2;<br>		end=r2;<br>	&#125;<span class="hljs-comment">//右部分更长，直接将已经排好序的接在末尾即可，并且是以r2作为尾结点end的</span><br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">//为了使额外空间复杂度为O(1),不能使用递归，因为mergeSort递归需要O(logn)的额外空间 </span><br>PNODE <span class="hljs-title function_">perfectSort</span><span class="hljs-params">(PNODE head)</span>&#123;<br>	<span class="hljs-type">int</span> len=<span class="hljs-number">0</span>;<span class="hljs-comment">//获得链表长度 </span><br>	PNODE cur=head;<br>	<span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)&#123;<br>		len++;<br>		cur=cur-&gt;pNext;<br>	&#125;<br>	<span class="hljs-comment">//l1……r1 每组的左部分</span><br>	<span class="hljs-comment">//l2……r2 每组的右部分</span><br>	<span class="hljs-comment">//next 下一组的头结点</span><br>	<span class="hljs-comment">//lastGroupEnd 上一组的尾结点</span><br>	PNODE l1,r1,l2,r2,next,lastGroupEnd;<br>	<span class="hljs-type">int</span> step=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(step;step&lt;len;step&lt;&lt;=<span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-comment">//第一组很特殊，因为要决定整个链表的头结点，所以要单独处理</span><br>		l1=head;<br>		r1=getEnd(l1,step);<br>		l2=r1-&gt;pNext;<br>		r2=getEnd(l2,step);<br>		next=r2-&gt;pNext;<br>		r1-&gt;pNext=<span class="hljs-literal">NULL</span>;<br>		r2-&gt;pNext=<span class="hljs-literal">NULL</span>;<br>		merge(l1,r1,l2,r2);<br>		head=start;<br>		lastGroupEnd=end;<br>		<span class="hljs-keyword">while</span>(next!=<span class="hljs-literal">NULL</span>)&#123;<br>			l1=next;<br>			r1=getEnd(l1,step);<br>			l2=r1-&gt;pNext;<br>			<span class="hljs-keyword">if</span>(l2==<span class="hljs-literal">NULL</span>)&#123;<br>				lastGroupEnd-&gt;pNext=l1;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br>			r2=getEnd(l2,step);<br>			next=r2-&gt;pNext;<br>			r1-&gt;pNext=<span class="hljs-literal">NULL</span>;<br>			r2-&gt;pNext=<span class="hljs-literal">NULL</span>;<br>			merge(l1,r1,l2,r2);<br>			lastGroupEnd-&gt;pNext=start;<br>			lastGroupEnd=end;<br>		&#125; <br>	&#125;<br>	<span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="六、数据结构设计高频题："><a href="#六、数据结构设计高频题：" class="headerlink" title="六、数据结构设计高频题："></a>六、数据结构设计高频题：</h2><pre><code> ### 1.LRU缓存：
</code></pre>
<p> 最近最少使用缓存约束的数据结构   </p>
<p>使用哈希表和双向链表实现</p>
<h3 id="2-插入、删除、元素等概率随机获取时间复杂度均为O-1-的结构"><a href="#2-插入、删除、元素等概率随机获取时间复杂度均为O-1-的结构" class="headerlink" title="2.插入、删除、元素等概率随机获取时间复杂度均为O(1)的结构:"></a>2.插入、删除、元素等概率随机获取时间复杂度均为O(1)的结构:</h3><p>哈希map记录加入值和其在动态数组中的下标，随机获取时在哈希map中随机获取下标，得到相应的随机值  </p>
<p>删除操作时用最后一个数去填删除的数来保证下标的连续，保证删除之后随机获取的随机性   </p>
<p>若允许重复数字的加入，那可以采用哈希map中value采用集合的形式存储key在动态数组中一共出现过的下标，相应的remove时再删除的值同动态数组的最后一个值不同时，用动态数组中最后一个数值，来到删除位置，并在哈希mapvalue集合中进行下标的删除和插入；相同时，删除最后一个值即可。若remove后该值value集合已为空，那么应该在哈希map里删除该键值对。</p>
<h3 id="3-快速获取数据流的中位数："><a href="#3-快速获取数据流的中位数：" class="headerlink" title="3.快速获取数据流的中位数："></a>3.快速获取数据流的中位数：</h3><p>堆实现：大根堆加上小根堆，希望较小的一半都在大根堆里，而较大的一半都在小根堆里。若两个堆都为空，新来数字进大根堆。若至少一个不为空，则新来数字若小于等于大根堆的顶，其进入大根堆，反之进入小根堆。大小根堆大小差值大于等于2时，较小的一方应弹出堆顶进入另一个堆，两个堆大小之和为偶数时，中位数为两个堆堆顶数的平均数；为奇数时，中位数为大小为偶数一方的堆顶。<br>        #### code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxsize 3240</span><br><span class="hljs-type">int</span> bigHeap[Maxsize];<br><span class="hljs-type">int</span> smallHeap[Maxsize];<br><span class="hljs-type">int</span> bigSize;<br><span class="hljs-type">int</span> smallSize;<br><span class="hljs-type">double</span> midnum;<span class="hljs-comment">//数据流的中位数 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-built_in">array</span>,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span>&#123;<br>	<span class="hljs-type">int</span> temp=<span class="hljs-built_in">array</span>[i];<br>	<span class="hljs-built_in">array</span>[i]=<span class="hljs-built_in">array</span>[j];<br>	<span class="hljs-built_in">array</span>[j]=temp;<br>	<span class="hljs-keyword">return</span> ;<br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">heapInsert</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-built_in">array</span>,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> key)</span>&#123;<span class="hljs-comment">//堆的插入操作,key为1是为大根堆，key为2是为小根堆 </span><br>	<span class="hljs-keyword">if</span>(key==<span class="hljs-number">1</span>)&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">array</span>[i]&gt;<span class="hljs-built_in">array</span>[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>])&#123;<span class="hljs-comment">//直到不比父节点的值大停止向上交换 </span><br>		swap(bigHeap,i,(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);<br>		i=(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(key==<span class="hljs-number">2</span>)&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-built_in">array</span>[i]&lt;<span class="hljs-built_in">array</span>[(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>])&#123;<span class="hljs-comment">//直到不比父节点的值小停止向上交换 </span><br>		swap(smallHeap,i,(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>);<br>		i=(i<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>	&#125;<br>&#125;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">//i位置上的数发生变化后，堆的自我调整形成大顶堆或小顶堆 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">heapAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-built_in">array</span>,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> key)</span>&#123;<br>	<span class="hljs-keyword">if</span>(key==<span class="hljs-number">1</span>)&#123;<br>	<span class="hljs-type">int</span> hold=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//i结点的左孩子 </span><br>	<span class="hljs-keyword">while</span>(hold&lt;bigSize)&#123;<br>		<span class="hljs-type">int</span> bigger=(hold+<span class="hljs-number">1</span>&lt;bigSize &amp;&amp; <span class="hljs-built_in">array</span>[hold+<span class="hljs-number">1</span>]&gt;<span class="hljs-built_in">array</span>[hold])?(hold+<span class="hljs-number">1</span>):hold;<span class="hljs-comment">//右孩子存在且比左孩子大的情况下作为最大的孩子 </span><br>		bigger=<span class="hljs-built_in">array</span>[bigger]&gt;<span class="hljs-built_in">array</span>[i]?bigger:i;<br>		<span class="hljs-keyword">if</span>(bigger==i)&#123;<br>			heapInsert(bigHeap,i,<span class="hljs-number">1</span>); <br>			<span class="hljs-keyword">return</span> ;<br>		&#125;<br>	swap(bigHeap,i,bigger);<br>		i=bigger;<br>		hold=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(key==<span class="hljs-number">2</span>)&#123;<br>	<span class="hljs-type">int</span> hold=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<span class="hljs-comment">//i结点的左孩子 </span><br>	<span class="hljs-keyword">while</span>(hold&lt;smallSize)&#123;<br>		<span class="hljs-type">int</span> smaller=(hold+<span class="hljs-number">1</span>&lt;smallSize &amp;&amp; <span class="hljs-built_in">array</span>[hold+<span class="hljs-number">1</span>]&lt;<span class="hljs-built_in">array</span>[hold])?(hold+<span class="hljs-number">1</span>):hold;<span class="hljs-comment">//右孩子存在且比左孩子大的情况下作为最大的孩子 </span><br>		smaller=<span class="hljs-built_in">array</span>[smaller]&lt;<span class="hljs-built_in">array</span>[i]?smaller:i;<br>		<span class="hljs-keyword">if</span>(smaller==i)&#123;<br>			heapInsert(smallHeap,i,<span class="hljs-number">2</span>); <br>			<span class="hljs-keyword">return</span> ;<br>		&#125;<br>	swap(smallHeap,i,smaller);<br>		i=smaller;<br>		hold=i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>	&#125;<br>&#125;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-built_in">array</span>,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> key)</span>&#123;<br>    <span class="hljs-type">int</span> hold=<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>];<br>	swap(<span class="hljs-built_in">array</span>,<span class="hljs-number">0</span>,size<span class="hljs-number">-1</span>);<br>	size--;<br>	heapAdjust(<span class="hljs-built_in">array</span>,<span class="hljs-number">0</span>,key);<br>	<span class="hljs-keyword">return</span> hold;	<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> n;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> x; <br>	<span class="hljs-keyword">for</span>(i;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>		<span class="hljs-keyword">if</span>(bigSize==<span class="hljs-number">0</span> &amp;&amp; smallSize==<span class="hljs-number">0</span>)&#123;<br>			bigHeap[bigSize]=x;<br>			heapInsert(bigHeap,bigSize++,<span class="hljs-number">1</span>);<br>			midnum=x;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			<span class="hljs-keyword">if</span>(x&lt;=bigHeap[<span class="hljs-number">0</span>])&#123;<br>				bigHeap[bigSize]=x;<br>			heapInsert(bigHeap,bigSize++,<span class="hljs-number">1</span>);<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				smallHeap[smallSize]=x;<br>				heapInsert(smallHeap,smallSize++,<span class="hljs-number">2</span>);<br>			&#125;<br>			<span class="hljs-keyword">if</span>(bigSize-smallSize&gt;=<span class="hljs-number">2</span>)&#123;<br>				<span class="hljs-type">int</span> temp=pop(bigHeap,bigSize,<span class="hljs-number">1</span>);<br>				smallHeap[smallSize]=temp;<br>				heapInsert(smallHeap,smallSize++,<span class="hljs-number">2</span>);<br>			&#125;<br>			<span class="hljs-keyword">if</span>(smallSize-bigSize&gt;=<span class="hljs-number">2</span>)&#123;<br>				<span class="hljs-type">int</span> tempp=pop(smallHeap,smallSize,<span class="hljs-number">2</span>);<br>					bigHeap[bigSize]=tempp;<br>			heapInsert(bigHeap,bigSize++,<span class="hljs-number">1</span>);<br>			&#125;<br>			<span class="hljs-keyword">if</span>((bigSize+smallSize)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>				midnum=(<span class="hljs-type">double</span>)(bigHeap[<span class="hljs-number">0</span>]+smallHeap[<span class="hljs-number">0</span>])/<span class="hljs-number">2</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span>&#123;<br>				midnum=(bigSize&gt;smallSize)?bigHeap[<span class="hljs-number">0</span>]:smallHeap[<span class="hljs-number">0</span>];<br>			&#125;<br>		&#125;<br>		<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf &quot;</span>,midnum);<br>	&#125; <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br></code></pre></td></tr></table></figure>

<h3 id="4-最大频率栈："><a href="#4-最大频率栈：" class="headerlink" title="4.最大频率栈："></a>4.最大频率栈：</h3><p>栈的压入同一般栈相同，弹出时弹出离栈顶最近，且在栈中频率最大的值。次频表统计值在栈中一共出现的次数并且用一个栈数组来分层存储进入栈的值，加入进来的值存在栈数组中该值压入前在栈中的次数的位置，弹出时弹出最大出现次数的栈顶即可。</p>
<h4 id="code-10"><a href="#code-10" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxsize 3240</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span>&#123;</span><br>	<span class="hljs-type">int</span> data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> * <span class="hljs-title">pNext</span>;</span><br>&#125;NODE,*PNODE;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stack</span>&#123;</span><br>	PNODE pTop;<br>	PNODE pBottom;<br>&#125;STACK,*PSTACK;<br><span class="hljs-type">int</span> maxnum=<span class="hljs-number">0</span>;<br>STACK <span class="hljs-built_in">array</span>[Maxsize];<span class="hljs-comment">//栈数组，用来实现按频率存储以及按频率弹出 </span><br><span class="hljs-type">int</span> foo[Maxsize];<span class="hljs-comment">//次频表，出现频率 </span><br><span class="hljs-type">void</span> <span class="hljs-title function_">initStack</span><span class="hljs-params">(PSTACK)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(PSTACK,<span class="hljs-type">int</span>)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">initStack</span><span class="hljs-params">(PSTACK pS)</span>&#123;<br>	pS-&gt;pTop=(PNODE)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(NODE));<br>	pS-&gt;pBottom=pS-&gt;pTop;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(PSTACK pS,<span class="hljs-type">int</span> val)</span>&#123;<br>	PNODE pNew=(PNODE)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(NODE));<br>	pNew-&gt;data=val;<br>	pNew-&gt;pNext=pS-&gt;pTop;<br>	pS-&gt;pTop=pNew;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">array</span>[maxnum].pBottom==<span class="hljs-built_in">array</span>[maxnum].pTop)&#123;<br>		<span class="hljs-keyword">if</span>(maxnum&gt;<span class="hljs-number">0</span>)&#123;<br>		maxnum--;<br>		<span class="hljs-type">int</span> hold=<span class="hljs-built_in">array</span>[maxnum].pTop-&gt;data;<br>		PNODE del=<span class="hljs-built_in">array</span>[maxnum].pTop;<br>		<span class="hljs-built_in">array</span>[maxnum].pTop=del-&gt;pNext;<br>		<span class="hljs-built_in">free</span>(del);<br>		<span class="hljs-keyword">return</span> hold;<br>	&#125;<br>	<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>	&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-type">int</span> hold=<span class="hljs-built_in">array</span>[maxnum].pTop-&gt;data;<br>		PNODE del=<span class="hljs-built_in">array</span>[maxnum].pTop;<br>		<span class="hljs-built_in">array</span>[maxnum].pTop=del-&gt;pNext;<br>		<span class="hljs-built_in">free</span>(del);<br>		<span class="hljs-keyword">return</span> hold;<br>	&#125; <br>&#125; <br>      <br></code></pre></td></tr></table></figure>

<h2 id="七、二叉树高频题："><a href="#七、二叉树高频题：" class="headerlink" title="七、二叉树高频题："></a>七、二叉树高频题：</h2><h3 id="1-bfs的两种实现方式："><a href="#1-bfs的两种实现方式：" class="headerlink" title="1.bfs的两种实现方式："></a>1.bfs的两种实现方式：</h3><h4 id="①队列加哈希表（表记录弹出结点的层数），根据哈希表中的数值与对应层数的关系在链表数组中进行处理。"><a href="#①队列加哈希表（表记录弹出结点的层数），根据哈希表中的数值与对应层数的关系在链表数组中进行处理。" class="headerlink" title="①队列加哈希表（表记录弹出结点的层数），根据哈希表中的数值与对应层数的关系在链表数组中进行处理。"></a>①队列加哈希表（表记录弹出结点的层数），根据哈希表中的数值与对应层数的关系在链表数组中进行处理。</h4><h4 id="②一次处理一层的方式："><a href="#②一次处理一层的方式：" class="headerlink" title="②一次处理一层的方式："></a>②一次处理一层的方式：</h4><h5 id="1-拿当前队列的长度size"><a href="#1-拿当前队列的长度size" class="headerlink" title="1)拿当前队列的长度size"></a>1)拿当前队列的长度size</h5><h5 id="2-如下行为重复size遍："><a href="#2-如下行为重复size遍：" class="headerlink" title="2)如下行为重复size遍："></a>2)如下行为重复size遍：</h5><h6 id="（1）弹出队首结点放入其所在层的链表中。"><a href="#（1）弹出队首结点放入其所在层的链表中。" class="headerlink" title="（1）弹出队首结点放入其所在层的链表中。"></a>（1）弹出队首结点放入其所在层的链表中。</h6><h6 id="（2）有左节点加左节点-有右节点加右节点"><a href="#（2）有左节点加左节点-有右节点加右节点" class="headerlink" title="（2）有左节点加左节点;有右节点加右节点"></a>（2）有左节点加左节点;有右节点加右节点</h6><h5 id="code-11"><a href="#code-11" class="headerlink" title="code:"></a>code:</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxsize 3240</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btnode</span>&#123;</span><br>	<span class="hljs-type">int</span> data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btnode</span> *<span class="hljs-title">left</span>,*<span class="hljs-title">right</span>;</span><br>&#125;BTNODE,*PBTNODE;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>&#123;</span><br>	<span class="hljs-type">int</span> length;<br>	<span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[Maxsize];<br>&#125;LIST,*PLIST;<br><span class="hljs-type">int</span> l;<br><span class="hljs-type">int</span> r;<br><span class="hljs-type">int</span> count;<br>BTNODE <span class="hljs-built_in">queue</span>[Maxsize];<br>PLIST linkList[Maxsize];<br>PBTNODE <span class="hljs-title function_">initBTree</span><span class="hljs-params">(PBTNODE pT,<span class="hljs-type">int</span> val)</span>&#123;<br>	<span class="hljs-keyword">if</span>(pT==<span class="hljs-literal">NULL</span>)&#123;<br>		pT=(PBTNODE)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNODE));<br>		pT-&gt;data=val;<br>		pT-&gt;left=<span class="hljs-literal">NULL</span>;<br>		pT-&gt;right=<span class="hljs-literal">NULL</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">if</span>(pT-&gt;data&gt;=val)&#123;<br>			pT-&gt;left=initBTree(pT-&gt;left,val);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			pT-&gt;right=initBTree(pT-&gt;right,val);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> pT;<br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">bfs</span><span class="hljs-params">(PBTNODE pRoot)</span>&#123;<br>	<span class="hljs-keyword">if</span>(pRoot!=<span class="hljs-literal">NULL</span>)&#123;<br>		l=r=<span class="hljs-number">0</span>;<span class="hljs-comment">//用[l,r)的左闭右开区间代表队列中的结点分布情况，l代表队首，r代表队尾的下一个结点 </span><br>        <span class="hljs-built_in">queue</span>[r++]=*pRoot;<br>		count=<span class="hljs-number">1</span>;<span class="hljs-comment">//代表结点所在的层数</span><br>		<span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>			<span class="hljs-type">int</span> size=r-l;<span class="hljs-comment">//队列长度</span><br>			<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span>(i;i&lt;size;i++)&#123;<span class="hljs-comment">//重复队列长度次可以将该层的所有结点都弹出 </span><br>			<span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>)&#123;<br>				linkList[count]=(PLIST)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LIST));<br>			&#125;<br>				BTNODE hold=<span class="hljs-built_in">queue</span>[l++];<br>				<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,hold.data);<br>				linkList[count]-&gt;<span class="hljs-built_in">array</span>[i]=hold.data;<br>				<span class="hljs-keyword">if</span>(hold.left!=<span class="hljs-literal">NULL</span>)&#123;<br>					<span class="hljs-built_in">queue</span>[r++]=*hold.left;<br>				&#125;<br>				<span class="hljs-keyword">if</span>(hold.right!=<span class="hljs-literal">NULL</span>)&#123;<br>					<span class="hljs-built_in">queue</span>[r++]=*hold.right;<br>				&#125;<br>			&#125;<br>			linkList[count]-&gt;length=size;<br>			count++; <br>		&#125;		<br>	&#125;<br>	<span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>	<span class="hljs-type">int</span> n;<br>	PBTNODE PROOT=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>	<span class="hljs-type">int</span> i,x;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>		PROOT=initBTree(PROOT,x);<br>	&#125;<br>	bfs(PROOT);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>	<span class="hljs-type">int</span> j;<br>	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;count;i++)&#123;<br>		<span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;linkList[i]-&gt;length;j++)&#123;<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,linkList[i]-&gt;<span class="hljs-built_in">array</span>[j]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125; <br></code></pre></td></tr></table></figure>


<h4 id="若要求锯齿状层次遍历二叉树，即相邻的两层的遍历左右次序不同，则队列加入结点的方式同上，弹出结点的方式改为如下："><a href="#若要求锯齿状层次遍历二叉树，即相邻的两层的遍历左右次序不同，则队列加入结点的方式同上，弹出结点的方式改为如下：" class="headerlink" title="若要求锯齿状层次遍历二叉树，即相邻的两层的遍历左右次序不同，则队列加入结点的方式同上，弹出结点的方式改为如下："></a>若要求锯齿状层次遍历二叉树，即相邻的两层的遍历左右次序不同，则队列加入结点的方式同上，弹出结点的方式改为如下：</h4><pre><code> #####       code：
</code></pre>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> reverse=<span class="hljs-literal">false</span>;<br><span class="hljs-comment">//reverse == false,左-&gt;右:i+=1,l…r-1,收集size-1个</span><br><span class="hljs-comment">//reverse == true,右-&gt;左:i-=1,r-1…l,收集size-1个 </span><br><span class="hljs-type">int</span> i,j,k;<br><span class="hljs-keyword">for</span>(i=(reverse)?(r<span class="hljs-number">-1</span>):l,j=(reverse)?(<span class="hljs-number">-1</span>):<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;k&lt;size;i+=j,k++)&#123;<br>	BTNODE hold=<span class="hljs-built_in">queue</span>[i];<br>	linkList[count]-&gt;<span class="hljs-built_in">array</span>[i]=hold.data;<br>&#125;<br><span class="hljs-comment">//每一层遍历结束后将reverse翻转即</span><br>reverse=!reverse; <br></code></pre></td></tr></table></figure>

<h3 id="2-最大特殊宽度："><a href="#2-最大特殊宽度：" class="headerlink" title="2.最大特殊宽度："></a>2.最大特殊宽度：</h3><h4 id="code-12"><a href="#code-12" class="headerlink" title="code:"></a>code:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxsize 3240</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btnode</span>&#123;</span><br>	<span class="hljs-type">int</span> data;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btnode</span> *<span class="hljs-title">left</span>,*<span class="hljs-title">right</span>;</span><br>&#125;BTNODE,*PBTNODE;<br><span class="hljs-type">int</span> l;<br><span class="hljs-type">int</span> r;<br><span class="hljs-type">int</span> ans;<br>BTNODE nodeQueue[Maxsize];<br><span class="hljs-type">int</span> idQueue[Maxsize];<br>PBTNODE <span class="hljs-title function_">initBTree</span><span class="hljs-params">(PBTNODE pT,<span class="hljs-type">int</span> val)</span>&#123;<br>	<span class="hljs-keyword">if</span>(pT==<span class="hljs-literal">NULL</span>)&#123;<br>		pT=(PBTNODE)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BTNODE));<br>		pT-&gt;data=val;<br>		pT-&gt;left=<span class="hljs-literal">NULL</span>;<br>		pT-&gt;right=<span class="hljs-literal">NULL</span>;<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-keyword">if</span>(pT-&gt;data&gt;=val)&#123;<br>			pT-&gt;left=initBTree(pT-&gt;left,val);<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			pT-&gt;right=initBTree(pT-&gt;right,val);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> pT;<br>&#125; <br><span class="hljs-type">void</span> <span class="hljs-title function_">bfsOFfindbigspecialwidth</span><span class="hljs-params">(PBTNODE pT)</span>&#123;<br>	ans=<span class="hljs-number">1</span>;<br>	l=r=<span class="hljs-number">0</span>;<br>	nodeQueue[r]=*pT;<br>	idQueue[r++]=<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">while</span>(l&lt;r)&#123;<br>		<span class="hljs-type">int</span> size=r-l;<br>		ans=(ans&gt;(idQueue[r<span class="hljs-number">-1</span>]-idQueue[l]+<span class="hljs-number">1</span>))?ans:(idQueue[r<span class="hljs-number">-1</span>]-idQueue[l]+<span class="hljs-number">1</span>);<br>		<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span>(i;i&lt;size;i++)&#123;<br>			BTNODE hold=nodeQueue[l];<br>			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,hold.data);<br>			<span class="hljs-type">int</span> id=idQueue[l++];<br>			<span class="hljs-keyword">if</span>(hold.left!=<span class="hljs-literal">NULL</span>)&#123;<br>				nodeQueue[r]=*hold.left;<br>				idQueue[r++]=id*<span class="hljs-number">2</span>;<br>			&#125;<br>			<span class="hljs-keyword">if</span>(hold.right!=<span class="hljs-literal">NULL</span>)&#123;<br>				nodeQueue[r]=*hold.right;<br>				idQueue[r++]=id*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code>             ### 3.二叉树的最小高度（从头结点到所有叶节点的高度中的最小值）：
</code></pre>
<h4 id="code：-4"><a href="#code：-4" class="headerlink" title="code："></a>code：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> Maxsize 3240 <span class="hljs-comment">//以3240来代表数值范围内的最大值，以题目数据范围为准</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btnode</span>&#123;</span><br>	    <span class="hljs-type">int</span> data;<br>	    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">btnode</span> *<span class="hljs-title">left</span>,*<span class="hljs-title">right</span>;</span><br>&#125;BTNODE,*PBTNODE;<br><span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(PBTNODE pRoot)</span>&#123;<br>	<span class="hljs-keyword">if</span>(pRoot==<span class="hljs-literal">NULL</span>)&#123;<br>	<span class="hljs-comment">//当前的树为空树 </span><br>	   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pRoot-&gt;left==<span class="hljs-literal">NULL</span> &amp;&amp; pRoot-&gt;right==<span class="hljs-literal">NULL</span>)&#123;<br>	<span class="hljs-comment">//pRoot指向叶节点</span><br>	   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>	&#125;<br>	<span class="hljs-type">int</span> ldeep=Maxsize;<br>	<span class="hljs-type">int</span> rdeep=Maxsize;<br>	<span class="hljs-keyword">if</span>(pRoot-&gt;left!=<span class="hljs-literal">NULL</span>)&#123;<br>	   ldeep=minDepth(pRoot-&gt;left);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(pRoot-&gt;right!=<span class="hljs-literal">NULL</span>)&#123;<br>	   rdeep=minDepth(pRoot-&gt;right);<br>	&#125;<br>	<span class="hljs-keyword">return</span> ((ldeep&lt;=rdeep)?ldeep:rdeep)+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


<h3 id="4-二叉树的先序序列化和反序列化"><a href="#4-二叉树的先序序列化和反序列化" class="headerlink" title="4.二叉树的先序序列化和反序列化"></a>4.二叉树的先序序列化和反序列化</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://ywxy12138.github.io">聿尛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://ywxy12138.github.io/2024/08/23/C%E8%AF%AD%E8%A8%80/">http://ywxy12138.github.io/2024/08/23/C语言/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ywxy12138.github.io" target="_blank">yumooo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a></div><div class="post_share"><div class="social-share" data-image="/img/C.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2024/08/20/Linux%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="Linux终端使用指南"><img class="cover" src="/img/Linux.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux终端使用指南</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E8%8A%B1%E9%AC%98.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">聿尛</div><div class="author-info__description">孤独永恒，死亡永生。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ywxy12138"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无可奈何花落去，似曾相识燕归来！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E5%BC%82%E6%88%96%E7%9A%84%E9%AB%98%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.</span> <span class="toc-text">一、二进制和位运算——异或的高端操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">答案：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.异或运算性质：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A2%98%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.1.3.</span> <span class="toc-text">2.题解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">1.1.4.</span> <span class="toc-text">3.异或运算的骚操作：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1).交换两个数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E7%94%A8%E4%BB%BB%E4%BD%95%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%9A"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">2).不用任何判断语句和比较操作，返回两个数的最大值：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%BE%E5%88%B0%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.1.5.</span> <span class="toc-text">3).  找到缺失的数字:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E5%87%BA%E7%8E%B0%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">1.1.6.</span> <span class="toc-text">4).找出数组中唯一出现奇数次的数字:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%AA%9A%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.7.</span> <span class="toc-text">5).骚操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0Brian-Kernighan%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8F%90%E5%8F%96%E5%87%BA%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E6%80%81%E4%B8%AD%E6%9C%80%E5%8F%B3%E4%BE%A7%E7%9A%841"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">①Brian Kernighan算法——提取出二进制状态中最右侧的1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%892%E7%A7%8D%E6%95%B0%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A5%87%E6%95%B0%E6%AC%A1%EF%BC%8C%E5%85%B6%E4%BB%96%E7%9A%84%E6%95%B0%E9%83%BD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%BA%86%E5%81%B6%E6%95%B0%E6%AC%A1%EF%BC%8C%E8%BF%94%E5%9B%9E%E8%BF%992%E7%A7%8D%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A5%87%E6%95%B0%E6%AC%A1%E7%9A%84%E6%95%B0%EF%BC%9Aa%E3%80%81b%EF%BC%88a%EF%BC%81-b%EF%BC%8C%E6%98%BE%E7%84%B6%EF%BC%89"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">②数组中有2种数出现了奇数次，其他的数都只出现了偶数次，返回这2种出现了奇数次的数：a、b（a！&#x3D;b，显然）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">code：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E5%B0%8F%E4%BA%8Em%E7%9A%84%E6%95%B0%EF%BC%9A"><span class="toc-number">1.1.8.</span> <span class="toc-text">6).找出数组中唯一的出现次数小于m的数：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-1"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">code：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">二、位运算的骚操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA2%E7%9A%84%E5%B9%82%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.判断一个整数是否为2的幂：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E5%90%A6%E4%B8%BA3%E7%9A%84%E5%B9%82%EF%BC%88int%E8%8C%83%E5%9B%B4%E5%86%85%EF%BC%89%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.判断一个整数是否为3的幂（int范围内）：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B7%B2%E7%9F%A5n%E4%B8%BA%E9%9D%9E%E8%B4%9F%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8En%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%842%E7%9A%84%E5%B9%82%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.已知n为非负数，返回大于等于n的最小的2的幂：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B0%86%E5%8C%BA%E9%97%B4-left-right-%E4%B8%AD%E7%9A%84%E6%95%B0%E5%85%A8%E9%83%A8-%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.将区间[left,right]中的数全部&amp;的结果：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-2"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8C%89%E7%85%A7%E5%85%B6%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%80%86%E5%BA%8F%E7%BF%BB%E8%BD%AC%E5%BE%97%E5%88%B0%E6%96%B0%E7%9A%84%E6%95%B0%EF%BC%9A"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.将一个数按照其二进制逆序翻转得到新的数：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-3"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B1%82%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F%E6%9C%89%E5%87%A0%E4%B8%AA1"><span class="toc-number">1.2.6.</span> <span class="toc-text">6.求一个数的二进制表现形式有几个1:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-4"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">code:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E4%BD%8D%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">三、位运算——位图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">位图的实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#code-5"><span class="toc-number">1.3.2.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">四、位运算——实现加减乘除：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-6"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">减法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-2"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">code：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">乘法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">除法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-7"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">code:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">五、链表高频问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%97%A0%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%EF%BC%8C%E8%8B%A5%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%88%99%E8%BF%94%E5%9B%9Enull"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.返回两个无环链表相交的第一个节点，若不相交则返回null</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-3"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">code：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%89%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%A5%E7%8E%AF%E8%8A%82%E7%82%B9%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%8E%AF%E7%BB%93%E6%9E%84%EF%BC%8C%E5%B0%B1%E8%BF%94%E5%9B%9ENULL%EF%BC%9A"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.找链表的第一个入环节点，如果不存在环结构，就返回NULL：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-8"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%8A%E6%8E%92%E5%BA%8F%E3%80%82%E8%A6%81%E6%B1%82%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-n-logn-%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1-%E8%BF%98%E8%A6%81%E6%B1%82%E6%8E%92%E5%BA%8F%E6%9C%89%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%8C%EF%BC%88%E5%9C%A8%E6%95%B0%E7%BB%84%E5%B1%82%E9%9D%A2%E4%B8%8A%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">6.在链表上排序。要求时间复杂度O(n*logn),额外空间复杂度O(1),还要求排序有稳定性，（在数组层面上不能实现）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-9"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">code:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%AB%98%E9%A2%91%E9%A2%98%EF%BC%9A"><span class="toc-number">1.6.</span> <span class="toc-text">六、数据结构设计高频题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E5%85%83%E7%B4%A0%E7%AD%89%E6%A6%82%E7%8E%87%E9%9A%8F%E6%9C%BA%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%9D%87%E4%B8%BAO-1-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">2.插入、删除、元素等概率随机获取时间复杂度均为O(1)的结构:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BF%AB%E9%80%9F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">3.快速获取数据流的中位数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88%EF%BC%9A"><span class="toc-number">1.6.3.</span> <span class="toc-text">4.最大频率栈：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-10"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">code:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E9%AB%98%E9%A2%91%E9%A2%98%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">七、二叉树高频题：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-bfs%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.bfs的两种实现方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E9%98%9F%E5%88%97%E5%8A%A0%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88%E8%A1%A8%E8%AE%B0%E5%BD%95%E5%BC%B9%E5%87%BA%E7%BB%93%E7%82%B9%E7%9A%84%E5%B1%82%E6%95%B0%EF%BC%89%EF%BC%8C%E6%A0%B9%E6%8D%AE%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%95%B0%E5%80%BC%E4%B8%8E%E5%AF%B9%E5%BA%94%E5%B1%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9C%A8%E9%93%BE%E8%A1%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">①队列加哈希表（表记录弹出结点的层数），根据哈希表中的数值与对应层数的关系在链表数组中进行处理。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%B8%80%E6%AC%A1%E5%A4%84%E7%90%86%E4%B8%80%E5%B1%82%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">②一次处理一层的方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8B%BF%E5%BD%93%E5%89%8D%E9%98%9F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6size"><span class="toc-number">1.7.1.2.1.</span> <span class="toc-text">1)拿当前队列的长度size</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A6%82%E4%B8%8B%E8%A1%8C%E4%B8%BA%E9%87%8D%E5%A4%8Dsize%E9%81%8D%EF%BC%9A"><span class="toc-number">1.7.1.2.2.</span> <span class="toc-text">2)如下行为重复size遍：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%BC%B9%E5%87%BA%E9%98%9F%E9%A6%96%E7%BB%93%E7%82%B9%E6%94%BE%E5%85%A5%E5%85%B6%E6%89%80%E5%9C%A8%E5%B1%82%E7%9A%84%E9%93%BE%E8%A1%A8%E4%B8%AD%E3%80%82"><span class="toc-number">1.7.1.2.2.1.</span> <span class="toc-text">（1）弹出队首结点放入其所在层的链表中。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9C%89%E5%B7%A6%E8%8A%82%E7%82%B9%E5%8A%A0%E5%B7%A6%E8%8A%82%E7%82%B9-%E6%9C%89%E5%8F%B3%E8%8A%82%E7%82%B9%E5%8A%A0%E5%8F%B3%E8%8A%82%E7%82%B9"><span class="toc-number">1.7.1.2.2.2.</span> <span class="toc-text">（2）有左节点加左节点;有右节点加右节点</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#code-11"><span class="toc-number">1.7.1.2.3.</span> <span class="toc-text">code:</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8B%A5%E8%A6%81%E6%B1%82%E9%94%AF%E9%BD%BF%E7%8A%B6%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%8D%B3%E7%9B%B8%E9%82%BB%E7%9A%84%E4%B8%A4%E5%B1%82%E7%9A%84%E9%81%8D%E5%8E%86%E5%B7%A6%E5%8F%B3%E6%AC%A1%E5%BA%8F%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%88%99%E9%98%9F%E5%88%97%E5%8A%A0%E5%85%A5%E7%BB%93%E7%82%B9%E7%9A%84%E6%96%B9%E5%BC%8F%E5%90%8C%E4%B8%8A%EF%BC%8C%E5%BC%B9%E5%87%BA%E7%BB%93%E7%82%B9%E7%9A%84%E6%96%B9%E5%BC%8F%E6%94%B9%E4%B8%BA%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">若要求锯齿状层次遍历二叉树，即相邻的两层的遍历左右次序不同，则队列加入结点的方式同上，弹出结点的方式改为如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%80%E5%A4%A7%E7%89%B9%E6%AE%8A%E5%AE%BD%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.7.2.</span> <span class="toc-text">2.最大特殊宽度：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#code-12"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">code:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#code%EF%BC%9A-4"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">code：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.7.3.</span> <span class="toc-text">4.二叉树的先序序列化和反序列化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/23/C%E8%AF%AD%E8%A8%80/" title="C语言"><img src="/img/C.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言"/></a><div class="content"><a class="title" href="/2024/08/23/C%E8%AF%AD%E8%A8%80/" title="C语言">C语言</a><time datetime="2024-08-23T02:32:45.000Z" title="发表于 2024-08-23 10:32:45">2024-08-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/20/Linux%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="Linux终端使用指南"><img src="/img/Linux.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux终端使用指南"/></a><div class="content"><a class="title" href="/2024/08/20/Linux%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="Linux终端使用指南">Linux终端使用指南</a><time datetime="2024-08-20T15:28:27.000Z" title="发表于 2024-08-20 23:28:27">2024-08-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/15/%E6%95%B0%E5%88%B6/" title="数制"><img src="/img/%E6%95%B0%E5%88%B6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数制"/></a><div class="content"><a class="title" href="/2024/08/15/%E6%95%B0%E5%88%B6/" title="数制">数制</a><time datetime="2024-08-15T04:45:43.000Z" title="发表于 2024-08-15 12:45:43">2024-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/14/Python/" title="python"><img src="/img/python.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python"/></a><div class="content"><a class="title" href="/2024/08/14/Python/" title="python">python</a><time datetime="2024-08-14T10:09:00.000Z" title="发表于 2024-08-14 18:09:00">2024-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/14/logisim/" title="Logisim"><img src="/img/logisim.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Logisim"/></a><div class="content"><a class="title" href="/2024/08/14/logisim/" title="Logisim">Logisim</a><time datetime="2024-08-14T10:09:00.000Z" title="发表于 2024-08-14 18:09:00">2024-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 聿尛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello, welcome to my <a target="_blank" rel="noopener" href="https://yumooo.cn">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>