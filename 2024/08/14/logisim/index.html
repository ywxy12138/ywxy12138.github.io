<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Logisim | yumooo</title><meta name="author" content="聿尛"><meta name="copyright" content="聿尛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LogisimLogisim简介：介绍Logisim 使用图形用户接口，设计并仿真数字电路，包含基础库（基础门电路，存储器，多路选择器等简单器件） 特点: 开源(open-source)  可在任意支持 Java 5 及以上版本的机器上运行  画图接口基于直观的工具栏  电路可以存为文件，也可以 GIF 格式导出或打印输出  允许层次化的电路设计：子电路调用  包含众多内置电路器件：输入&amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="Logisim">
<meta property="og:url" content="http://ywxy12138.github.io/2024/08/14/logisim/index.html">
<meta property="og:site_name" content="yumooo">
<meta property="og:description" content="LogisimLogisim简介：介绍Logisim 使用图形用户接口，设计并仿真数字电路，包含基础库（基础门电路，存储器，多路选择器等简单器件） 特点: 开源(open-source)  可在任意支持 Java 5 及以上版本的机器上运行  画图接口基于直观的工具栏  电路可以存为文件，也可以 GIF 格式导出或打印输出  允许层次化的电路设计：子电路调用  包含众多内置电路器件：输入&amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://ywxy12138.github.io/img/logisim.png">
<meta property="article:published_time" content="2024-08-14T10:09:00.000Z">
<meta property="article:modified_time" content="2024-09-08T01:25:03.918Z">
<meta property="article:author" content="聿尛">
<meta property="article:tag" content="Logisim">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ywxy12138.github.io/img/logisim.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://ywxy12138.github.io/2024/08/14/logisim/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 聿尛","link":"链接: ","source":"来源: yumooo","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Logisim',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-09-08 09:25:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/self/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E8%8A%B1%E9%AC%98.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/logisim.png')"><nav id="nav"><span id="blog-info"><a href="/" title="yumooo"><span class="site-name">yumooo</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Logisim</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-14T10:09:00.000Z" title="发表于 2024-08-14 18:09:00">2024-08-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-08T01:25:03.918Z" title="更新于 2024-09-08 09:25:03">2024-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0/">北航计组笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Logisim"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Logisim"><a href="#Logisim" class="headerlink" title="Logisim"></a>Logisim</h1><h2 id="Logisim简介："><a href="#Logisim简介：" class="headerlink" title="Logisim简介："></a>Logisim简介：</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Logisim 使用图形用户接口，设计并仿真数字电路，包含基础库（基础门电路，存储器，多路选择器等简单器件）</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h3><ul>
<li><p>开源(open-source)</p>
</li>
<li><p>可在任意支持 Java 5 及以上版本的机器上运行</p>
</li>
<li><p>画图接口基于直观的工具栏</p>
</li>
<li><p>电路可以存为文件，也可以 GIF 格式导出或打印输出</p>
</li>
<li><p>允许层次化的电路设计：子电路调用</p>
</li>
<li><p>包含众多内置电路器件：输入&#x2F;输出，门电路，多路选择器，以及RAM存储器</p>
</li>
<li><p>内置组合逻辑分析模块，支持在电路、真值表和表达式之间转换</p>
</li>
</ul>
<h2 id="Logisim门电路"><a href="#Logisim门电路" class="headerlink" title="Logisim门电路"></a>Logisim门电路</h2><h3 id="工具布局"><a href="#工具布局" class="headerlink" title="工具布局"></a>工具布局</h3><p><img src="/img/logisim%E5%B7%A5%E5%85%B7%E5%B8%83%E5%B1%80.png" alt="Logisim工具布局"></p>
<p>总结：</p>
<ol>
<li><p>Logisim 提供图形界面，以鼠标拖拽的形式可以新建部件以及进行部件间连线。</p>
</li>
<li><p>也可通过快捷键 Ctrl+D 增加一个所选择的部件。</p>
</li>
</ol>
<h3 id="元件概览（不止门电路）"><a href="#元件概览（不止门电路）" class="headerlink" title="元件概览（不止门电路）"></a>元件概览（不止门电路）</h3><h4 id="Wiring-线路-组件"><a href="#Wiring-线路-组件" class="headerlink" title="Wiring(线路) 组件"></a>Wiring(线路) 组件</h4><p><img src="/img/Wiring(%E7%BA%BF%E8%B7%AF)%E7%BB%84%E4%BB%B6.png" alt="Logisim中的Wiring(线路)组件">   </p>
<h5 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h5><p>The splitter creates a correspondence between a multi-bit value and several separate subsets of those bits.(简而言之就是将一个多位比特数同许多分割开的多位比特数的子集做联系) Despite its name, it can &#x3D;&#x3D;either split a multi-bit value into component parts&#x3D;&#x3D;, or it can &#x3D;&#x3D;combine component parts into a multi-bit value&#x3D;&#x3D; - or &#x3D;&#x3D;indeed it can do both at once&#x3D;&#x3D;. </p>
<p>具体实例：When you work with multi-bit values, you will often want to route different bits in different directions. The Wiring library’s splitter tool allows you to accomplish this.</p>
<p>For example, suppose we want a circuit that computes the bitwise AND of the two nibbles of its eight-bit input (the upper four bits and the lower four bits)(省流：将一个二进制数的高四位同低四位做与运算). We will have an eight-bit value coming from the input pin, and we want to split that into two four-bit values. In the below circuit, we have used a splitter to accomplish this: The 8-bit input comes into the splitter, which divides the 8 bits into two 4-bit values, which are then fed into the AND gate and from there to the output.</p>
<p><img src="/img/bundles-splitter-circ.png" alt="示例一"></p>
<p>In this example, the splitter ‘’splits’’ an incoming value into multiple outgoing values. But splitters can also work the other way: It can &#x3D;&#x3D;combine multiple values into a single value&#x3D;&#x3D;. In fact, they are &#x3D;&#x3D;non-directional&#x3D;&#x3D;: They can send values one way at one time and another way later, and they can even do both at the same time, as in the below example where a value travels eastward through the two splitters, then is routed back westward through them again, and then back eastward where it finally reaches its output.</p>
<p><img src="/img/bundles-splitter-2way.png" alt="示例二"></p>
<p>Logisim treats splitters specially when propagating values within a circuit: Whereas all other components have &#x3D;&#x3D;a computed delay(计算延迟)&#x3D;&#x3D; for purposes of simulating their behavior, values propagate through splitters (as well as wires) instantaneously.(省流：<del>值传递</del>经过splitters时无计算延迟) </p>
<p>The key to understanding splitters is their attributes. In the following, the term <em>split end</em> refers to one of the multiple wires on one side(<del>像刷子毛的</del>那一端的任意一个接口), while the term <em>combined end</em> refers to the single wire on the other side.</p>
<ul>
<li>The <strong>Facing</strong> attribute tells where the &#x3D;&#x3D;split ends&#x3D;&#x3D; should be relative to &#x3D;&#x3D;the combined end&#x3D;&#x3D;.(<del>控制刷子毛朝向</del>)</li>
<li>The <strong>Fan Out</strong> attribute specifies how many &#x3D;&#x3D;split ends&#x3D;&#x3D; there are.(<del>分多少根刷子毛出去</del>)</li>
<li>The <strong>Bit Width In</strong> attribute specifies the bit width of &#x3D;&#x3D;the combined end&#x3D;&#x3D;.(接入几位的比特)</li>
<li>The <strong>Bit x</strong> attribute says which split end corresponds to bit <em>x</em> of the combined end. If multiple bits correspond to the same split end, then their relative ordering will be the same as in the combined end. Logisim splitters cannot have a bit from the combined end correspond to multiple split ends.(<del>表示编号为0-((Fan Out)-1))的刷子毛的相对位置？</del>）</li>
</ul>
<p>Note that any change to the Fan Out or Bit Width In attributes will reset all Bit x attributes so that they will distribute the bits of the combined value as evenly as possible among the split ends.   </p>
<h5 id="Probe"><a href="#Probe" class="headerlink" title="Probe"></a>Probe</h5><p>Probe 作为一个显示线路数据值的部件，可以对&#x3D;&#x3D;多位宽数据&#x3D;&#x3D;进行实时监控，简而言之，就是可以直接显示接线的数值，并且不影响整个电路的运行。</p>
<p>熟练掌握 Probe 部件，可以方便对电路进行实时监控，做到分部件测试的效果。</p>
<p>Probe并不与电路中其他组件交互，适用于排错。   </p>
<p>Probe的接入引脚接收的比特位数是可变的，取决于输入的比特位数。</p>
<p>通过点击Probe工具，便可在希望添加Probe器件的地方添加该器件。大多数情况下Probe器件与输出管脚器件功能一致，但当电路作为子电路器件使用时，输出管脚将作为接口的一部分，而Probe并不作为接口的一部分。除此以外，Probe并不具有Data Bits属性用以进行配置。从属性上看，Pin管脚和Probe十分接近，区别在于Pin管脚边框较厚且为黑色，Probe边框较窄且为黑色。  </p>
<p>Probe的Facing属性可以更改其朝向，Label属性可以更改当前显示的内容，Label Location属性可以Label属性与器件的相对位置，还可以通过Label Font属性来修改标签词形。而Radix属性用来表示进制表示的形式。    </p>
<h5 id="Tunnel"><a href="#Tunnel" class="headerlink" title="Tunnel"></a>Tunnel</h5><p>Tunnel 部件是在整个 Logisim 实验中简化电路布线复杂度效果最好的一个部件，可以让你在纷繁复杂的接线中解脱出来，让你能够更加专心的关注于各个部件的设计，而不被复杂的接线所打扰。</p>
<p>Tunnel 名为隧道，即它可以将标签相同 Tunnel 之间的数据，通过一个不可见的“隧道”进行传输，在使用过程中，可以链接数据的输入端和输出端，使得数据可以方便简单的传输。</p>
<p>&#x3D;&#x3D;注：Tunnel 需要增加标签以区分不同的数据。并且每个标签只允许有一个输入，输出的数量不做限制。但是在有较多 Tunnel 部件的时候，要特别留意标签的名字，防止出现混乱。&#x3D;&#x3D;</p>
<p><img src="/img/image-20240818202039055.png" alt="Tunnel部件示意图"></p>
<h5 id="Pull-Resistor"><a href="#Pull-Resistor" class="headerlink" title="Pull Resistor"></a>Pull Resistor</h5><h6 id="Behavior"><a href="#Behavior" class="headerlink" title="Behavior"></a>Behavior</h6><p>When connected to a point, this component has an effect only when the value at that point is the floating value (Z)(即0、1、x中的x，浮动值，或不确定的值). In this case, the resistor pulls the wire to which it is connected toward the value indicated in its “Pull Direction” attribute.(可以通过连接输入、输出间的电路将输入端的x值变为1(One)、0(Zero)、E(Error))</p>
<p>![样例](&#x2F;img&#x2F;Pull Resistor.png)  </p>
<p>If it is connected to a multiple-bit value, then each bit in the value that is floating is pulled in the direction specified, while the bits that are not floating are left unchanged(省流:多位情况下恒定值保持不变，浮动值改变).    </p>
<h6 id="Pins"><a href="#Pins" class="headerlink" title="Pins"></a>Pins</h6><p>The resistor has just one pin, which is an output and has a bit width that is derived from whichever component it is connected.</p>
<h6 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h6><p>When the component is selected or being added, the arrow keys alter its Facing attribute.</p>
<ul>
<li><p>Facing</p>
<p>The direction in which the component’s pin lies from component’s center.</p>
</li>
<li><p>Pull Direction</p>
<p>Specifies the value to which a floating value should be pulled. This could be 0, 1, or the error value.</p>
</li>
</ul>
<h5 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h5><h6 id="Behavior-1"><a href="#Behavior-1" class="headerlink" title="Behavior"></a>Behavior</h6><p>The clock toggles(切换) its output value on a regular schedule as long as ticks are enabled via the <a target="_blank" rel="noopener" href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421e7e056d224327d427d00c7af9758/logisim/docs/2.7/en/html/guide/menu/simulate.html">Simulate menu</a>. (要先在最顶上一排中的Simulate menu里开启Ticks，才能让Clock”走起来“)(Ticks are disabled by default.) A “tick” is Logisim’s unit of time; the speed at which ticks occur can be selected from the Simulate menu’s Tick Frequency submenu.</p>
<p>The clock’s cycle can be configured using its High Duration and Low Duration attributes.</p>
<p>Note that Logisim’s simulation of clocks is quite <strong>unrealistic</strong>: In real circuits, &#x3D;&#x3D;multiple clocks will drift from one another and will never move in lockstep&#x3D;&#x3D;. But in Logisim, all clocks experience ticks at the same rate.</p>
<h6 id="Pins-1"><a href="#Pins-1" class="headerlink" title="Pins"></a>Pins</h6><p>A clock has only one pin, an output with a bit width of 1, whose value will represent the current value of the clock. The location of this pin is specified in the Facing attribute. The clock’s value will toggle on its schedule whenever ticks are enabled(只要启动,<del>时间就会走</del>), and it will toggle whenever it is clicked using the <a target="_blank" rel="noopener" href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421e7e056d224327d427d00c7af9758/logisim/docs/2.7/en/html/libs/wiring/poke.html">Poke Tool</a>.</p>
<h6 id="Attributes-1"><a href="#Attributes-1" class="headerlink" title="Attributes"></a>Attributes</h6><p>When the component is selected or being added, the arrow keys alter its Facing attribute.</p>
<ul>
<li><p>Facing</p>
<p>The side of the component where its output pin should be.</p>
</li>
<li><p>High Duration</p>
<p>The length of time within each cycle that the clock’s output should be 1.(省流:1持续的时间)</p>
</li>
<li><p>Low Duration</p>
<p>The length of time within each cycle that the clock’s output should be 0.(0持续的时间)</p>
</li>
<li><p>Label</p>
<p>The text within the label associated with the clock component.</p>
</li>
<li><p>Label Location</p>
<p>The location of the label relative to the component.</p>
</li>
<li><p>Label Font</p>
<p>The font with which to render the label.</p>
</li>
</ul>
<h6 id="Poke-Tool-Behavior"><a href="#Poke-Tool-Behavior" class="headerlink" title="Poke Tool Behavior"></a>Poke Tool Behavior</h6><p>Clicking a clock component will toggle its current output value immediately.(再点击Poke后，直接点击clock即可转换clock的值)</p>
<h6 id="Text-Tool-Behavior"><a href="#Text-Tool-Behavior" class="headerlink" title="Text Tool Behavior"></a>Text Tool Behavior</h6><p>Allows the label associated with the component to be edited.</p>
<h5 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h5><h6 id="Behavior-2"><a href="#Behavior-2" class="headerlink" title="Behavior"></a>Behavior</h6><p>Emits the value specified in its Value attribute.(省流:正如其名，不断输出其显示值)</p>
<h6 id="Pins-2"><a href="#Pins-2" class="headerlink" title="Pins"></a>Pins</h6><p>There is only one pin, an output whose bit width matches the Data Bits attribute. The location of this pin is specified in the Facing attribute. The component constantly outputs on this pin whatever value specified in the Value attribute.</p>
<h6 id="Attributes-2"><a href="#Attributes-2" class="headerlink" title="Attributes"></a>Attributes</h6><p>When the component is selected or being added, the hexademical digits ‘0’ through ‘9’ and ‘a’ through ‘f’ alter its Value attribute, Alt-0 through Alt-9 alter its Data Bits attribute, and the arrow keys alter its Facing attribute.</p>
<ul>
<li><p>Facing</p>
<p>The direction in which the pin is located relative to where the value is drawn.</p>
</li>
<li><p>Data Bits</p>
<p>The bit width of the value placed onto the wire.</p>
</li>
<li><p>Value</p>
<p>The value, written in hexademical, that is emitted by the component. The number of bits used to specify the value cannot exceed the component’s bit width.</p>
</li>
</ul>
<h5 id="Power-Ground"><a href="#Power-Ground" class="headerlink" title="Power&#x2F;Ground"></a>Power&#x2F;Ground</h5><h6 id="Behavior-3"><a href="#Behavior-3" class="headerlink" title="Behavior"></a>Behavior</h6><p>Emits a single value onto a wire. For a power element, indicated by a triangle(<del>长得一个小雨伞样</del>）, this value will be one (or, if the Data Bits attribute is more than 1, an all-ones value). For a ground element, indicated by an arrow of three shortening parallel lines(<del>神似WiFi信号图标被一把棍子戳平了</del>), this value will be zero (or, if the Data Bits attribute is more than 1, an all-zero value).</p>
<p>The same functionality can be achieved using the more versatile <a target="_blank" rel="noopener" href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421e7e056d224327d427d00c7af9758/logisim/docs/2.7/en/html/libs/wiring/constant.html">Constant</a> component. The only reason to prefer ground and power is that they are standard electronic symbols.(<del>因为标准所以爱</del>)</p>
<h6 id="Pins-3"><a href="#Pins-3" class="headerlink" title="Pins"></a>Pins</h6><p>There is only one pin, an output whose bit width matches the Data Bits attribute. The component constantly outputs the same value on this pin: for a ground component, the output is an all-zero value, and for a power component, the output is an all-one value.(省流：power全输出1，ground全输出0)</p>
<h6 id="Attributes-3"><a href="#Attributes-3" class="headerlink" title="Attributes"></a>Attributes</h6><p>When the component is selected or being added, Alt-0 through Alt-9 alter its Data Bits attribute and the arrow keys alter its Facing attribute.</p>
<ul>
<li><p>Facing</p>
<p>The direction in which the arrow will point from the location of its pin.</p>
</li>
<li><p>Data Bits</p>
<p>The bit width of the value placed onto the wire.</p>
</li>
</ul>
<h5 id="Transistor"><a href="#Transistor" class="headerlink" title="Transistor"></a>Transistor</h5><h6 id="Behavior-4"><a href="#Behavior-4" class="headerlink" title="Behavior"></a>Behavior</h6><p>A transistor has two inputs, called <strong>gate</strong> and <strong>source</strong>, and one output, called <strong>drain</strong>. When diagrammed, the <strong>source</strong> input and <strong>drain</strong> output are drawn connected by a plate;(<strong>source</strong>同<strong>drain</strong>直接通过极板相连) Logisim draws an arrowhead to indicate the direction of flow from input to output.(箭头表示输入到输出流向) The <strong>gate</strong> input is drawn connected to a plate that is parallel to the plate connecting <strong>source</strong> to <strong>drain</strong>.(<strong>gate</strong>在极板之上) Logisim supports two types of transistors, with slightly different behaviors described below; the P-type(positive) transistor is indicated by a circle connecting the <strong>gate</strong> input to its plate, while the N-type(negative) transistor has no such circle.</p>
<p>Depending on the value found at <strong>gate</strong>, the value at <strong>source</strong> may be transmitted to <strong>drain</strong>; or there may be no connection from <strong>source</strong>, so <strong>drain</strong> is left floating. The determination of transmitting or disconnecting depends on the type of transistor: A P-type transistor (indicated by a circle on the <strong>gate</strong> line) transmits when <strong>gate</strong> is 0(<strong>gate</strong>是0且在P状态下，<strong>drain</strong>的值与<strong>source</strong>的值相同), while an N-type transistor (which has no such circle) transmits when <em>gate</em> is 1. (反之亦然)The behavior is summarized by the following tables.</p>
<p>​                                                                                                              P-type</p>
<table>
<thead>
<tr>
<th><strong>gate</strong></th>
<th><strong>drain</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td><strong>source</strong></td>
</tr>
<tr>
<td>1</td>
<td>Z</td>
</tr>
<tr>
<td>X&#x2F;Z</td>
<td>X*</td>
</tr>
</tbody></table>
<p>​                                       N-type</p>
<table>
<thead>
<tr>
<th><strong>gate</strong></th>
<th><strong>drain</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Z</td>
</tr>
<tr>
<td>1</td>
<td><strong>source</strong></td>
</tr>
<tr>
<td>X&#x2F;Z</td>
<td>X*</td>
</tr>
</tbody></table>
<p>*:<em>if <strong>source</strong> is Z, <strong>drain</strong> is Z; otherwise <strong>drain</strong> is X.</em></p>
<p><em>If the Data Bits attribute is more than 1,&#x3D;&#x3D;the <strong>gate</strong> input is still a single bit&#x3D;&#x3D;, but its value is applied simultaneously to each of the <strong>source</strong> input’s bits.An N-type transistor behaves very similarly to a <a target="_blank" rel="noopener" href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421e7e056d224327d427d00c7af9758/logisim/docs/2.7/en/html/libs/gates/controlled.html">Controlled Buffer</a>. The primary difference is that a transistor is meant for more basic circuit designs.</em>(<del>基础即王道</del>)</p>
<h6 id="Pins-assuming-component-faces-east-gate-line-top-left"><a href="#Pins-assuming-component-faces-east-gate-line-top-left" class="headerlink" title="Pins (assuming component faces east, gate line top&#x2F;left)"></a>Pins (assuming component faces east, gate line top&#x2F;left)</h6><p>West edge (input, bit width matches Data Bits attribute)(<strong>source</strong>)</p>
<p>The component’s <strong>source</strong> input that will transmit to the output if triggered by the <strong>gate</strong> input.</p>
<p>North edge (input, bit width 1)(<strong>gate</strong>)</p>
<p>The component’s <strong>gate</strong> input. For P-type transistors, the transistor will transmit if the <strong>gate</strong> value is 0; for N-type transistors, this will trigger the transistor if the <strong>gate</strong> value is 1.</p>
<p>East edge (output, bit width matches Data Bits attribute)(<strong>drain</strong>)</p>
<p>The component’s output, which will match the <strong>source</strong> input if indicated by the <strong>gate</strong> input, or will be floating if the <strong>gate</strong> input is the negation of what indicates negation. If <strong>gate</strong> is floating or an error value, then the output will be &#x3D;&#x3D;an error value&#x3D;&#x3D;.</p>
<h5 id="Transmission-Gate"><a href="#Transmission-Gate" class="headerlink" title="Transmission Gate"></a>Transmission Gate</h5><p>一个<strong>Transmission Gate</strong>有三个输入(<strong>source</strong>、<strong>n-gate</strong>、<strong>p-gate</strong>)、一个输出(<strong>drain</strong>)。与Transistor类似的，<strong>source</strong>同<strong>drain</strong>直接通过两极板相连，而<strong>p-gate</strong>(同P-type一样有小圆圈)和<strong>n-gate</strong>(同N-type一样没圆圈)分别平行存在于上下极板(<del>出场器件</del>).</p>
<p>&#x3D;&#x3D;The transmission gate is simply the combination of two complementary transistors.&#x3D;&#x3D;(<del>鞭辟入里</del>)Indeed, the same behavior can be achieved in Logisim by using just one transistor. However, designers sometimes prefer to use matched pairs of transistors due to electrical issues with draining voltage that is more complex than Logisim attempts to simulate.(<del>不知所云</del>，<del>设计师为王？</del>)</p>
<p>只有<strong>p-gate</strong>和<strong>n-gate</strong>分别为0和1时，<strong>source</strong>可以原封不动的传给<strong>drain</strong>。</p>
<table>
<thead>
<tr>
<th><strong>p-gate</strong></th>
<th><strong>n-gate</strong></th>
<th><strong>drain</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>X*</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td><strong>source</strong></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Z</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>X*</td>
</tr>
<tr>
<td>X&#x2F;Z</td>
<td>any</td>
<td>X*</td>
</tr>
<tr>
<td>any</td>
<td>X&#x2F;Z</td>
<td>X*</td>
</tr>
</tbody></table>
<h5 id="Bit-Extender"><a href="#Bit-Extender" class="headerlink" title="Bit Extender"></a>Bit Extender</h5><h6 id="Behavior-5"><a href="#Behavior-5" class="headerlink" title="Behavior"></a>Behavior</h6><p>The bit extender transforms a value into a value of another bit width. If it’s being transformed into a smaller bit width,(入大出小就截断，保留低位) it is simply truncated to keep the lowest-order bits. If it’s being transformed into a large bit width, the lowest-order bits are the same,(入小出大就补齐) and you have a choice about what the additional high-order bits will be: They can all be 0, all be 1, all match the input’s sign bit (its highest-order bit), or the component can have an additional one-bit input that determines the identity of these other bits.</p>
<h6 id="Pins-4"><a href="#Pins-4" class="headerlink" title="Pins"></a>Pins</h6><ul>
<li><p>West edge (input, bit width from Bit Width In attribute)</p>
<p>The multi-bit input whose value is to be transformed.</p>
</li>
<li><p>East edge (output, bit width from Bit Width Out attribute)</p>
<p>The computed output.</p>
</li>
<li><p>North edge (input, bit width 1)</p>
<p>&#x3D;&#x3D;Specifies what the additional bits in the output should be&#x3D;&#x3D;. <strong>This pin is available only when the Extension Type attribute is Input</strong>.</p>
</li>
</ul>
<h6 id="Attributes-4"><a href="#Attributes-4" class="headerlink" title="Attributes"></a>Attributes</h6><p>When the component is selected or being added, the digits 0 through 9 alter the Bit Width In attribute and Alt-0 through Alt-9 alter its Bit Width Out attribute.</p>
<ul>
<li><p>Bit Width In</p>
<p>The input’s bit width.</p>
</li>
<li><p>Bit Width Out</p>
<p>The output’s bit width.</p>
</li>
<li><p>Extension Type</p>
<p>Assuming the output bit width exceeds the input bit width, this attribute configures what the additional output bits should be. If Zero or One, the additional bits are 0 or 1 accordingly. If Sign, &#x3D;&#x3D;the additional bits are taken to match the highest-order bit in the input&#x3D;&#x3D;. (拿原来最高位去补齐多出来的，类似用符号位(sign)补齐)And if Input, &#x3D;&#x3D;the component has a second input on its north side whose <strong>one-bit value</strong> is used for the additional bits&#x3D;&#x3D;.(input提供的只能是一位，也就是说补齐时所有方式补齐的位都全是0或全是1，<del>好多余的设计</del>)</p>
</li>
</ul>
<h4 id="Gates-逻辑门-组件"><a href="#Gates-逻辑门-组件" class="headerlink" title="Gates(逻辑门) 组件"></a>Gates(逻辑门) 组件</h4><p><img src="/img/Gates(%E9%80%BB%E8%BE%91%E9%97%A8)%E7%BB%84%E4%BB%B6.png" alt="Logisim中的Gates(逻辑门)组件"><br>     ##### Buffer</p>
<h6 id="Behavior-6"><a href="#Behavior-6" class="headerlink" title="Behavior"></a>Behavior</h6><p>The buffer simply passes through to its right output whatever input it receives on the left side. (正常情况下，传啥输啥，除非改变其Attributes中的Output Value)   </p>
<p>Buffers are &#x3D;&#x3D;the most useless&#x3D;&#x3D; of the gate components provided in Logisim; (<del>官方认证</del>)its presence in the Gates library is just as much a matter of completeness (a component for each possible one-input truth table) as it is a matter of providing useful functionality. Still, it can be occasionally useful to ensure that values propagate in only one direction along a wire.(<del>莫名其妙的用途，存在即合理？</del>)    </p>
<h6 id="Attributes-5"><a href="#Attributes-5" class="headerlink" title="Attributes"></a>Attributes</h6><p>Output Value：</p>
<p>Indicates how false and true results should be translated into output values. By default, false is indicated by a low voltage (0) and true by a high voltage (1), but one or the other can be replaced by a high-impedance (floating) value instead. This allows wired-or and wired-and connections, as illustrated in the <a target="_blank" rel="noopener" href="https://d.buaa.edu.cn/http/77726476706e69737468656265737421e7e056d224327d427d00c7af9758/logisim/docs/2.7/en/html/libs/gates/basic.html">AND&#x2F;OR&#x2F;NAND&#x2F;NOR Gate documentation</a>.</p>
<p>用Buffer和Pull resistor构建与门和非门。下图中左边两个Buffer的Output Value属性都为floating&#x2F;1(即1得1、0得x),the resistor pulls to 0.右边两个Buffer的Output Value属性都为0&#x2F;floating(即1得x、0得0),the resistor pulls to 1.</p>
<p>![buffer和resistor搭建与非门](&#x2F;img&#x2F;wired-or and wired-and.png)    </p>
<h5 id="XOR-异或-XNOR-同或-Odd-Parity-奇检验-Even-Parity-偶检验-Gate"><a href="#XOR-异或-XNOR-同或-Odd-Parity-奇检验-Even-Parity-偶检验-Gate" class="headerlink" title="XOR(异或)&#x2F;XNOR(同或)&#x2F;Odd Parity(奇检验)&#x2F;Even Parity(偶检验) Gate"></a>XOR(异或)&#x2F;XNOR(同或)&#x2F;Odd Parity(奇检验)&#x2F;Even Parity(偶检验) Gate</h5><table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th><strong>XOR</strong></th>
<th>XNOR</th>
<th>Odd Parity</th>
<th>Even Parity</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody></table>
<p>As you can see, the Odd Parity gate and the XOR gate behave identically with two inputs; similarly, the even parity gate and the XNOR gate behave identically.(相似但不相同)But if there are more than two specified inputs, the XOR gate will emit 1 only when there is exactly one 1 input(异或只有在仅有一个1输入时输出为1), whereas the Odd Parity gate will emit 1 if there are an odd number of 1 inputs(而奇检验在输入为1的个数为奇数的情况下输出就为1). The XNOR gate will emit 1 only when there is <em>not</em> exactly one 1 input(同或在输入为一个1时输出为0，其余情况输出均为1), while the Even Parity gate will emit 1 if there are an even number of 1 inputs(偶检验在输入为偶数个1时输出为1). The XOR and XNOR gates include an attribute titled Multiple-Input Behavior that allow them to be configured to use the Odd Parity and Even Parity behavior.</p>
<h5 id="Controlled-Buffer-Inverter"><a href="#Controlled-Buffer-Inverter" class="headerlink" title="Controlled Buffer&#x2F;Inverter"></a>Controlled Buffer&#x2F;Inverter</h5><p>正如其名，Controlled Buffer&#x2F;Inverter就是由一个控制位(正常情况下器件南边的把儿，需要输入值)控制的Buffer&#x2F;Inverter(NOT gate).因此，也被称为<em>three-state buffers&#x2F;inverters</em>。</p>
<p>当控制位为1时Controlled Buffer&#x2F;Inverter分别为Buffer&#x2F;NOT gate;</p>
<p>当控制位为0或者未知(i.e., floating)时,两种器件的输出均为x;</p>
<p>当控制位为Error(such as would occur when two conflicting values are being fed into the input)时，器件输出值均为error。</p>
<p>Controlled buffers can be useful when you have a wire (often called a <em>bus</em>) whose value should match the output of one of several components. By placing a controlled buffer between each component output and the bus, you can control whether that component’s output is fed onto the bus or not.   </p>
<h4 id="Plexers-复用器-组件"><a href="#Plexers-复用器-组件" class="headerlink" title="Plexers(复用器)组件"></a>Plexers(复用器)组件</h4><p><img src="/img/Plexers(%E5%A4%8D%E7%94%A8%E5%99%A8)%E7%BB%84%E4%BB%B6.png" alt="Logisim中的Plexers(复用器)组件"></p>
<h5 id="Multiplexer"><a href="#Multiplexer" class="headerlink" title="Multiplexer"></a>Multiplexer</h5><p>多路选择器，将左端多个输入（从上到下以0开始编号）经过下端左侧的选择（若选择为浮动值则输出全为浮动值x）其中一个编号复制到右端输出。下端右侧还有一个输入，在其为0时将输出全置为浮动值x，不论输入值以及选择的编号是多少；其为其他值时无影响。</p>
<h5 id="Demultiplexer"><a href="#Demultiplexer" class="headerlink" title="Demultiplexer"></a>Demultiplexer</h5><p>多路分配器（网易有道翻译），将左端一个输入经过下端右侧的选择（若选择为浮动值则输出全为浮动值x）其中一个编号复制到右端（从上到下以0为始编号）相应编号输出。下端左侧还有一个输入，其为0时将输出全置为浮动值x，不论输入值以及选择的编号是多少；其为其他值时无影响。</p>
<h5 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h5><p>译码器，根据下端右侧输入的编号在右端（从上到下以0为始编号）输出1。下端左侧还有一个输入，其为0时将输出全置为浮动值x，不论输入值以及选择的编号是多少；其为其他值时无影响。</p>
<p>最大的功能在于可以将二进制编码转换为相应的独热码，如101的3位二进制编码作为输入就可以被转换为00100000的8位独热码作为输出。</p>
<h5 id="Priority-Encoder"><a href="#Priority-Encoder" class="headerlink" title="Priority Encoder"></a>Priority Encoder</h5><p>优先编码器，左端引脚从上到下以0为始编号，右端上引脚输出左端输入为1的引脚的最大编号，右端下引脚输出是否找到最大编号：若未找到输出0，同时右端上引脚也输出0或者全为浮动值x（依据Disabled Output属性确定）；若找到则输出1，同时右端上引脚输出最大编号。除此之外，在该器件的下端还有一个Enable In输入引脚来决定器件是否运行：若输入为0，则停止运行；否则正常运行。并且该器件还有一个Enable Out输出引脚：只有当器件正常运行并且右端没有输出时即右端下引脚为0时输出1，其余情况都输出0.上述性质可以实现多个编码器串接来适应额外的输入。</p>
<p>An additional output of the priority encoder is 1 whenever the priority encoder is enabled and finds a 1 on one of the indexed inputs. When chaining priority encoders together, this output can be used to identify which of the encoders was triggered.（省流：右端下引脚的输出可以用来判断多个串接起来的优先编码器中哪个被“激活”了）</p>
<h5 id="Bit-Selector"><a href="#Bit-Selector" class="headerlink" title="Bit Selector"></a>Bit Selector</h5><p>该器件可将多位比特数，从低位起均分为位数相同的多个切片，若高位不够切则用0补齐再根据下端输入的切片索引在右端输出相应的切片。例如：输入多位比特为<code>01010101</code>，设置Bit Selector的Output Bits为3即均分为位数为三的多个切片，那么切片0即为<code>101</code>，切片1为<code>010</code>，切片2为<code>001</code>，切片3为<code>000</code>。</p>
<h4 id="Arithmetic-运算器-组件"><a href="#Arithmetic-运算器-组件" class="headerlink" title="Arithmetic(运算器)组件"></a>Arithmetic(运算器)组件</h4><p><img src="/img/Arithmetic(%E8%BF%90%E7%AE%97%E5%99%A8)%E7%BB%84%E4%BB%B6.jpg" alt="Logisim中的Arithmetic(运算器)组件"></p>
<h5 id="Adder"><a href="#Adder" class="headerlink" title="Adder"></a>Adder</h5><p>作为一个加法器，该器件的功能就是将左端(正常情况下)两个输入相加并加上上端输入的carry-in(c in)位，得到sum，从右端输出sum溢出后的部分，下端输出carry-out(c out)为sum溢出的部分。如此一来多个该器件相连结可以扩大加法的范围。</p>
<h5 id="Subtractor"><a href="#Subtractor" class="headerlink" title="Subtractor"></a>Subtractor</h5><p>作为一个减法器，该器件的功能就是将左上端(正常情况下)的输入减去左下端的输入并且减去borrow-in(b in)位，得到sum，从右端输出sum溢出后的部分，在假定无符号数减法的情况下，如果左上大于等于（左下+borrow-in）则下端borrow-out(b out)输出0，反之输出1，表示从更高一位借一位1，例如:左上:<code>10000000</code>,左下:<code>10000000</code>，b in:<code>1</code>，则b out:<code>1</code>，sum:<code>11111111</code>即<code>110000000</code>-<code>10000001</code>。</p>
<h5 id="Multiplier"><a href="#Multiplier" class="headerlink" title="Multiplier"></a>Multiplier</h5><p>作为一个乘法器，该器件的功能就是将左端(正常情况下)两个输入相乘并加上上端输入的carry-in(c in)位，得到sum，从右端输出sum溢出后的部分（the lower dataBits bits of the product of the two values coming in the west edge, plus the cin value），下端carry-out输出sum溢出的部分（the upper dataBits bits of the product）。</p>
<h5 id="Divider"><a href="#Divider" class="headerlink" title="Divider"></a>Divider</h5><p>作为一个除法器，该器件拥有三个输入端，两个输出端，主要功能是将左上端输入的数同上端输入的数结合，上端作高为，左上端做低位，作为<strong>dividend</strong>，除以左下端输入的数<strong>divisor</strong>，根据quotient * divisor + remainder &#x3D; dividend，右端输出<strong>quotient</strong>，下端输出<strong>remainder</strong>。但是输出时并不考虑溢出问题，若溢出只会显示溢出后结果，无法查询完整结果，ps：需手动控制防溢出(<del>除法老是出问题</del>)。</p>
<h5 id="Negator"><a href="#Negator" class="headerlink" title="Negator"></a>Negator</h5><p>即取反操作（~）。</p>
<h5 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h5><p>比较器顾名思义，即将左上端输入的数同左下端输入的数作比较，大于情况输出在右上端，等于情况输出在右中端，小于情况输出在右下端。  </p>
<h5 id="Shifter"><a href="#Shifter" class="headerlink" title="Shifter"></a>Shifter</h5><p>移位器将左上端输入的<strong>data</strong>移动左下端输入的<strong>dist</strong>位数，<strong>dist</strong>的位数根据<strong>data</strong>输入的位数决定，用y表示<strong>data</strong>的位数、x表示<strong>dist</strong>的位数，则x为2^x^&gt;&#x3D;y中x的最小整数值。</p>
<p>而其中移动的类型又分为5种：</p>
<ul>
<li><p>逻辑左移（Logical Left）:左移低位补0. For example, 11001011 logically shifted left twice is 00101100. (The top two ones are lost.)</p>
</li>
<li><p>逻辑右移（Logical Right）: 右移高位补0. For example, 11001011 logically shifted right twice is 00110010. (The bottom two ones are lost.)</p>
</li>
<li><p>算术右移（Arithmetic Right）: 右移高位根据最高位补. For example, 11001011 arithmetically shifted right twice is 11110010.</p>
</li>
<li><p>循环左移（Rotate Left）: 左移低位由高位溢出的补齐. For example, 11001011 rotated left twice is 00101111.</p>
</li>
<li><p>循环右移（Rotate Right）: 右移高位由低位溢出补齐. For example, 11001011 rotated right twice is 11110010.</p>
</li>
</ul>
<h5 id="Bit-Adder"><a href="#Bit-Adder" class="headerlink" title="Bit Adder"></a>Bit Adder</h5><p>输出输入的二进制数中的1的个数。</p>
<h5 id="Bit-Finder"><a href="#Bit-Finder" class="headerlink" title="Bit Finder"></a>Bit Finder</h5><p>索引器根据Attributes中的Type（Lowest-order 1、Lowest-order 0、Highest-order 1、Highest-order 0）在左端输入的数中寻找相应的索引，若没找到则在下端显示0并右端也同样显示0；若找到则在下端显示1并在右端显示相应的索引。</p>
<h4 id="Memory-存储-组件"><a href="#Memory-存储-组件" class="headerlink" title="Memory(存储)组件"></a>Memory(存储)组件</h4><p><img src="/img/Memory(%E5%AD%98%E5%82%A8)%E7%BB%84%E4%BB%B6.png" alt="Logisim中的Memory(存储)组件"></p>
<h5 id="D-T-J-K-S-R-Flip-Flop"><a href="#D-T-J-K-S-R-Flip-Flop" class="headerlink" title="D&#x2F;T&#x2F;J-K&#x2F;S-R Flip-Flop"></a>D&#x2F;T&#x2F;J-K&#x2F;S-R Flip-Flop</h5><p>每个触发器储存一个数据位，并通过右端Q释放，右端Q下侧一端还会输出当前触发器储存的值的补码（省流：若Q为1则Q下为0；反之亦然）。通常情况下，释放值将会受左端输入影响。尤其是当以三角形为标记的<strong>clock</strong>输入端的输入值发生0&#x2F;1变换或者低电平持续以及高电平持续时。</p>
<h6 id="D-Flip-Flop"><a href="#D-Flip-Flop" class="headerlink" title="D Flip-Flop"></a>D Flip-Flop</h6><table>
<thead>
<tr>
<th>D</th>
<th>Q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>当时钟触发（根据器件Trigger属性（0-&gt;1切换、1-&gt;0切换、低电平持续、高电平持续）中的描述决定）时，触发器储存的值变为该时刻D输入的值。</p>
<h6 id="T-Flip-Flop"><a href="#T-Flip-Flop" class="headerlink" title="T Flip-Flop"></a>T Flip-Flop</h6><table>
<thead>
<tr>
<th>T</th>
<th>Q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Q</td>
</tr>
<tr>
<td>1</td>
<td>Q‘</td>
</tr>
</tbody></table>
<p>当时钟触发（根据器件Trigger属性（0-&gt;1切换、1-&gt;0切换）中的描述决定）时，触发器储存的值要么保持不变要么切换，当T输入为1时切换，当T为0时保持不变。</p>
<h6 id="J-K-Flip-Flop"><a href="#J-K-Flip-Flop" class="headerlink" title="J-K Flip-Flop"></a>J-K Flip-Flop</h6><table>
<thead>
<tr>
<th>J</th>
<th>K</th>
<th>Q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>Q</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Q’</td>
</tr>
</tbody></table>
<p>当时钟触发（根据器件Trigger属性（0-&gt;1切换、1-&gt;0切换）中的描述决定）时，若J输入和K输入（下文简称J和K）一样，同为0时，Q值不变；同为1时，Q值切换。若J和K不一样，则J（Jump）为1时，Q值为1；K（Kill）为1时，Q值为0。</p>
<h6 id="S-R-Flip-Flop"><a href="#S-R-Flip-Flop" class="headerlink" title="S-R Flip-Flop"></a>S-R Flip-Flop</h6><table>
<thead>
<tr>
<th>S</th>
<th>R</th>
<th>Q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>Q</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Q</td>
</tr>
</tbody></table>
<p>当时钟触发（根据器件Trigger属性（0-&gt;1切换、1-&gt;0切换、低电平持续、高电平持续）中的描述决定）时，若S输入和R输入（下文简称S和R）一样，则Q值保持不变；若S和R不一样，则S（set）为1时，Q值为1；R（reset）为1时，Q值为0。</p>
<h6 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h6><p>每一个触发器的下端从左至右都有三个输入端口，按顺序记为1、en、0端口。1端口输入为1时，Q值立刻变为1且停止触发，1端口其余值对触发器无影响。en端口为0时，时钟的触发将被忽略，其余值时始终仍可触发。0端口为1时，Q值立刻变为0且停止触发，0端口其余值对触发器无影响。0端口将Q值置0优先于1端口置1。</p>
<h5 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h5><p>一个寄存器储存一个多比特值，并以十六进制的形式体现在器件中，从右端Q输出相应的二进制值。器件左端有D（Data）（上）输入端和en（enable）（下）输入端，D端输入数据，en端决定寄存器是否接收clock端的触发，当en端为1时接收clock端触发，当始终触发根据器件Trigger属性（0-&gt;1切换、1-&gt;0切换、低电平持续、高电平持续）中的描述决定）时，寄存器的值和Q端的值变为D端此时的值；当en端为0时忽略clock端的触发信号。器件下端从左至右有两个输入端分别为clock端（左）和0端口（右），0端口为1时，寄存器的值和Q值立刻变为0且停止触发，0端口其余值对触发器无影响。</p>
<h5 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h5><h6 id="Behavior-7"><a href="#Behavior-7" class="headerlink" title="Behavior"></a>Behavior</h6><p>计数器共有5个输入端（三个在左端，从上至下为load端、D（Data）端、ct（count）端，另外两个在下端，从左至右为clock端和0（clear）端），两个输出端（在右端，从上至下依次为Q端和carry端）。当0端不为1时，且当时钟触发（根据器件Trigger属性（0-&gt;1切换、1-&gt;0切换）中的描述决定）时，计数器的值和Q值会根据load端和count端的值发生如下表的变化：</p>
<table>
<thead>
<tr>
<th>load(加载)</th>
<th>count(计数)</th>
<th>触发变化</th>
</tr>
</thead>
<tbody><tr>
<td>0&#x2F;x</td>
<td>0</td>
<td>计数器的值和Q值保持不变</td>
</tr>
<tr>
<td>0&#x2F;x</td>
<td>1&#x2F;x</td>
<td>计数器的值和Q值递增</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>计数器的值和Q值变为D值(可以理解为加载上传)</td>
</tr>
<tr>
<td>1</td>
<td>1&#x2F;x</td>
<td>计数器的值和Q值递减</td>
</tr>
</tbody></table>
<p>当0端不为1但无时钟触发时，计数器的值和Q值保持不变；当0端为1时，Q值变为0，不管任何输入。除此之外，carry端在Q值达到&#x3D;&#x3D;定义的最大值&#x3D;&#x3D;（由Attributes中的Maximum Value定义）并且时钟触发的变化为递增或者Q值为0并且时钟触发的变化为递减时为1，其余情况均为0.</p>
<h6 id="Attributes-6"><a href="#Attributes-6" class="headerlink" title="Attributes"></a>Attributes</h6><p>&#x3D;&#x3D;特别注意&#x3D;&#x3D;：Action On Overflow：代表“溢出”时的行为（递增过定义的最大值或者递减过0的时候），共有四种：Wrap around（定义的最大值增为0，0减为定义的最大值）、Stay at value(保持不变)、Continue counting(定义的最大值递增直到比特位所能表示的最大值，继续增为0；0减为比特位所能表示的最大值)、Load next value(“溢出”时变化为D值)。</p>
<h5 id="Shift-Register"><a href="#Shift-Register" class="headerlink" title="Shift Register"></a>Shift Register</h5><p>移位寄存器按阶段存储并输出值，并从左向右按时间顺序加入或删除不同的阶段的值。   </p>
<p>左端有三个输入口，左上为1比特值，当其不为0时，寄存器做正常的一位存储行为；反之停止移位存储。不过当<code>Load</code>输入端(上最左)为1时，左上输入的值将被忽略。左中的位宽根据寄存器存储的位宽决定，是输入数据的端口。左下是<code>clock</code>端，当时钟触发时，寄存器会进行移位存储，将会移位处理，或者加载上传数据(<code>Load</code>&#x3D;&#x3D;1时)。  </p>
<p>上端最左端为<code>Load</code>端，其输入为1时，会将其右侧上端有输入的引脚的值在下一次时钟触发时加载上传到移位寄存器对应的阶段的值上。</p>
<p>下端最左端为<code>clear</code>端，其输入为1时，将把移位寄存器的所有阶段的值置为0。其右侧所有端口在有输出端口相连时会输出相应阶段的值。    </p>
<p>右端有一个输出端口，输出最后一个阶段的值，即最右边的一个阶段的值。</p>
<h5 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h5><p>该器件根据特定的公式来产生随机数。</p>
<h5 id="RAM存储器"><a href="#RAM存储器" class="headerlink" title="RAM存储器"></a>RAM存储器</h5><p>RAM 是一个可读可写的存储器，在实验中，采用的是读与写相互分离的类型，所以在选择 RAM 时，请将数据接口选择为 “Separate load and store ports”。   </p>
<p>RAM可以储存多达16777216个值(在the Address Bit Width属性中指定)，每个值最多可以包含32位(在the Data Bit Width属性中指定)。  </p>
<p>RAM储存的当前值显示在组件中，显示的地址在显示区左侧以灰色列示。在其内部，每个值都用16进制表示。当前所选地址的值将以反向文本显示（即黑底白字）。   </p>
<p>RAM有三种不同的传输界面，取决于the Data Interface attribute属性。</p>
<p>1.One synchronous load&#x2F;store port（默认，一个同步加载&#x2F;存储接口):此时该器件有一个单接口在左端即可加载上传也可储存数据。而这些的执行取决于<code>ld</code>端（下端从左至右数第三个）的输入:1(或浮动)表示将数据加载到组件左端指定的地址，0表示将数据存储在端口上。为了将数据传入和传出组件，您需要使用受控缓冲区组件，如下所示。</p>
<p><img src="/img/ramdemo.png" alt="示例"></p>
<p>2.One asynchronous load&#x2F;store port(一个异步加载&#x2F;存储接口)</p>
<p>此时器件没有时钟端。当<code>ld</code>端输入为0时，在数据接口处的值会被存储到内存中。如果，当<code>ld</code>端输入为0时，地址或数据发生变化，则会发生额外的存储。这个选项意味着更接近于许多可用的随机存取存储器的接口。</p>
<p>3.Separate load and store ports（单独的加载和存储接口）</p>
<p>此时提供了两个数据端口-一个在左端用于存储数据，另一个在右端用于加载数据。此状态下有7个输入端，1个输出端。  </p>
<p>器件左端有两个端口，左上为<code>A</code>端口，输入的值将表示选择的存储地址（address）；左下为<code>D</code>端口，输入的值将表示写入的值。  </p>
<p>器件下端有5个输入端口，从左至右分别是<code>str</code>、<code>sel</code>、<code>clock</code>、<code>ld</code>、<code>clr</code>。其中<code>str</code>端口决定是否将左<code>D</code>端口的数据上传到<code>A</code>端输入的地址上（前提是<code>sel</code>端口输入值不为0）。<code>sel</code>端口的作用便是决定该地址是否被选择，即是否被选中。<code>ld</code>端口决定左<code>D</code>端口的数据是否上传到右<code>D</code>端口上（前提是<code>sel</code>端口输入值不为0）。<code>clr</code>端口的作用便是将RAM中所有地址的值置0。</p>
<p>器件的右端有一个<code>D</code>端口，当<code>sel</code>&#x3D;&#x3D; 1 且 <code>ld</code>&#x3D;&#x3D;1，该端口将输出左<code>D</code>端口的值。</p>
<h5 id="ROM存储器"><a href="#ROM存储器" class="headerlink" title="ROM存储器"></a>ROM存储器</h5><p>ROM 是一个只读类型的存储器，顾名思义，在使用过程中只能对其进行读取操作，而&#x3D;&#x3D;不能进行写操作&#x3D;&#x3D;，所以 ROM 在创建时，必须一次性将所有的信息全部导入，之后不可再进行更改。   </p>
<p>对于 RAM 和 ROM 的数据的导入有以下两种方式：</p>
<ol>
<li>手动导入：可手动在数据区域选择内存直接进行更改</li>
<li>文件导入：可编写相应的数据文件，进行一次性导入，文件头需要增加一行 &#x3D;&#x3D;<code>v2.0 raw</code>&#x3D;&#x3D; 字样才可以正确导入。</li>
</ol>
<p>对于 RAM 和 ROM 的数据位宽，在实验中，请选择 &#x3D;&#x3D;32 位&#x3D;&#x3D;，这与 &#x3D;&#x3D;MIPS 的指令长度相匹配&#x3D;&#x3D;，至于地址位宽，请确保位宽长度能够容纳实验要求的指令数量。    </p>
<p>ROM组件最多可存储16,777,216个值，每个值最多可包含32位。电路可以访问ROM中的电流值，但不能改变它们。用户可以通过Poke工具交互式地修改单个值，或者用户可以通过菜单工具修改整个内容。</p>
<h4 id="Input-Output-输入-输出-组件"><a href="#Input-Output-输入-输出-组件" class="headerlink" title="Input&#x2F;Output(输入&#x2F;输出)组件"></a>Input&#x2F;Output(输入&#x2F;输出)组件</h4><p><img src="/img/Logisim_2_1_IO.png" alt="Logisim中的Input/Output(输入/输出)组件"></p>
<h4 id="Base（基本）组件"><a href="#Base（基本）组件" class="headerlink" title="Base（基本）组件"></a>Base（基本）组件</h4><p><img src="/img/logisim_2_1_Base.png" alt="Logisim中的Base（基本）组件"></p>
<h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><h4 id="搭建异或电路"><a href="#搭建异或电路" class="headerlink" title="搭建异或电路"></a>搭建异或电路</h4><p>x^y&#x3D;x XOR y&#x3D;(x AND NOT y) OR (NOT x AND y)</p>
<p>真值表</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>x XOR y</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>图示：</p>
<p><img src="/img/xor.png" alt="异或电路">   </p>
<h2 id="Logisim组合电路"><a href="#Logisim组合电路" class="headerlink" title="Logisim组合电路"></a>Logisim组合电路</h2><h3 id="子电路"><a href="#子电路" class="headerlink" title="子电路"></a>子电路</h3><h4 id="创建子电路"><a href="#创建子电路" class="headerlink" title="创建子电路"></a>创建子电路</h4><p>通过Project栏下的Add Circuit；</p>
<h4 id="添加子电路内容"><a href="#添加子电路内容" class="headerlink" title="添加子电路内容"></a>添加子电路内容</h4><p>子电路布线</p>
<h4 id="设置子电路外观"><a href="#设置子电路外观" class="headerlink" title="设置子电路外观"></a>设置子电路外观</h4><p><img src="/img/logisim_3_1_1.png" alt="查看电路外观"></p>
<p><strong>ps:更改外观时，可对端口增加文字说明，提高可读性</strong></p>
<h4 id="引用子电路"><a href="#引用子电路" class="headerlink" title="引用子电路"></a>引用子电路</h4><p>3种方法：</p>
<p>1.在Project菜单中选择View Simulasion Tree，窗格将显示正在访问的电路的子电路的层次结构，双击层次结构中的一个元素将显示该子电路中的仿真情况。</p>
<p>2.通过在子电路上右键或者右键同时点击<code>ctrl</code>键得到选项点击View即可。</p>
<p>3.选用Poke工具，点击子电路出现放大后双击放大镜即可进入该子电路。</p>
<h3 id="Wire-colors"><a href="#Wire-colors" class="headerlink" title="Wire colors"></a>Wire colors</h3><p>![接线颜色](&#x2F;img&#x2F;wire colors.png)</p>
<h3 id="利用Logisim进行组合逻辑分析"><a href="#利用Logisim进行组合逻辑分析" class="headerlink" title="利用Logisim进行组合逻辑分析"></a>利用Logisim进行组合逻辑分析</h3><h4 id="三种主要技术"><a href="#三种主要技术" class="headerlink" title="三种主要技术"></a>三种主要技术</h4><p>1.逻辑电路</p>
<p>2.布尔表达式</p>
<p>3.真值表</p>
<p>运用组合逻辑分析模块，可根据逻辑表达式得到相应的真值表。也可通过输入真值表，再产生相应的表达式，或者产生相应的电路。</p>
<p>打开组合逻辑分析模块的方式：</p>
<ol>
<li><p>Window 栏目下的 Combinational Analysis</p>
</li>
<li><p>Project 栏目下的 Analyze Circuit</p>
</li>
</ol>
<p>ps:Logisim的组合逻辑分析并不支持异或操作。</p>
<h2 id="Logisim时序电路"><a href="#Logisim时序电路" class="headerlink" title="Logisim时序电路"></a>Logisim时序电路</h2><h3 id="SR锁存器（SR-latch）"><a href="#SR锁存器（SR-latch）" class="headerlink" title="SR锁存器（SR latch）"></a>SR锁存器（SR latch）</h3><p>SR锁存器由两个&#x3D;&#x3D;交叉耦合的或非门&#x3D;&#x3D;（或者，等价地，两个&#x3D;&#x3D;反置输入的与非门&#x3D;&#x3D;）组成，整个电路的状态可以由 S（Set）和 R（Reset）输入来决定，对应得到两个相反的输出 Q 和 ~Q，它的真值表如下：</p>
<p><img src="/img/%E7%94%A8%E6%88%96%E9%9D%9E%E9%97%A8%E7%BB%84%E6%88%90%E7%9A%84SR%E9%94%81%E5%AD%98%E5%99%A8%E7%9A%84%E7%89%B9%E6%80%A7%E8%A1%A8.png" alt="用或非门组成的SR锁存器的特性表"></p>
<p>其中 S<del>D</del> 和 R<del>D</del> 为是电路输入的两个端口，Q^n^ 表示电路当前的输出，Q^n+1^ 表示电路下一个状态的输出。由真值表可以看出，这个电路的输出不仅和当前输入有关，也和&#x3D;&#x3D;上一次的输出&#x3D;&#x3D;有关。显然这个电路就是一种能记住自己之前状态的电路。其实，这就是一个最简单的时序电路，我们称之为 SR 锁存器。</p>
<p>观察其功能一栏，可以看到，通过改变 S<del>D</del> 和 R<del>D</del> 为合适的值，我们可以改变电路的输出，而当 S<del>D</del> 和 R<del>D</del> 为均为 0 时，电路会一直保持原来的输出不变，这看上去很像 U 盘之类的设备（通电时能够修改存储的内容，断电时保持内容不变）。事实上，通过配合合适的外部电路，我们就可以使用这个电路来存储整个电路的状态，从而搭建起更复杂的时序电路。(其实同Memory组件里的S-R Flip-Flop器件类似)</p>
<p>常见的两种搭建方法：</p>
<p>1.使用或非门</p>
<p><img src="/img/%E6%88%96%E9%9D%9E%E9%97%A8SR%E9%94%81%E5%AD%98%E5%99%A8.jpeg" alt="图 1 使用或非门搭建的 SR 锁存器"></p>
<p>2.使用与非门</p>
<p><img src="/img/%E4%B8%8E%E9%9D%9E%E9%97%A8SR%E9%94%81%E5%AD%98%E5%99%A8.png" alt="图 2 使用与非门搭建的 SR 锁存器"></p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="基本寄存器"><a href="#基本寄存器" class="headerlink" title="基本寄存器"></a>基本寄存器</h4><h5 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h5><h6 id="时钟沿"><a href="#时钟沿" class="headerlink" title="时钟沿"></a>时钟沿</h6><p>时钟上升沿：数字时钟电路中，数字电平从低电平（数字 “0”）变为高电平（数字 “1”）的那一瞬间叫作上升沿。</p>
<p>时钟下降沿：数字时钟电路中，数字电平从高电平（数字 “1”）变为低电平（数字 “0”）的那一瞬间叫作下降沿。</p>
<h6 id="复位信号"><a href="#复位信号" class="headerlink" title="复位信号"></a>复位信号</h6><p>寄存器会接受一个外部传入的、可以将自身存储数据清零的信号。寄存器的复位信号有两种，分别是同步复位和异步复位。</p>
<p>同步复位：复位信号只有在时钟上升沿到来时，才能有效。也就是说，同步复位操作永远发生在时钟上升沿，即便复位信号提前到来，也无法立刻完成复位操作。</p>
<p>异步复位：无论时钟沿是否到来，只要复位信号有效，就对系统进行复位。</p>
<h6 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h6><p>为加快时序逻辑电路的运行速度，一个重要的手段就是提高时钟频率。但是，时钟频率是能无限增加的吗？显然不是。一个重要的限制就是寄存器之间组合逻辑电路的关键路径延迟。</p>
<p>具体来说，一个简单的时序逻辑电路如下：<img src="/img/4.4.2.1.1.png" alt="简单的时序逻辑电路"></p>
<p>两个寄存器之间的加法器，是一个组合逻辑电路。其本身存在一定的门延迟。也就是说，加法器的输入信号稳定的一段时间之后，输出信号才能稳定。如果时钟周期比这个门延迟的时间还要短，那么后面的寄存器读入的值就&#x3D;&#x3D;无法确定&#x3D;&#x3D;。</p>
<p>在寄存器之间的逻辑较为复杂的情况下，可能存在多条路径。关键路径，是指同步逻辑电路中，组合逻辑延时最大的路径。</p>
<h6 id="深入探讨"><a href="#深入探讨" class="headerlink" title="深入探讨"></a>深入探讨</h6><p>在时序逻辑电路中，会常常见到这样的情形：</p>
<p><img src="/img/4.4.2.1.2.png" alt="短路电路"></p>
<p>寄存器的输出端经过一些组合逻辑电路，链接到寄存器的输入端。</p>
<p>分析可知，当时钟上升沿来到时，数据更新为寄存器中的值 + 1。<code>a = a + 1</code>，这样的表达式十分像导致短路的电路（如果在组合逻辑电路中就是会短路的）。初学者很容易将寄存器理解为上升沿时对前一个输入信号的赋值。这样理解，确实难以解释其短路的问题。那么，在上升沿到来时，电路内部究竟发生了什么？</p>
<p>在解释这个问题之前，我们先来看下面这个例子。</p>
<p><img src="/img/4.4.2.1.3.png" alt="例子"></p>
<p>当第一个时钟上升沿到来时，左边的寄存器会赋值成 1，但右边的寄存器仍然是 0。如果是在时钟上升沿到来时，进行赋值，如何保证不会一次性让两个寄存器都变成 1 呢？</p>
<p>这两个问题事关寄存器上升沿赋值的本质。在上一节中我们谈到，寄存器本质就是一个 D 触发器。</p>
<p><img src="/img/" alt="寄存器上升沿赋值的本质"></p>
<p>它是由两个 D 锁存器构成的。D 锁存器的功能是当 CP 为高电平(1)时，Q 赋值为 D。当时钟低电平(0)时，左侧的锁存器将 D 赋值给 N1，当时钟高电平(1)时，右侧的锁存器将 N1 赋值给 Q。这个世界上本没有上升沿赋值，只有高低电平赋值。通过这样两个 D 锁存器结合形成的 D 触发器，宏观上就表现为了上升沿的赋值。这个过程有点类似于船只通过大坝的过程。先打开第一道关卡，堵第二道关卡（时钟低电平时），让船（输入数据）到中转站（N1），然后堵上第一道关卡，开第二道关卡（时钟高电平时），让船只通过。由于两个过程交替进行，宏观上就变成了，时钟在上升沿时，数据进行赋值。</p>
<h4 id="移位寄存器"><a href="#移位寄存器" class="headerlink" title="移位寄存器"></a>移位寄存器</h4><h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><h4 id="状态机的定义与行为"><a href="#状态机的定义与行为" class="headerlink" title="状态机的定义与行为"></a>状态机的定义与行为</h4><p>有限状态机（ Finite-state machine ，简称 FSM ），其所描述的是一个对象，在一段时间内，经过一系列事件后，其状态进行一系列转移的行为特征。</p>
<h5 id="状态机的构成和基本性质"><a href="#状态机的构成和基本性质" class="headerlink" title="状态机的构成和基本性质"></a>状态机的构成和基本性质</h5><p>数学定义：构成一个有限状态机的六元组为：状态集合，输入集合，输出集合，状态转移函数，输出函数，初始状态。给定以上六个集合，函数或元素，就可以确定一个有限状态机。</p>
<p>据此，有限状态机具有以下特征：</p>
<ul>
<li><p>在任何时间点，状态、输入、输出均为<strong>给定的有限种情况</strong>之一。</p>
</li>
<li><p>对于一对确定的当前状态和输入，只有一个<strong>固定且唯一</strong>的次态（下一个周期的状态）。</p>
</li>
<li><p>对于一对确定的当前状态和输入，只有一种<strong>固定且唯一</strong>的输出情况。</p>
</li>
</ul>
<h5 id="状态机的时序行为"><a href="#状态机的时序行为" class="headerlink" title="状态机的时序行为"></a>状态机的时序行为</h5><p>我们以周期为<strong>时间段的单位</strong>计时。方便起见，这里将最先到来的周期记为第 0 周期。 <strong>每个周期内不同时间点的输入可能变化，但每个周期内的状态&#x3D;&#x3D;一定不变&#x3D;&#x3D;。</strong></p>
<p>状态转移行为可以描述成如下过程：</p>
<ul>
<li>当第 0 周期开始，状态 <em>state</em> 设为初始状态 <em>state<del>0</del></em> 。</li>
<li>每当第 n 周期结束前的最后一瞬间，记该瞬间的输入为 *input<del>n</del>*。</li>
<li>每当第 n 周期结束，第 n+1 周期开始时，状态变为状态转移函数给出的次态：</li>
</ul>
<p><em>state<del>n+1</del>&#x3D;F<del>next_state</del>(state<del>n</del>,input<del>n</del>)</em></p>
<p>输出行为可以描述成如下过程：</p>
<ul>
<li>在任意周期中的任意时间点，输出为 <em>F<del>output</del>(state,input)<em>。这里的 <em>input</em> 是当前时间点的输入，</em>state</em> 是当前时间点的状态。</li>
</ul>
<h5 id="Moore-和-Mealy-状态机的区别"><a href="#Moore-和-Mealy-状态机的区别" class="headerlink" title="Moore 和 Mealy 状态机的区别"></a>Moore 和 Mealy 状态机的区别</h5><p>区分状态机类型时：<strong>当&#x3D;&#x3D;输出函数的结果&#x3D;&#x3D;会随 input 变化而改变时，该状态机为 Mealy 机，否则为 Moore 机。</strong></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>考虑一个饮食不太规律的人。这个人可能会跳过一天中的几顿饭。我们可以用状态机模拟这个人，并且分析其状态。比如：这个人吃的上顿饭是不是早饭？</p>
<h5 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h5><p>一个人的就餐状态可以划分为：上一顿是早饭，上一顿是午饭，上一顿是晚饭，三种，时间状态分：早，中，晚。这两部分构成了状态。（那就有&lt;早，早&gt;（前一个为上一顿饭，后一个为当前时间）、&lt;早，中&gt;、&lt;早，晚&gt;、&lt;中，早&gt;、&lt;晚，早&gt;、&lt;中，中&gt;、&lt;中，晚&gt;、&lt;晚，中&gt;、&lt;晚，晚&gt;共9种状态，联想到二进制数则需要高位三种、低位三种，也就是四位数表示）影响状态的因素（输入），简单起见假设只有吃东西，不吃东西两种。每逢饭点（每一周期结束或开始时），时间状态改变。如果这个人在吃饭，那么上一顿饭的内容就会发生改变。如果不在饭点，那么吃的东西并非正餐，不改变状态。</p>
<p><img src="/img/FSMstate.svg" alt="FSMstate"></p>
<p>用伪代码描述这个次态逻辑如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">状态 = &lt;上顿饭, 当前时间&gt;;<br>下一周期的上顿饭 = 吃不吃 ? 当前时间对应的饭 : 上顿饭;<br>下一周期的当前时间 = 当前时间 + 1;<br>次态 = &lt;下一周期的上顿饭, 下一周期的当前时间&gt;;<br></code></pre></td></tr></table></figure>

<h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>输出的内容与<strong>此时的输入</strong>是否有关，决定了该状态机是 Moore 机还是 Mealy 机。这是 Moore 机和 Mealy 机最根本的区别。</p>
<p>如果输出以下内容，由于输出与输入（现在吃不吃）无关，这是个 Moore 机：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">上顿饭是不是早饭 = 上顿饭 == &quot;早饭&quot; ? &quot;是&quot; : &quot;否&quot;;<br></code></pre></td></tr></table></figure>

<p>如果输出以下内容，由于输出与输入（现在吃不吃）有关，这是个 Mealy 机：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">在不在吃 = 吃不吃 ? &quot;是&quot; : &quot;否&quot;；<br></code></pre></td></tr></table></figure>

<h5 id="设计电路"><a href="#设计电路" class="headerlink" title="设计电路"></a>设计电路</h5><p><img src="/img/FSMexample.png" alt="电路"></p>
<p>之后再根据题目要求，补齐图中输出电路，设计状态机的工作就告一段落了。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>采用状态机解决问题时，状态（和状态转移）的设计对工作的难度有着至关重要的影响。设计状态机时，你应当设计好输入，状态，输出之间的关系。</p>
</li>
<li><p>完成设计过程之后，实现组合电路部分。可以参考下图。（图中是 Mealy 机的基本结构。如果你所需的结果是一个 Moore 状态机，输出电路的结果应当与状态机输入无关。）</p>
</li>
</ul>
<p><img src="/img/FSMfsm%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.svg" alt="基本框架"></p>
<p>有限状态机所需的最小位数并不是每一个子状态的位数乘以子状态个数的结果，应该是在二进制下总状态数所需的最小位数。例如：如果有9种状态则应需要至少4位，因为2^4^&#x3D;16&gt;9，而2^3^&#x3D;8&lt;9。同理若有625种状态，则应至少需要10位即可，因为2^10^&#x3D;1024&gt;625,而2^9^&#x3D;512&lt;625。</p>
<h2 id="Logisim设计指南"><a href="#Logisim设计指南" class="headerlink" title="Logisim设计指南"></a>Logisim设计指南</h2><h3 id="1-对电路进行标识（Label）"><a href="#1-对电路进行标识（Label）" class="headerlink" title="1.对电路进行标识（Label）"></a>1.对电路进行标识（Label）</h3><h3 id="2-使用适当的多路选择器（Multiplexer）"><a href="#2-使用适当的多路选择器（Multiplexer）" class="headerlink" title="2.使用适当的多路选择器（Multiplexer）"></a>2.使用适当的多路选择器（Multiplexer）</h3><h3 id="3-不要使用常量来扩展信号"><a href="#3-不要使用常量来扩展信号" class="headerlink" title="3. 不要使用常量来扩展信号"></a>3. 不要使用常量来扩展信号</h3><p>在电路中尽量避免使用常量。</p>
<h3 id="4-不要将信号和它取反的结果作为多路选择器（Multiplexer）的输入"><a href="#4-不要将信号和它取反的结果作为多路选择器（Multiplexer）的输入" class="headerlink" title="4. 不要将信号和它取反的结果作为多路选择器（Multiplexer）的输入"></a>4. 不要将信号和它取反的结果作为多路选择器（Multiplexer）的输入</h3><h3 id="5-适当使用常量"><a href="#5-适当使用常量" class="headerlink" title="5. 适当使用常量"></a>5. 适当使用常量</h3><p>正如3中提到的，在通常情况下，你绘制的电路不应需要任何常量。两种例外的情况是：</p>
<p>(a) 子电路需要的输入比你需要使用的多;</p>
<p>(b) 常量能使你的电路更加简单。每当你想要向电路中添加一个常量时，思考一下能否通过使用其他门电路来优化掉这个常量。</p>
<h3 id="6-不要将一个信号同时作为多路选择器（Multiplexer）的输入端和控制端"><a href="#6-不要将一个信号同时作为多路选择器（Multiplexer）的输入端和控制端" class="headerlink" title="6. 不要将一个信号同时作为多路选择器（Multiplexer）的输入端和控制端"></a>6. 不要将一个信号同时作为多路选择器（Multiplexer）的输入端和控制端</h3><p>这样的多路选择器可以用一个或门代替掉。</p>
<h3 id="7-学会做全面测试"><a href="#7-学会做全面测试" class="headerlink" title="7. 学会做全面测试"></a>7. 学会做全面测试</h3><p>请确认你提交的电路中不包含任何红色的连线，并且能够通过你自己构造的测试。如果你设计的电路使用二进制补码输入，请务必测试正、负数两种情况。</p>
<p>你构造的测试点至少应包括：正数+正数、正数+负数、负数+负数、负数+正数，另外不要忘记 0。</p>
<h3 id="8-使用正确的数据流方向"><a href="#8-使用正确的数据流方向" class="headerlink" title="8. 使用正确的数据流方向"></a>8. 使用正确的数据流方向</h3><p>在 Logisim 中，通常的数据流方向是&#x3D;&#x3D;由上至下&#x3D;&#x3D;、&#x3D;&#x3D;由左至右&#x3D;&#x3D;，虽然很多器件可以通过更改朝向来改变输入输出的方向，但多路选择器（Multiplexer）等器件的朝向是不能更改的。</p>
<h3 id="9-学会编辑子电路外观"><a href="#9-学会编辑子电路外观" class="headerlink" title="9. 学会编辑子电路外观"></a>9. 学会编辑子电路外观</h3><p>通常子电路的默认外观都非常丑陋，接口拥挤，而且没有注释，所以推荐大家尽可能自行编辑子电路外观，这里给出一个示例。</p>
<p><img src="/img/eg_grf_appearance.gif" alt="示例"></p>
<h3 id="10-子电路输入修改"><a href="#10-子电路输入修改" class="headerlink" title="10.子电路输入修改"></a>10.子电路输入修改</h3><p>修改时要同时修改不然在时序逻辑电路中会导致不同子电路的时序混乱。</p>
<h2 id="Logisim-自动化方法概览"><a href="#Logisim-自动化方法概览" class="headerlink" title="Logisim 自动化方法概览"></a>Logisim 自动化方法概览</h2><p>观察电路的实际储存形式，可以发现它只是 &#x3D;&#x3D;XML 代码&#x3D;&#x3D;，因此可以使用代码自动生成的方法简化操作，达到提高效率的目的，接下来我们就对方法本身进行介绍，并针对某个具体问题进行讲解。</p>
<h3 id="circ-文件与标签"><a href="#circ-文件与标签" class="headerlink" title="circ 文件与标签"></a>circ 文件与标签</h3><p>Logisim 使用的文件是 .circ 文件，它是使用扩展性标记语言编写的文件，Logisim 通过这种文件来存储电路。这是一种描述性文件，和网页用的语言 HTML 类似，可以通过直接修改文件来更改电路图。作为一种 XML 文件，它主要是被用于<strong>传输数据</strong>，而非显示数据，这是与 HTML 的不同之处，因此它的标签均是&#x3D;&#x3D;可以自定义&#x3D;&#x3D;的。只需满足如 <code>&lt;foo&gt;bar&lt;/foo&gt;</code> 式的格式即可，在 Logisim 中同样也有 Logisim 自行规定的一些标签，通过标签的类型其中比较常见的有：</p>
<ul>
<li><code>&lt;circuit&gt;</code> 是电路或子电路的标签，用于标记整个电路</li>
<li><code>&lt;wire&gt;</code> 标签，用于连线，通过 <code>x-y</code> 属性定位，需要自己尝试。</li>
<li><code>&lt;comp&gt;</code> 标签，拥有 <code>loc</code> 和 <code>name</code> 属性，用于调用库元件</li>
</ul>
<p>我们的自动化方法其实是一种半自动方法，需要我们去观察使用 <code>GUI</code> 工具搭建出来的电路，再在这个基础上进行代码生成，其实是一种<strong>聪明的复制粘贴。</strong></p>
<h3 id="以内存矩阵为例"><a href="#以内存矩阵为例" class="headerlink" title="以内存矩阵为例"></a>以内存矩阵为例</h3><p>下面我们来考虑这么一个问题：</p>
<p>假设我们现在有 8 位字长，存储容量为 256B（8 位地址）的 ROM 芯片，我们需要搭建合理的电路，将其扩展成，32 位字长，存储容量为 16KB 的 ROM（12 位地址）。ROM 芯片如图：</p>
<p><img src="/img/4.6.1.1.png" alt="ROM芯片"></p>
<p>从理论上分析，字长扩展了 4 倍，地址扩展了 4 位，因此共需 4 * 16 &#x3D; 64 块原芯片，预计是要摆出一个 16 行 4 列的芯片矩阵。看，面对如此大量的芯片，传统地在 Logisim 中“手撸”一个电路就显得十分繁琐了。因此我们需要采用自动化的方法。</p>
<p>首先我们需使用 &#x3D;&#x3D;GUI&#x3D;&#x3D; 工具拖放元件，这一步其实是非常重要的，通过合理的尝试，我们可以找到显示效果最漂亮的摆放方式，为之后的编码提供位置信息。</p>
<p><img src="/img/4.6.6.2.png" alt="漂亮的摆放方式"></p>
<p>之后我们需要观察产生的 .circ 文件，文件中我们可以发现，<code>&lt;comp&gt;</code> 标签表示对库元件的调用，用 <code>&lt;a&gt;</code> 标签表示相关的属性，<code>loc</code> 属性表示位置.每个 <code>&lt;comp&gt;</code> 标签就是一个个 ROM 芯片。我们自动化方法的核心其实就是构造一个可以被&#x3D;&#x3D;重复&#x3D;&#x3D;摆放的<strong>最小单元</strong>，而且这个最小单元往往通过 Tunnel 连带着输出一起。在本例中即是这个 <code>&lt;comp&gt;</code> 标签</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">lib</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">loc</span>=<span class="hljs-string">&quot;(420,290)&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROM&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contents&quot;</span>&gt;</span>addr/data: 8 8<br>0<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">lib</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">loc</span>=<span class="hljs-string">&quot;(260,390)&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROM&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contents&quot;</span>&gt;</span>addr/data: 8 8<br>0<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">lib</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">loc</span>=<span class="hljs-string">&quot;(260,290)&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROM&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contents&quot;</span>&gt;</span>addr/data: 8 8<br>0<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>接着我们需要编写脚本去批量生成按照规律摆放的 ROM 芯片，在此我们使用较为简单的 Python 语言去编写脚本。需要知道的是，整个自动化方法的核心就是把摆放电路这件<strong>机械重复</strong>的事，交由计算机去完成。我们只需要根据前文所确定的<strong>最小单元</strong>，与摆放的<strong>位置信息</strong>，就能够编写相应的代码来自动生成所要的部分电路 XML。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml">start_x = 260<br>start_y = 290<br>step_x = 160<br>step_y = 100<br><br>template = &quot;&quot;&quot;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">lib</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">loc</span>=<span class="hljs-string">&quot;(%d,%d)&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ROM&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contents&quot;</span>&gt;</span>addr/data: 8 8<br>0<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span><br>&quot;&quot;&quot;<br><br>result = &quot;&quot;<br>for i in range(0,4):<br>    for j in range(0,16):<br>        result += template % (start_x + step_x * i,start_y + step_y * j)<br><br>print(result)<br></code></pre></td></tr></table></figure>

<p>观察所编写的代码，其实只是将最小单位的位置信息参数化，进行重复输出而已，编写起来应该比较简单。之后我们只需将生成的 XML 黏贴到源文件中 main 下合适的部分即可。最终效果如下：</p>
<p><img src="/img/4.6.6.5.png" alt="最终效果"></p>
<p>可以注意到的是，此时我们还没有解决连线的大问题，因此我们就要使用 Tunnel 简化布线，Tunnel 元件直接不用 wire 连接在部件上组成<strong>最小单位</strong>，再进行自动化方法即可。效果如图，可以发现 Tunnel 的名字同样也参数化了，这样就可以通过有规律的 Tunnel 信号进行操作。</p>
<p><img src="/img/4.6.6.6.png" alt="效果"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>自动化方法：</p>
<p>1.尝试</p>
<p>2.发现最小单位</p>
<p>3.编写生成代码</p>
<p>4.使用XML代码</p>
<h2 id="CHALLENGE"><a href="#CHALLENGE" class="headerlink" title="CHALLENGE ! ! !"></a>CHALLENGE ! ! !</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>黄小板同学暗中观察了公司负责人很久，觉得他搭建的电路性能实在太差，他提出只需要 <strong>64</strong> 个周期就能计算出 32 位无符号整数能表示的最大数位置上的斐波那契数的（最后 32bit），在完成搭建这样的电路后，公司负责人五体投地，宣布给黄小板开出了东门烤串无限量供应的实习工资，从此黄小板每日吃串，终于吃成了黄老板…</p>
<p>那么，这个电路是什么样子的呢？</p>
<p><strong>注意：这道题是一个对你的挑战，需要一定的算法和工程能力，请谨慎思考，大胆尝试！</strong></p>
<h3 id="提交要求"><a href="#提交要求" class="headerlink" title="提交要求"></a>提交要求</h3><p><img src="/img/%E9%A2%98%E9%9D%A2%E8%A6%81%E6%B1%82.png" alt="提交要求"></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于输入N为32位无符号数，用常规的计算方法需要O(n)的时间复杂度，当N很大时，计算周期将会远远超过64。因此需要另辟蹊径。</p>
<p>首先先观察到：<br>$$<br>fib(n) &#x3D; 1 * fib(n-1) +1 * fib(n-2);fib(n-1) &#x3D; 1 * fib(n-1) + 0 * fib(n-2),(n&gt;2,n∈N;fib(n)为斐波那契数列的第n项)<br>$$<br> 为什么第二个式子的右侧要多写一个0*fib(n-2)这么一个无用项？其实是为了同第一个式子右侧做对应，方便看出$$(fib(n),fib(n-1))$$与$(fib(n-1),fib(n-2))$之间的关系。</p>
<p>利用在《工科高等代数》这门课上学到的矩阵，可以得到以下关系式：<br>$$<br>\begin{bmatrix}fib(n)\fib(n-1)\end{bmatrix}&#x3D;\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}\begin{bmatrix}fib(n-1)\fib(n-2)\end{bmatrix} (n&gt;2,n∈N)<br>$$<br>经过迭代就可以得到如下关系式：<br>$$<br>\begin{bmatrix}fib(n)\fib(n-1)\end{bmatrix}\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}^2&#x3D;\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}^n\begin{bmatrix}fib(2)\fib(1)\end{bmatrix}  (n&gt;2,n∈N)<br>$$<br>因此只需要算出$\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}$的(n-2)次幂即可，但是这样仍需要进行O(n)次矩阵相乘运算，时间复杂度并没有降低。注意到提交要求中的Hint:矩阵乘法的快速幂。</p>
<p>所谓快速幂，即是将一个数的幂运算拆解乘多个已运算得到的幂结果，进而减小运算次数，可将时间复杂度降低到O(logn)的方法。例如：若要计算a^13^一般的暴力方法即是用一个初始化为1的s存放循环相乘13次a的结果；但在快速幂方法下13&#x3D;&#x3D;0b1101，则a^13^&#x3D;a^0b1101^&#x3D;a^0b1000^ * a^0b0100^ * a^0b0001^&#x3D;a^8^ * a^4^ * a^1^&#x3D;(((a^2^)^2^))^2^ * ((a^2^))^2^ * a,此时只需要大致计算log<del>2</del>13次。因此，我们发现当计算两数相乘时，这两个数尽可能的越大，就越快接近最终结果。又因为幂运算的性质，观察到如果是偶次幂，将a^2n^直接转化为(a^n^)^2^则只需计算一次；如果是奇次幂，在偶次幂的基础上还得再多乘一次。由上述说明，定义power(a,n)为a^n^,则<br>$$<br>power(a,n)&#x3D;power(a&#x2F;2,n)^2*a (n为奇数)\power(a,n)&#x3D;power(a&#x2F;2,n)^2(n为偶数)\power(a,n)&#x3D;1(n&#x3D;&#x3D;0)<br>$$<br>由此可以得到C语言中递归代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<span class="hljs-comment">//a^2</span><br>  <span class="hljs-keyword">return</span> a*a;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">power</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//a^n</span><br>	<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">return</span> (n&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)?sqr(power(a,n/<span class="hljs-number">2</span>))*a:sqr(power(a,n/<span class="hljs-number">2</span>)); <br>&#125;<br></code></pre></td></tr></table></figure>



<p>如此一来可以大量降低时间复杂度，实现64周期内算出答案的要求，只不过在题目中，a要看作是矩阵，而乘法运算要看成是矩阵相乘。因此先封装出矩阵相乘的子电路，便于后续调用。</p>
<p><img src="/img/%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98.png" alt="矩阵相乘"></p>
<p>但是问题有出现了在硬件设计中我们无法使用递归。因此需要将上述递归方法改写为迭代的方法。观察到我们一开始将13成二进制形式的方法，可不可以对n的二进制的每一位（从低到高）进行扫描，当该位为1时就将此时的a乘入ans中（显然a要随着扫描的进行而进行更新）；反之则不做处理。由此可以得到快速幂的迭代版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">power</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> n)</span>&#123;<span class="hljs-comment">//a^n</span><br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<span class="hljs-comment">//初始化</span><br>	<span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//n==0时说明位数以移完32位或者已经没有是1的位了，此时即可跳出循环</span><br>	<span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>==<span class="hljs-number">1</span>)&#123;<br>		ans*=a;<br>	&#125;<br>	a*=a;<span class="hljs-comment">//a需要根据位数做相应的更新 </span><br>	n&gt;&gt;=<span class="hljs-number">1</span>;<span class="hljs-comment">//每次n右移将当前位推至第一位</span><br>	&#125;<br>	<span class="hljs-comment">//循环对a的次数n的二进制表示的每一位都进行扫描，若其为1则乘进ans中；若为0则无事发生。 </span><br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有了上述代码就可以进行相应的电路设计了。</p>
<p>首先，为了初始化的方便，封装两个特殊矩阵：单位阵和乘子矩阵（即<br>$$<br>\begin{bmatrix}1&amp;1\1&amp;0\end{bmatrix}<br>$$<br>）<img src="/img/%E5%8D%95%E4%BD%8D%E9%98%B5.png" alt="单位阵"><img src="/img/%E4%B9%98%E5%AD%90%E7%9F%A9%E9%98%B5.png" alt="乘子矩阵"></p>
<p>为了方便存储和初始化时以及代码中每轮循环的乘以乘子与否，再封装矩阵存储和矩阵选择两个子电路，方便计算电路的使用。</p>
<p><img src="/img/%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8.png" alt="矩阵存储"><img src="/img/%E7%9F%A9%E9%98%B5%E9%80%89%E6%8B%A9.png" alt="矩阵选择"></p>
<p>接着将代码中的循环和计算分别拆分为计时电路和计算电路：</p>
<p><img src="/img/%E8%AE%A1%E6%97%B6%E7%94%B5%E8%B7%AF.png" alt="计时电路"><img src="/img/%E8%AE%A1%E7%AE%97%E7%94%B5%E8%B7%AF.png" alt="计算电路"></p>
<p>在计时电路和计算电路中都有一个初始化器，它是由特定设置（最大值设置为1，Action on Overflow 设置为Stay at value）的counter计数器，这样一来在电路运行时会多出一个周期来进行初始化赋值（即第一个周期输出为0，之后输出均为1；输出到init在计时电路和计算电路结合多路选择器，实现初始化以及选择）。</p>
<p>再看计时电路，初始化后n被赋值为N-2（in），获取n的最低位n_lowest传给计算电路中作为ans选择不变(单位阵)还是乘以当前位上的乘子矩阵的依据，并将n同0进行比较得到freez信号，作为计算电路中计算是否停止的依据，注意：这里也要搭配多路选择器进行第一周期同之后周期的区分，因为第一个周期时，初始化与比较是同时进行的，如此得到的freeze信号将是0，会使计算电路在第一个周期停止工作，导致初始化并没有进入存储矩阵，而输入的第一位信息也没有成功进行计算，之后的值将全是0。之后计时电路将一直选择逻辑右移一位的n直到n等于0，发出freeze信号为0。</p>
<p>再看计算电路，左上端为初始化器，以及n_lowest和freeze。中间是两个“有限状态机”，上方是对于乘子矩阵的计算与存储，在初始化时选择最原始的乘子矩阵并存储赋值给a矩阵，之后每次都选择a^2^并存储赋值给a矩阵。下方的ans矩阵的计算与存储同理，根据n_lowest选择是单位阵（0）还是a矩阵（1），再同ans相乘得到ans‘矩阵在初始化部分，第一个周期选择单位阵，之后选择ans’矩阵并存储赋值给ans。</p>
<p>右上的输出电路根据freeze信号，当n！&#x3D;0时一直输出0；当n&#x3D;&#x3D;0时则输出ans_00 * fib(2)+ans_01 * fib(1),由于fib(1) &#x3D;&#x3D; fib(1) &#x3D;&#x3D; 1,所以即是输出ans_00+ans_01。</p>
<p>再在main板块中将计时电路同计算电路用电线相连即可得到所需电路。如下：</p>
<p><img src="/img/main.png" alt="总电路"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://ywxy12138.github.io">聿尛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://ywxy12138.github.io/2024/08/14/logisim/">http://ywxy12138.github.io/2024/08/14/logisim/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ywxy12138.github.io" target="_blank">yumooo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Logisim/">Logisim</a></div><div class="post_share"><div class="social-share" data-image="/img/logisim.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/13/Markdown%E8%AF%AD%E6%B3%95/" title="Markdown语法"><img class="cover" src="/img/markdown.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Markdown语法</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/14/Python/" title="python"><img class="cover" src="/img/python.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E8%8A%B1%E9%AC%98.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">聿尛</div><div class="author-info__description">孤独永恒，死亡永生。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ywxy12138"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">无可奈何花落去，似曾相识燕归来！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Logisim"><span class="toc-number">1.</span> <span class="toc-text">Logisim</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Logisim%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">Logisim简介：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">特点:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logisim%E9%97%A8%E7%94%B5%E8%B7%AF"><span class="toc-number">1.2.</span> <span class="toc-text">Logisim门电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%B8%83%E5%B1%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">工具布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E4%BB%B6%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%8D%E6%AD%A2%E9%97%A8%E7%94%B5%E8%B7%AF%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">元件概览（不止门电路）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Wiring-%E7%BA%BF%E8%B7%AF-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Wiring(线路) 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Splitter"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">Splitter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Probe"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">Probe</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Tunnel"><span class="toc-number">1.2.2.1.3.</span> <span class="toc-text">Tunnel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Pull-Resistor"><span class="toc-number">1.2.2.1.4.</span> <span class="toc-text">Pull Resistor</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior"><span class="toc-number">1.2.2.1.4.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Pins"><span class="toc-number">1.2.2.1.4.2.</span> <span class="toc-text">Pins</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Attributes"><span class="toc-number">1.2.2.1.4.3.</span> <span class="toc-text">Attributes</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Clock"><span class="toc-number">1.2.2.1.5.</span> <span class="toc-text">Clock</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior-1"><span class="toc-number">1.2.2.1.5.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Pins-1"><span class="toc-number">1.2.2.1.5.2.</span> <span class="toc-text">Pins</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Attributes-1"><span class="toc-number">1.2.2.1.5.3.</span> <span class="toc-text">Attributes</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Poke-Tool-Behavior"><span class="toc-number">1.2.2.1.5.4.</span> <span class="toc-text">Poke Tool Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Text-Tool-Behavior"><span class="toc-number">1.2.2.1.5.5.</span> <span class="toc-text">Text Tool Behavior</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Constant"><span class="toc-number">1.2.2.1.6.</span> <span class="toc-text">Constant</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior-2"><span class="toc-number">1.2.2.1.6.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Pins-2"><span class="toc-number">1.2.2.1.6.2.</span> <span class="toc-text">Pins</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Attributes-2"><span class="toc-number">1.2.2.1.6.3.</span> <span class="toc-text">Attributes</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Power-Ground"><span class="toc-number">1.2.2.1.7.</span> <span class="toc-text">Power&#x2F;Ground</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior-3"><span class="toc-number">1.2.2.1.7.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Pins-3"><span class="toc-number">1.2.2.1.7.2.</span> <span class="toc-text">Pins</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Attributes-3"><span class="toc-number">1.2.2.1.7.3.</span> <span class="toc-text">Attributes</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Transistor"><span class="toc-number">1.2.2.1.8.</span> <span class="toc-text">Transistor</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior-4"><span class="toc-number">1.2.2.1.8.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Pins-assuming-component-faces-east-gate-line-top-left"><span class="toc-number">1.2.2.1.8.2.</span> <span class="toc-text">Pins (assuming component faces east, gate line top&#x2F;left)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Transmission-Gate"><span class="toc-number">1.2.2.1.9.</span> <span class="toc-text">Transmission Gate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bit-Extender"><span class="toc-number">1.2.2.1.10.</span> <span class="toc-text">Bit Extender</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior-5"><span class="toc-number">1.2.2.1.10.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Pins-4"><span class="toc-number">1.2.2.1.10.2.</span> <span class="toc-text">Pins</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Attributes-4"><span class="toc-number">1.2.2.1.10.3.</span> <span class="toc-text">Attributes</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gates-%E9%80%BB%E8%BE%91%E9%97%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Gates(逻辑门) 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior-6"><span class="toc-number">1.2.2.2.0.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Attributes-5"><span class="toc-number">1.2.2.2.0.2.</span> <span class="toc-text">Attributes</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#XOR-%E5%BC%82%E6%88%96-XNOR-%E5%90%8C%E6%88%96-Odd-Parity-%E5%A5%87%E6%A3%80%E9%AA%8C-Even-Parity-%E5%81%B6%E6%A3%80%E9%AA%8C-Gate"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">XOR(异或)&#x2F;XNOR(同或)&#x2F;Odd Parity(奇检验)&#x2F;Even Parity(偶检验) Gate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Controlled-Buffer-Inverter"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">Controlled Buffer&#x2F;Inverter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Plexers-%E5%A4%8D%E7%94%A8%E5%99%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">Plexers(复用器)组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Multiplexer"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">Multiplexer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Demultiplexer"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">Demultiplexer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Decoder"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">Decoder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Priority-Encoder"><span class="toc-number">1.2.2.3.4.</span> <span class="toc-text">Priority Encoder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bit-Selector"><span class="toc-number">1.2.2.3.5.</span> <span class="toc-text">Bit Selector</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arithmetic-%E8%BF%90%E7%AE%97%E5%99%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">Arithmetic(运算器)组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Adder"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">Adder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Subtractor"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">Subtractor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Multiplier"><span class="toc-number">1.2.2.4.3.</span> <span class="toc-text">Multiplier</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Divider"><span class="toc-number">1.2.2.4.4.</span> <span class="toc-text">Divider</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Negator"><span class="toc-number">1.2.2.4.5.</span> <span class="toc-text">Negator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Comparator"><span class="toc-number">1.2.2.4.6.</span> <span class="toc-text">Comparator</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shifter"><span class="toc-number">1.2.2.4.7.</span> <span class="toc-text">Shifter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bit-Adder"><span class="toc-number">1.2.2.4.8.</span> <span class="toc-text">Bit Adder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bit-Finder"><span class="toc-number">1.2.2.4.9.</span> <span class="toc-text">Bit Finder</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-%E5%AD%98%E5%82%A8-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">Memory(存储)组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#D-T-J-K-S-R-Flip-Flop"><span class="toc-number">1.2.2.5.1.</span> <span class="toc-text">D&#x2F;T&#x2F;J-K&#x2F;S-R Flip-Flop</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#D-Flip-Flop"><span class="toc-number">1.2.2.5.1.1.</span> <span class="toc-text">D Flip-Flop</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#T-Flip-Flop"><span class="toc-number">1.2.2.5.1.2.</span> <span class="toc-text">T Flip-Flop</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#J-K-Flip-Flop"><span class="toc-number">1.2.2.5.1.3.</span> <span class="toc-text">J-K Flip-Flop</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#S-R-Flip-Flop"><span class="toc-number">1.2.2.5.1.4.</span> <span class="toc-text">S-R Flip-Flop</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A4%E5%A4%96"><span class="toc-number">1.2.2.5.1.5.</span> <span class="toc-text">此外</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Register"><span class="toc-number">1.2.2.5.2.</span> <span class="toc-text">Register</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Counter"><span class="toc-number">1.2.2.5.3.</span> <span class="toc-text">Counter</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Behavior-7"><span class="toc-number">1.2.2.5.3.1.</span> <span class="toc-text">Behavior</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Attributes-6"><span class="toc-number">1.2.2.5.3.2.</span> <span class="toc-text">Attributes</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Shift-Register"><span class="toc-number">1.2.2.5.4.</span> <span class="toc-text">Shift Register</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Random"><span class="toc-number">1.2.2.5.5.</span> <span class="toc-text">Random</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RAM%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.2.5.6.</span> <span class="toc-text">RAM存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ROM%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.2.5.7.</span> <span class="toc-text">ROM存储器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Input-Output-%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA-%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">Input&#x2F;Output(输入&#x2F;输出)组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Base%EF%BC%88%E5%9F%BA%E6%9C%AC%EF%BC%89%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">Base（基本）组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.2.3.</span> <span class="toc-text">例：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E5%BC%82%E6%88%96%E7%94%B5%E8%B7%AF"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">搭建异或电路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logisim%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF"><span class="toc-number">1.3.</span> <span class="toc-text">Logisim组合电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%94%B5%E8%B7%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">子电路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%90%E7%94%B5%E8%B7%AF"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">创建子电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%AD%90%E7%94%B5%E8%B7%AF%E5%86%85%E5%AE%B9"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">添加子电路内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%90%E7%94%B5%E8%B7%AF%E5%A4%96%E8%A7%82"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">设置子电路外观</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%AD%90%E7%94%B5%E8%B7%AF"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">引用子电路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Wire-colors"><span class="toc-number">1.3.2.</span> <span class="toc-text">Wire colors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Logisim%E8%BF%9B%E8%A1%8C%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">利用Logisim进行组合逻辑分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">三种主要技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logisim%E6%97%B6%E5%BA%8F%E7%94%B5%E8%B7%AF"><span class="toc-number">1.4.</span> <span class="toc-text">Logisim时序电路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SR%E9%94%81%E5%AD%98%E5%99%A8%EF%BC%88SR-latch%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">SR锁存器（SR latch）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">基本寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">一些概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%B2%BF"><span class="toc-number">1.4.2.1.1.1.</span> <span class="toc-text">时钟沿</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.4.2.1.1.2.</span> <span class="toc-text">复位信号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.2.1.1.3.</span> <span class="toc-text">关键路径</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E8%AE%A8"><span class="toc-number">1.4.2.1.1.4.</span> <span class="toc-text">深入探讨</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">移位寄存器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">1.4.3.</span> <span class="toc-text">有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">状态机的定义与行为</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E6%9E%84%E6%88%90%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">1.4.3.1.1.</span> <span class="toc-text">状态机的构成和基本性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E6%97%B6%E5%BA%8F%E8%A1%8C%E4%B8%BA"><span class="toc-number">1.4.3.1.2.</span> <span class="toc-text">状态机的时序行为</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Moore-%E5%92%8C-Mealy-%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.1.3.</span> <span class="toc-text">Moore 和 Mealy 状态机的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.4.3.2.1.</span> <span class="toc-text">状态转移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.4.3.2.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%94%B5%E8%B7%AF"><span class="toc-number">1.4.3.2.3.</span> <span class="toc-text">设计电路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logisim%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97"><span class="toc-number">1.5.</span> <span class="toc-text">Logisim设计指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E7%94%B5%E8%B7%AF%E8%BF%9B%E8%A1%8C%E6%A0%87%E8%AF%86%EF%BC%88Label%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.对电路进行标识（Label）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E9%80%82%E5%BD%93%E7%9A%84%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%88Multiplexer%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.使用适当的多路选择器（Multiplexer）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E6%9D%A5%E6%89%A9%E5%B1%95%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.5.3.</span> <span class="toc-text">3. 不要使用常量来扩展信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%8D%E8%A6%81%E5%B0%86%E4%BF%A1%E5%8F%B7%E5%92%8C%E5%AE%83%E5%8F%96%E5%8F%8D%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BD%9C%E4%B8%BA%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%88Multiplexer%EF%BC%89%E7%9A%84%E8%BE%93%E5%85%A5"><span class="toc-number">1.5.4.</span> <span class="toc-text">4. 不要将信号和它取反的结果作为多路选择器（Multiplexer）的输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%82%E5%BD%93%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F"><span class="toc-number">1.5.5.</span> <span class="toc-text">5. 适当使用常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%8D%E8%A6%81%E5%B0%86%E4%B8%80%E4%B8%AA%E4%BF%A1%E5%8F%B7%E5%90%8C%E6%97%B6%E4%BD%9C%E4%B8%BA%E5%A4%9A%E8%B7%AF%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%88Multiplexer%EF%BC%89%E7%9A%84%E8%BE%93%E5%85%A5%E7%AB%AF%E5%92%8C%E6%8E%A7%E5%88%B6%E7%AB%AF"><span class="toc-number">1.5.6.</span> <span class="toc-text">6. 不要将一个信号同时作为多路选择器（Multiplexer）的输入端和控制端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AD%A6%E4%BC%9A%E5%81%9A%E5%85%A8%E9%9D%A2%E6%B5%8B%E8%AF%95"><span class="toc-number">1.5.7.</span> <span class="toc-text">7. 学会做全面测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E6%96%B9%E5%90%91"><span class="toc-number">1.5.8.</span> <span class="toc-text">8. 使用正确的数据流方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%AD%A6%E4%BC%9A%E7%BC%96%E8%BE%91%E5%AD%90%E7%94%B5%E8%B7%AF%E5%A4%96%E8%A7%82"><span class="toc-number">1.5.9.</span> <span class="toc-text">9. 学会编辑子电路外观</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AD%90%E7%94%B5%E8%B7%AF%E8%BE%93%E5%85%A5%E4%BF%AE%E6%94%B9"><span class="toc-number">1.5.10.</span> <span class="toc-text">10.子电路输入修改</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Logisim-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%96%B9%E6%B3%95%E6%A6%82%E8%A7%88"><span class="toc-number">1.6.</span> <span class="toc-text">Logisim 自动化方法概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#circ-%E6%96%87%E4%BB%B6%E4%B8%8E%E6%A0%87%E7%AD%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">circ 文件与标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%86%85%E5%AD%98%E7%9F%A9%E9%98%B5%E4%B8%BA%E4%BE%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">以内存矩阵为例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.6.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CHALLENGE"><span class="toc-number">1.7.</span> <span class="toc-text">CHALLENGE ! ! !</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E9%9D%A2"><span class="toc-number">1.7.1.</span> <span class="toc-text">题面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E8%A6%81%E6%B1%82"><span class="toc-number">1.7.2.</span> <span class="toc-text">提交要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.7.3.</span> <span class="toc-text">思路</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/Git/" title="Git"><img src="/img/GIT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git"/></a><div class="content"><a class="title" href="/2024/09/09/Git/" title="Git">Git</a><time datetime="2024-09-09T04:48:31.000Z" title="发表于 2024-09-09 12:48:31">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/09/English/" title="English"><img src="/img/English.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="English"/></a><div class="content"><a class="title" href="/2024/09/09/English/" title="English">English</a><time datetime="2024-09-09T02:04:08.000Z" title="发表于 2024-09-09 10:04:08">2024-09-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/07/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="超级计算机"><img src="/img/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="超级计算机"/></a><div class="content"><a class="title" href="/2024/09/07/%E8%B6%85%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="超级计算机">超级计算机</a><time datetime="2024-09-07T06:45:15.000Z" title="发表于 2024-09-07 14:45:15">2024-09-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/05/oopre/" title="oopre"><img src="/img/java.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="oopre"/></a><div class="content"><a class="title" href="/2024/09/05/oopre/" title="oopre">oopre</a><time datetime="2024-09-05T06:05:14.000Z" title="发表于 2024-09-05 14:05:14">2024-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/03/MIPS/" title="MIPS"><img src="/img/MIPS.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MIPS"/></a><div class="content"><a class="title" href="/2024/09/03/MIPS/" title="MIPS">MIPS</a><time datetime="2024-09-03T12:51:51.000Z" title="发表于 2024-09-03 20:51:51">2024-09-03</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 聿尛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello, welcome to my <a target="_blank" rel="noopener" href="https://yumooo.cn">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>